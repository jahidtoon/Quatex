
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model currency_pairs
 * 
 */
export type currency_pairs = $Result.DefaultSelection<Prisma.$currency_pairsPayload>
/**
 * Model forex_candles
 * 
 */
export type forex_candles = $Result.DefaultSelection<Prisma.$forex_candlesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model deposits
 * 
 */
export type deposits = $Result.DefaultSelection<Prisma.$depositsPayload>
/**
 * Model withdrawals
 * 
 */
export type withdrawals = $Result.DefaultSelection<Prisma.$withdrawalsPayload>
/**
 * Model trades
 * 
 */
export type trades = $Result.DefaultSelection<Prisma.$tradesPayload>
/**
 * Model leaderboard
 * 
 */
export type leaderboard = $Result.DefaultSelection<Prisma.$leaderboardPayload>
/**
 * Model tournaments
 * 
 */
export type tournaments = $Result.DefaultSelection<Prisma.$tournamentsPayload>
/**
 * Model support_messages
 * 
 */
export type support_messages = $Result.DefaultSelection<Prisma.$support_messagesPayload>
/**
 * Model chat_messages
 * 
 */
export type chat_messages = $Result.DefaultSelection<Prisma.$chat_messagesPayload>
/**
 * Model settings
 * 
 */
export type settings = $Result.DefaultSelection<Prisma.$settingsPayload>
/**
 * Model crypto_assets
 * 
 */
export type crypto_assets = $Result.DefaultSelection<Prisma.$crypto_assetsPayload>
/**
 * Model deposit_sessions
 * 
 */
export type deposit_sessions = $Result.DefaultSelection<Prisma.$deposit_sessionsPayload>
/**
 * Model wallet_ledger
 * 
 */
export type wallet_ledger = $Result.DefaultSelection<Prisma.$wallet_ledgerPayload>
/**
 * Model payment_method_templates
 * 
 */
export type payment_method_templates = $Result.DefaultSelection<Prisma.$payment_method_templatesPayload>
/**
 * Model p2p_offers
 * 
 */
export type p2p_offers = $Result.DefaultSelection<Prisma.$p2p_offersPayload>
/**
 * Model user_payment_methods
 * 
 */
export type user_payment_methods = $Result.DefaultSelection<Prisma.$user_payment_methodsPayload>
/**
 * Model p2p_offer_payment_methods
 * 
 */
export type p2p_offer_payment_methods = $Result.DefaultSelection<Prisma.$p2p_offer_payment_methodsPayload>
/**
 * Model p2p_orders
 * 
 */
export type p2p_orders = $Result.DefaultSelection<Prisma.$p2p_ordersPayload>
/**
 * Model p2p_messages
 * 
 */
export type p2p_messages = $Result.DefaultSelection<Prisma.$p2p_messagesPayload>
/**
 * Model p2p_disputes
 * 
 */
export type p2p_disputes = $Result.DefaultSelection<Prisma.$p2p_disputesPayload>
/**
 * Model p2p_ratings
 * 
 */
export type p2p_ratings = $Result.DefaultSelection<Prisma.$p2p_ratingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PairStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DISABLED: 'DISABLED',
  INACTIVE: 'INACTIVE'
};

export type PairStatus = (typeof PairStatus)[keyof typeof PairStatus]


export const DepositSessionStatus: {
  PENDING: 'PENDING',
  DETECTED: 'DETECTED',
  CONFIRMED: 'CONFIRMED',
  PARTIAL: 'PARTIAL',
  EXPIRED: 'EXPIRED',
  LATE_CONFIRMED: 'LATE_CONFIRMED',
  FAILED: 'FAILED'
};

export type DepositSessionStatus = (typeof DepositSessionStatus)[keyof typeof DepositSessionStatus]


export const LedgerType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL',
  ADJUST: 'ADJUST',
  P2P_ESCROW_HOLD: 'P2P_ESCROW_HOLD',
  P2P_ESCROW_RELEASE: 'P2P_ESCROW_RELEASE',
  P2P_ESCROW_REFUND: 'P2P_ESCROW_REFUND',
  P2P_FEE: 'P2P_FEE'
};

export type LedgerType = (typeof LedgerType)[keyof typeof LedgerType]


export const P2POrderSide: {
  BUY: 'BUY',
  SELL: 'SELL'
};

export type P2POrderSide = (typeof P2POrderSide)[keyof typeof P2POrderSide]


export const P2POfferStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  CLOSED: 'CLOSED'
};

export type P2POfferStatus = (typeof P2POfferStatus)[keyof typeof P2POfferStatus]


export const P2PTradeStatus: {
  PENDING: 'PENDING',
  WAITING_PAYMENT: 'WAITING_PAYMENT',
  PAID: 'PAID',
  ESCROW_HELD: 'ESCROW_HELD',
  RELEASED: 'RELEASED',
  CANCELED: 'CANCELED',
  DISPUTED: 'DISPUTED',
  REFUNDED: 'REFUNDED',
  EXPIRED: 'EXPIRED'
};

export type P2PTradeStatus = (typeof P2PTradeStatus)[keyof typeof P2PTradeStatus]


export const P2PDisputeStatus: {
  OPEN: 'OPEN',
  RESOLVED: 'RESOLVED',
  CANCELED: 'CANCELED'
};

export type P2PDisputeStatus = (typeof P2PDisputeStatus)[keyof typeof P2PDisputeStatus]


export const PaymentMethodType: {
  BKASH: 'BKASH',
  NAGAD: 'NAGAD',
  BANK: 'BANK',
  CARDBANK: 'CARDBANK',
  OTHERS: 'OTHERS'
};

export type PaymentMethodType = (typeof PaymentMethodType)[keyof typeof PaymentMethodType]

}

export type PairStatus = $Enums.PairStatus

export const PairStatus: typeof $Enums.PairStatus

export type DepositSessionStatus = $Enums.DepositSessionStatus

export const DepositSessionStatus: typeof $Enums.DepositSessionStatus

export type LedgerType = $Enums.LedgerType

export const LedgerType: typeof $Enums.LedgerType

export type P2POrderSide = $Enums.P2POrderSide

export const P2POrderSide: typeof $Enums.P2POrderSide

export type P2POfferStatus = $Enums.P2POfferStatus

export const P2POfferStatus: typeof $Enums.P2POfferStatus

export type P2PTradeStatus = $Enums.P2PTradeStatus

export const P2PTradeStatus: typeof $Enums.P2PTradeStatus

export type P2PDisputeStatus = $Enums.P2PDisputeStatus

export const P2PDisputeStatus: typeof $Enums.P2PDisputeStatus

export type PaymentMethodType = $Enums.PaymentMethodType

export const PaymentMethodType: typeof $Enums.PaymentMethodType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Currency_pairs
 * const currency_pairs = await prisma.currency_pairs.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Currency_pairs
   * const currency_pairs = await prisma.currency_pairs.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.currency_pairs`: Exposes CRUD operations for the **currency_pairs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currency_pairs
    * const currency_pairs = await prisma.currency_pairs.findMany()
    * ```
    */
  get currency_pairs(): Prisma.currency_pairsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forex_candles`: Exposes CRUD operations for the **forex_candles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forex_candles
    * const forex_candles = await prisma.forex_candles.findMany()
    * ```
    */
  get forex_candles(): Prisma.forex_candlesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposits`: Exposes CRUD operations for the **deposits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposits
    * const deposits = await prisma.deposits.findMany()
    * ```
    */
  get deposits(): Prisma.depositsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawals`: Exposes CRUD operations for the **withdrawals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawals.findMany()
    * ```
    */
  get withdrawals(): Prisma.withdrawalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trades`: Exposes CRUD operations for the **trades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trades.findMany()
    * ```
    */
  get trades(): Prisma.tradesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.leaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournaments`: Exposes CRUD operations for the **tournaments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournaments.findMany()
    * ```
    */
  get tournaments(): Prisma.tournamentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_messages`: Exposes CRUD operations for the **support_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_messages
    * const support_messages = await prisma.support_messages.findMany()
    * ```
    */
  get support_messages(): Prisma.support_messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_messages`: Exposes CRUD operations for the **chat_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_messages
    * const chat_messages = await prisma.chat_messages.findMany()
    * ```
    */
  get chat_messages(): Prisma.chat_messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crypto_assets`: Exposes CRUD operations for the **crypto_assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crypto_assets
    * const crypto_assets = await prisma.crypto_assets.findMany()
    * ```
    */
  get crypto_assets(): Prisma.crypto_assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposit_sessions`: Exposes CRUD operations for the **deposit_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposit_sessions
    * const deposit_sessions = await prisma.deposit_sessions.findMany()
    * ```
    */
  get deposit_sessions(): Prisma.deposit_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet_ledger`: Exposes CRUD operations for the **wallet_ledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_ledgers
    * const wallet_ledgers = await prisma.wallet_ledger.findMany()
    * ```
    */
  get wallet_ledger(): Prisma.wallet_ledgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_method_templates`: Exposes CRUD operations for the **payment_method_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_method_templates
    * const payment_method_templates = await prisma.payment_method_templates.findMany()
    * ```
    */
  get payment_method_templates(): Prisma.payment_method_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2p_offers`: Exposes CRUD operations for the **p2p_offers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2p_offers
    * const p2p_offers = await prisma.p2p_offers.findMany()
    * ```
    */
  get p2p_offers(): Prisma.p2p_offersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_payment_methods`: Exposes CRUD operations for the **user_payment_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_payment_methods
    * const user_payment_methods = await prisma.user_payment_methods.findMany()
    * ```
    */
  get user_payment_methods(): Prisma.user_payment_methodsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2p_offer_payment_methods`: Exposes CRUD operations for the **p2p_offer_payment_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2p_offer_payment_methods
    * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findMany()
    * ```
    */
  get p2p_offer_payment_methods(): Prisma.p2p_offer_payment_methodsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2p_orders`: Exposes CRUD operations for the **p2p_orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2p_orders
    * const p2p_orders = await prisma.p2p_orders.findMany()
    * ```
    */
  get p2p_orders(): Prisma.p2p_ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2p_messages`: Exposes CRUD operations for the **p2p_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2p_messages
    * const p2p_messages = await prisma.p2p_messages.findMany()
    * ```
    */
  get p2p_messages(): Prisma.p2p_messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2p_disputes`: Exposes CRUD operations for the **p2p_disputes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2p_disputes
    * const p2p_disputes = await prisma.p2p_disputes.findMany()
    * ```
    */
  get p2p_disputes(): Prisma.p2p_disputesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2p_ratings`: Exposes CRUD operations for the **p2p_ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2p_ratings
    * const p2p_ratings = await prisma.p2p_ratings.findMany()
    * ```
    */
  get p2p_ratings(): Prisma.p2p_ratingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    currency_pairs: 'currency_pairs',
    forex_candles: 'forex_candles',
    users: 'users',
    deposits: 'deposits',
    withdrawals: 'withdrawals',
    trades: 'trades',
    leaderboard: 'leaderboard',
    tournaments: 'tournaments',
    support_messages: 'support_messages',
    chat_messages: 'chat_messages',
    settings: 'settings',
    crypto_assets: 'crypto_assets',
    deposit_sessions: 'deposit_sessions',
    wallet_ledger: 'wallet_ledger',
    payment_method_templates: 'payment_method_templates',
    p2p_offers: 'p2p_offers',
    user_payment_methods: 'user_payment_methods',
    p2p_offer_payment_methods: 'p2p_offer_payment_methods',
    p2p_orders: 'p2p_orders',
    p2p_messages: 'p2p_messages',
    p2p_disputes: 'p2p_disputes',
    p2p_ratings: 'p2p_ratings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "currency_pairs" | "forex_candles" | "users" | "deposits" | "withdrawals" | "trades" | "leaderboard" | "tournaments" | "support_messages" | "chat_messages" | "settings" | "crypto_assets" | "deposit_sessions" | "wallet_ledger" | "payment_method_templates" | "p2p_offers" | "user_payment_methods" | "p2p_offer_payment_methods" | "p2p_orders" | "p2p_messages" | "p2p_disputes" | "p2p_ratings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      currency_pairs: {
        payload: Prisma.$currency_pairsPayload<ExtArgs>
        fields: Prisma.currency_pairsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.currency_pairsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.currency_pairsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>
          }
          findFirst: {
            args: Prisma.currency_pairsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.currency_pairsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>
          }
          findMany: {
            args: Prisma.currency_pairsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>[]
          }
          create: {
            args: Prisma.currency_pairsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>
          }
          createMany: {
            args: Prisma.currency_pairsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.currency_pairsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>[]
          }
          delete: {
            args: Prisma.currency_pairsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>
          }
          update: {
            args: Prisma.currency_pairsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>
          }
          deleteMany: {
            args: Prisma.currency_pairsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.currency_pairsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.currency_pairsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>[]
          }
          upsert: {
            args: Prisma.currency_pairsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currency_pairsPayload>
          }
          aggregate: {
            args: Prisma.Currency_pairsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency_pairs>
          }
          groupBy: {
            args: Prisma.currency_pairsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Currency_pairsGroupByOutputType>[]
          }
          count: {
            args: Prisma.currency_pairsCountArgs<ExtArgs>
            result: $Utils.Optional<Currency_pairsCountAggregateOutputType> | number
          }
        }
      }
      forex_candles: {
        payload: Prisma.$forex_candlesPayload<ExtArgs>
        fields: Prisma.forex_candlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.forex_candlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.forex_candlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>
          }
          findFirst: {
            args: Prisma.forex_candlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.forex_candlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>
          }
          findMany: {
            args: Prisma.forex_candlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>[]
          }
          create: {
            args: Prisma.forex_candlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>
          }
          createMany: {
            args: Prisma.forex_candlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.forex_candlesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>[]
          }
          delete: {
            args: Prisma.forex_candlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>
          }
          update: {
            args: Prisma.forex_candlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>
          }
          deleteMany: {
            args: Prisma.forex_candlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.forex_candlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.forex_candlesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>[]
          }
          upsert: {
            args: Prisma.forex_candlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forex_candlesPayload>
          }
          aggregate: {
            args: Prisma.Forex_candlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForex_candles>
          }
          groupBy: {
            args: Prisma.forex_candlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Forex_candlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.forex_candlesCountArgs<ExtArgs>
            result: $Utils.Optional<Forex_candlesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      deposits: {
        payload: Prisma.$depositsPayload<ExtArgs>
        fields: Prisma.depositsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.depositsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.depositsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>
          }
          findFirst: {
            args: Prisma.depositsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.depositsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>
          }
          findMany: {
            args: Prisma.depositsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>[]
          }
          create: {
            args: Prisma.depositsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>
          }
          createMany: {
            args: Prisma.depositsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.depositsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>[]
          }
          delete: {
            args: Prisma.depositsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>
          }
          update: {
            args: Prisma.depositsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>
          }
          deleteMany: {
            args: Prisma.depositsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.depositsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.depositsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>[]
          }
          upsert: {
            args: Prisma.depositsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositsPayload>
          }
          aggregate: {
            args: Prisma.DepositsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposits>
          }
          groupBy: {
            args: Prisma.depositsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositsGroupByOutputType>[]
          }
          count: {
            args: Prisma.depositsCountArgs<ExtArgs>
            result: $Utils.Optional<DepositsCountAggregateOutputType> | number
          }
        }
      }
      withdrawals: {
        payload: Prisma.$withdrawalsPayload<ExtArgs>
        fields: Prisma.withdrawalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.withdrawalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.withdrawalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>
          }
          findFirst: {
            args: Prisma.withdrawalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.withdrawalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>
          }
          findMany: {
            args: Prisma.withdrawalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>[]
          }
          create: {
            args: Prisma.withdrawalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>
          }
          createMany: {
            args: Prisma.withdrawalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.withdrawalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>[]
          }
          delete: {
            args: Prisma.withdrawalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>
          }
          update: {
            args: Prisma.withdrawalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>
          }
          deleteMany: {
            args: Prisma.withdrawalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.withdrawalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.withdrawalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>[]
          }
          upsert: {
            args: Prisma.withdrawalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalsPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawals>
          }
          groupBy: {
            args: Prisma.withdrawalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.withdrawalsCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalsCountAggregateOutputType> | number
          }
        }
      }
      trades: {
        payload: Prisma.$tradesPayload<ExtArgs>
        fields: Prisma.tradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tradesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tradesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          findFirst: {
            args: Prisma.tradesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tradesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          findMany: {
            args: Prisma.tradesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>[]
          }
          create: {
            args: Prisma.tradesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          createMany: {
            args: Prisma.tradesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tradesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>[]
          }
          delete: {
            args: Prisma.tradesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          update: {
            args: Prisma.tradesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          deleteMany: {
            args: Prisma.tradesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tradesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tradesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>[]
          }
          upsert: {
            args: Prisma.tradesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          aggregate: {
            args: Prisma.TradesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrades>
          }
          groupBy: {
            args: Prisma.tradesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tradesCountArgs<ExtArgs>
            result: $Utils.Optional<TradesCountAggregateOutputType> | number
          }
        }
      }
      leaderboard: {
        payload: Prisma.$leaderboardPayload<ExtArgs>
        fields: Prisma.leaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>
          }
          findFirst: {
            args: Prisma.leaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>
          }
          findMany: {
            args: Prisma.leaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>[]
          }
          create: {
            args: Prisma.leaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>
          }
          createMany: {
            args: Prisma.leaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.leaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>[]
          }
          delete: {
            args: Prisma.leaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>
          }
          update: {
            args: Prisma.leaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>
          }
          deleteMany: {
            args: Prisma.leaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.leaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.leaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>[]
          }
          upsert: {
            args: Prisma.leaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.leaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.leaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
      tournaments: {
        payload: Prisma.$tournamentsPayload<ExtArgs>
        fields: Prisma.tournamentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          findFirst: {
            args: Prisma.tournamentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          findMany: {
            args: Prisma.tournamentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          create: {
            args: Prisma.tournamentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          createMany: {
            args: Prisma.tournamentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          delete: {
            args: Prisma.tournamentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          update: {
            args: Prisma.tournamentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          deleteMany: {
            args: Prisma.tournamentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          upsert: {
            args: Prisma.tournamentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          aggregate: {
            args: Prisma.TournamentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournaments>
          }
          groupBy: {
            args: Prisma.tournamentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentsCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentsCountAggregateOutputType> | number
          }
        }
      }
      support_messages: {
        payload: Prisma.$support_messagesPayload<ExtArgs>
        fields: Prisma.support_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>
          }
          findFirst: {
            args: Prisma.support_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>
          }
          findMany: {
            args: Prisma.support_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>[]
          }
          create: {
            args: Prisma.support_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>
          }
          createMany: {
            args: Prisma.support_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>[]
          }
          delete: {
            args: Prisma.support_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>
          }
          update: {
            args: Prisma.support_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>
          }
          deleteMany: {
            args: Prisma.support_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>[]
          }
          upsert: {
            args: Prisma.support_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_messagesPayload>
          }
          aggregate: {
            args: Prisma.Support_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_messages>
          }
          groupBy: {
            args: Prisma.support_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_messagesCountAggregateOutputType> | number
          }
        }
      }
      chat_messages: {
        payload: Prisma.$chat_messagesPayload<ExtArgs>
        fields: Prisma.chat_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findFirst: {
            args: Prisma.chat_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findMany: {
            args: Prisma.chat_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          create: {
            args: Prisma.chat_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          createMany: {
            args: Prisma.chat_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          delete: {
            args: Prisma.chat_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          update: {
            args: Prisma.chat_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          deleteMany: {
            args: Prisma.chat_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          upsert: {
            args: Prisma.chat_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          aggregate: {
            args: Prisma.Chat_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_messages>
          }
          groupBy: {
            args: Prisma.chat_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesCountAggregateOutputType> | number
          }
        }
      }
      settings: {
        payload: Prisma.$settingsPayload<ExtArgs>
        fields: Prisma.settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.settingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      crypto_assets: {
        payload: Prisma.$crypto_assetsPayload<ExtArgs>
        fields: Prisma.crypto_assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crypto_assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crypto_assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>
          }
          findFirst: {
            args: Prisma.crypto_assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crypto_assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>
          }
          findMany: {
            args: Prisma.crypto_assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>[]
          }
          create: {
            args: Prisma.crypto_assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>
          }
          createMany: {
            args: Prisma.crypto_assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.crypto_assetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>[]
          }
          delete: {
            args: Prisma.crypto_assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>
          }
          update: {
            args: Prisma.crypto_assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>
          }
          deleteMany: {
            args: Prisma.crypto_assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.crypto_assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.crypto_assetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>[]
          }
          upsert: {
            args: Prisma.crypto_assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_assetsPayload>
          }
          aggregate: {
            args: Prisma.Crypto_assetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrypto_assets>
          }
          groupBy: {
            args: Prisma.crypto_assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Crypto_assetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.crypto_assetsCountArgs<ExtArgs>
            result: $Utils.Optional<Crypto_assetsCountAggregateOutputType> | number
          }
        }
      }
      deposit_sessions: {
        payload: Prisma.$deposit_sessionsPayload<ExtArgs>
        fields: Prisma.deposit_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deposit_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deposit_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>
          }
          findFirst: {
            args: Prisma.deposit_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deposit_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>
          }
          findMany: {
            args: Prisma.deposit_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>[]
          }
          create: {
            args: Prisma.deposit_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>
          }
          createMany: {
            args: Prisma.deposit_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.deposit_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>[]
          }
          delete: {
            args: Prisma.deposit_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>
          }
          update: {
            args: Prisma.deposit_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.deposit_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deposit_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.deposit_sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>[]
          }
          upsert: {
            args: Prisma.deposit_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deposit_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Deposit_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposit_sessions>
          }
          groupBy: {
            args: Prisma.deposit_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Deposit_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.deposit_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Deposit_sessionsCountAggregateOutputType> | number
          }
        }
      }
      wallet_ledger: {
        payload: Prisma.$wallet_ledgerPayload<ExtArgs>
        fields: Prisma.wallet_ledgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_ledgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_ledgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>
          }
          findFirst: {
            args: Prisma.wallet_ledgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_ledgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>
          }
          findMany: {
            args: Prisma.wallet_ledgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>[]
          }
          create: {
            args: Prisma.wallet_ledgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>
          }
          createMany: {
            args: Prisma.wallet_ledgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wallet_ledgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>[]
          }
          delete: {
            args: Prisma.wallet_ledgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>
          }
          update: {
            args: Prisma.wallet_ledgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>
          }
          deleteMany: {
            args: Prisma.wallet_ledgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_ledgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.wallet_ledgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>[]
          }
          upsert: {
            args: Prisma.wallet_ledgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_ledgerPayload>
          }
          aggregate: {
            args: Prisma.Wallet_ledgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_ledger>
          }
          groupBy: {
            args: Prisma.wallet_ledgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_ledgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_ledgerCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_ledgerCountAggregateOutputType> | number
          }
        }
      }
      payment_method_templates: {
        payload: Prisma.$payment_method_templatesPayload<ExtArgs>
        fields: Prisma.payment_method_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_method_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_method_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>
          }
          findFirst: {
            args: Prisma.payment_method_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_method_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>
          }
          findMany: {
            args: Prisma.payment_method_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>[]
          }
          create: {
            args: Prisma.payment_method_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>
          }
          createMany: {
            args: Prisma.payment_method_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_method_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>[]
          }
          delete: {
            args: Prisma.payment_method_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>
          }
          update: {
            args: Prisma.payment_method_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>
          }
          deleteMany: {
            args: Prisma.payment_method_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_method_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_method_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>[]
          }
          upsert: {
            args: Prisma.payment_method_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_method_templatesPayload>
          }
          aggregate: {
            args: Prisma.Payment_method_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_method_templates>
          }
          groupBy: {
            args: Prisma.payment_method_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_method_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_method_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_method_templatesCountAggregateOutputType> | number
          }
        }
      }
      p2p_offers: {
        payload: Prisma.$p2p_offersPayload<ExtArgs>
        fields: Prisma.p2p_offersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2p_offersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2p_offersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>
          }
          findFirst: {
            args: Prisma.p2p_offersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2p_offersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>
          }
          findMany: {
            args: Prisma.p2p_offersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>[]
          }
          create: {
            args: Prisma.p2p_offersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>
          }
          createMany: {
            args: Prisma.p2p_offersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2p_offersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>[]
          }
          delete: {
            args: Prisma.p2p_offersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>
          }
          update: {
            args: Prisma.p2p_offersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>
          }
          deleteMany: {
            args: Prisma.p2p_offersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2p_offersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2p_offersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>[]
          }
          upsert: {
            args: Prisma.p2p_offersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offersPayload>
          }
          aggregate: {
            args: Prisma.P2p_offersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2p_offers>
          }
          groupBy: {
            args: Prisma.p2p_offersGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2p_offersGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2p_offersCountArgs<ExtArgs>
            result: $Utils.Optional<P2p_offersCountAggregateOutputType> | number
          }
        }
      }
      user_payment_methods: {
        payload: Prisma.$user_payment_methodsPayload<ExtArgs>
        fields: Prisma.user_payment_methodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_payment_methodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_payment_methodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          findFirst: {
            args: Prisma.user_payment_methodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_payment_methodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          findMany: {
            args: Prisma.user_payment_methodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          create: {
            args: Prisma.user_payment_methodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          createMany: {
            args: Prisma.user_payment_methodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_payment_methodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          delete: {
            args: Prisma.user_payment_methodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          update: {
            args: Prisma.user_payment_methodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          deleteMany: {
            args: Prisma.user_payment_methodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_payment_methodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_payment_methodsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          upsert: {
            args: Prisma.user_payment_methodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          aggregate: {
            args: Prisma.User_payment_methodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_payment_methods>
          }
          groupBy: {
            args: Prisma.user_payment_methodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_payment_methodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_payment_methodsCountArgs<ExtArgs>
            result: $Utils.Optional<User_payment_methodsCountAggregateOutputType> | number
          }
        }
      }
      p2p_offer_payment_methods: {
        payload: Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>
        fields: Prisma.p2p_offer_payment_methodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2p_offer_payment_methodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2p_offer_payment_methodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>
          }
          findFirst: {
            args: Prisma.p2p_offer_payment_methodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2p_offer_payment_methodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>
          }
          findMany: {
            args: Prisma.p2p_offer_payment_methodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>[]
          }
          create: {
            args: Prisma.p2p_offer_payment_methodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>
          }
          createMany: {
            args: Prisma.p2p_offer_payment_methodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2p_offer_payment_methodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>[]
          }
          delete: {
            args: Prisma.p2p_offer_payment_methodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>
          }
          update: {
            args: Prisma.p2p_offer_payment_methodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>
          }
          deleteMany: {
            args: Prisma.p2p_offer_payment_methodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2p_offer_payment_methodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2p_offer_payment_methodsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>[]
          }
          upsert: {
            args: Prisma.p2p_offer_payment_methodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_offer_payment_methodsPayload>
          }
          aggregate: {
            args: Prisma.P2p_offer_payment_methodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2p_offer_payment_methods>
          }
          groupBy: {
            args: Prisma.p2p_offer_payment_methodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2p_offer_payment_methodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2p_offer_payment_methodsCountArgs<ExtArgs>
            result: $Utils.Optional<P2p_offer_payment_methodsCountAggregateOutputType> | number
          }
        }
      }
      p2p_orders: {
        payload: Prisma.$p2p_ordersPayload<ExtArgs>
        fields: Prisma.p2p_ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2p_ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2p_ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>
          }
          findFirst: {
            args: Prisma.p2p_ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2p_ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>
          }
          findMany: {
            args: Prisma.p2p_ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>[]
          }
          create: {
            args: Prisma.p2p_ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>
          }
          createMany: {
            args: Prisma.p2p_ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2p_ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>[]
          }
          delete: {
            args: Prisma.p2p_ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>
          }
          update: {
            args: Prisma.p2p_ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>
          }
          deleteMany: {
            args: Prisma.p2p_ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2p_ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2p_ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>[]
          }
          upsert: {
            args: Prisma.p2p_ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ordersPayload>
          }
          aggregate: {
            args: Prisma.P2p_ordersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2p_orders>
          }
          groupBy: {
            args: Prisma.p2p_ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2p_ordersGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2p_ordersCountArgs<ExtArgs>
            result: $Utils.Optional<P2p_ordersCountAggregateOutputType> | number
          }
        }
      }
      p2p_messages: {
        payload: Prisma.$p2p_messagesPayload<ExtArgs>
        fields: Prisma.p2p_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2p_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2p_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>
          }
          findFirst: {
            args: Prisma.p2p_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2p_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>
          }
          findMany: {
            args: Prisma.p2p_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>[]
          }
          create: {
            args: Prisma.p2p_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>
          }
          createMany: {
            args: Prisma.p2p_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2p_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>[]
          }
          delete: {
            args: Prisma.p2p_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>
          }
          update: {
            args: Prisma.p2p_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>
          }
          deleteMany: {
            args: Prisma.p2p_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2p_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2p_messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>[]
          }
          upsert: {
            args: Prisma.p2p_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_messagesPayload>
          }
          aggregate: {
            args: Prisma.P2p_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2p_messages>
          }
          groupBy: {
            args: Prisma.p2p_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2p_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2p_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<P2p_messagesCountAggregateOutputType> | number
          }
        }
      }
      p2p_disputes: {
        payload: Prisma.$p2p_disputesPayload<ExtArgs>
        fields: Prisma.p2p_disputesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2p_disputesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2p_disputesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>
          }
          findFirst: {
            args: Prisma.p2p_disputesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2p_disputesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>
          }
          findMany: {
            args: Prisma.p2p_disputesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>[]
          }
          create: {
            args: Prisma.p2p_disputesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>
          }
          createMany: {
            args: Prisma.p2p_disputesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2p_disputesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>[]
          }
          delete: {
            args: Prisma.p2p_disputesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>
          }
          update: {
            args: Prisma.p2p_disputesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>
          }
          deleteMany: {
            args: Prisma.p2p_disputesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2p_disputesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2p_disputesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>[]
          }
          upsert: {
            args: Prisma.p2p_disputesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_disputesPayload>
          }
          aggregate: {
            args: Prisma.P2p_disputesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2p_disputes>
          }
          groupBy: {
            args: Prisma.p2p_disputesGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2p_disputesGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2p_disputesCountArgs<ExtArgs>
            result: $Utils.Optional<P2p_disputesCountAggregateOutputType> | number
          }
        }
      }
      p2p_ratings: {
        payload: Prisma.$p2p_ratingsPayload<ExtArgs>
        fields: Prisma.p2p_ratingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2p_ratingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2p_ratingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>
          }
          findFirst: {
            args: Prisma.p2p_ratingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2p_ratingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>
          }
          findMany: {
            args: Prisma.p2p_ratingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>[]
          }
          create: {
            args: Prisma.p2p_ratingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>
          }
          createMany: {
            args: Prisma.p2p_ratingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2p_ratingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>[]
          }
          delete: {
            args: Prisma.p2p_ratingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>
          }
          update: {
            args: Prisma.p2p_ratingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>
          }
          deleteMany: {
            args: Prisma.p2p_ratingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2p_ratingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2p_ratingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>[]
          }
          upsert: {
            args: Prisma.p2p_ratingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2p_ratingsPayload>
          }
          aggregate: {
            args: Prisma.P2p_ratingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2p_ratings>
          }
          groupBy: {
            args: Prisma.p2p_ratingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2p_ratingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2p_ratingsCountArgs<ExtArgs>
            result: $Utils.Optional<P2p_ratingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    currency_pairs?: currency_pairsOmit
    forex_candles?: forex_candlesOmit
    users?: usersOmit
    deposits?: depositsOmit
    withdrawals?: withdrawalsOmit
    trades?: tradesOmit
    leaderboard?: leaderboardOmit
    tournaments?: tournamentsOmit
    support_messages?: support_messagesOmit
    chat_messages?: chat_messagesOmit
    settings?: settingsOmit
    crypto_assets?: crypto_assetsOmit
    deposit_sessions?: deposit_sessionsOmit
    wallet_ledger?: wallet_ledgerOmit
    payment_method_templates?: payment_method_templatesOmit
    p2p_offers?: p2p_offersOmit
    user_payment_methods?: user_payment_methodsOmit
    p2p_offer_payment_methods?: p2p_offer_payment_methodsOmit
    p2p_orders?: p2p_ordersOmit
    p2p_messages?: p2p_messagesOmit
    p2p_disputes?: p2p_disputesOmit
    p2p_ratings?: p2p_ratingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    chat_messages: number
    deposits: number
    leaderboard: number
    settings: number
    support_messages: number
    trades: number
    withdrawals: number
    deposit_sessions: number
    wallet_ledger: number
    p2p_offers: number
    user_payment_methods: number
    p2p_maker_orders: number
    p2p_taker_orders: number
    p2p_messages_sent: number
    p2p_disputes_raised: number
    p2p_ratings_from: number
    p2p_ratings_to: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | UsersCountOutputTypeCountChat_messagesArgs
    deposits?: boolean | UsersCountOutputTypeCountDepositsArgs
    leaderboard?: boolean | UsersCountOutputTypeCountLeaderboardArgs
    settings?: boolean | UsersCountOutputTypeCountSettingsArgs
    support_messages?: boolean | UsersCountOutputTypeCountSupport_messagesArgs
    trades?: boolean | UsersCountOutputTypeCountTradesArgs
    withdrawals?: boolean | UsersCountOutputTypeCountWithdrawalsArgs
    deposit_sessions?: boolean | UsersCountOutputTypeCountDeposit_sessionsArgs
    wallet_ledger?: boolean | UsersCountOutputTypeCountWallet_ledgerArgs
    p2p_offers?: boolean | UsersCountOutputTypeCountP2p_offersArgs
    user_payment_methods?: boolean | UsersCountOutputTypeCountUser_payment_methodsArgs
    p2p_maker_orders?: boolean | UsersCountOutputTypeCountP2p_maker_ordersArgs
    p2p_taker_orders?: boolean | UsersCountOutputTypeCountP2p_taker_ordersArgs
    p2p_messages_sent?: boolean | UsersCountOutputTypeCountP2p_messages_sentArgs
    p2p_disputes_raised?: boolean | UsersCountOutputTypeCountP2p_disputes_raisedArgs
    p2p_ratings_from?: boolean | UsersCountOutputTypeCountP2p_ratings_fromArgs
    p2p_ratings_to?: boolean | UsersCountOutputTypeCountP2p_ratings_toArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: depositsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leaderboardWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSupport_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tradesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWithdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: withdrawalsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDeposit_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deposit_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWallet_ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_ledgerWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_offersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_payment_methodsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_maker_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ordersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_taker_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ordersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_messages_sentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_disputes_raisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_disputesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_ratings_fromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ratingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountP2p_ratings_toArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ratingsWhereInput
  }


  /**
   * Count Type Crypto_assetsCountOutputType
   */

  export type Crypto_assetsCountOutputType = {
    deposit_sessions: number
  }

  export type Crypto_assetsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit_sessions?: boolean | Crypto_assetsCountOutputTypeCountDeposit_sessionsArgs
  }

  // Custom InputTypes
  /**
   * Crypto_assetsCountOutputType without action
   */
  export type Crypto_assetsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crypto_assetsCountOutputType
     */
    select?: Crypto_assetsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Crypto_assetsCountOutputType without action
   */
  export type Crypto_assetsCountOutputTypeCountDeposit_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deposit_sessionsWhereInput
  }


  /**
   * Count Type P2p_offersCountOutputType
   */

  export type P2p_offersCountOutputType = {
    payment_methods: number
    orders: number
  }

  export type P2p_offersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_methods?: boolean | P2p_offersCountOutputTypeCountPayment_methodsArgs
    orders?: boolean | P2p_offersCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * P2p_offersCountOutputType without action
   */
  export type P2p_offersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2p_offersCountOutputType
     */
    select?: P2p_offersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * P2p_offersCountOutputType without action
   */
  export type P2p_offersCountOutputTypeCountPayment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_offer_payment_methodsWhereInput
  }

  /**
   * P2p_offersCountOutputType without action
   */
  export type P2p_offersCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ordersWhereInput
  }


  /**
   * Count Type User_payment_methodsCountOutputType
   */

  export type User_payment_methodsCountOutputType = {
    offers: number
  }

  export type User_payment_methodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | User_payment_methodsCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * User_payment_methodsCountOutputType without action
   */
  export type User_payment_methodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_payment_methodsCountOutputType
     */
    select?: User_payment_methodsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_payment_methodsCountOutputType without action
   */
  export type User_payment_methodsCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_offer_payment_methodsWhereInput
  }


  /**
   * Count Type P2p_ordersCountOutputType
   */

  export type P2p_ordersCountOutputType = {
    messages: number
    disputes: number
    ratings: number
  }

  export type P2p_ordersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | P2p_ordersCountOutputTypeCountMessagesArgs
    disputes?: boolean | P2p_ordersCountOutputTypeCountDisputesArgs
    ratings?: boolean | P2p_ordersCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * P2p_ordersCountOutputType without action
   */
  export type P2p_ordersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2p_ordersCountOutputType
     */
    select?: P2p_ordersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * P2p_ordersCountOutputType without action
   */
  export type P2p_ordersCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_messagesWhereInput
  }

  /**
   * P2p_ordersCountOutputType without action
   */
  export type P2p_ordersCountOutputTypeCountDisputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_disputesWhereInput
  }

  /**
   * P2p_ordersCountOutputType without action
   */
  export type P2p_ordersCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ratingsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model currency_pairs
   */

  export type AggregateCurrency_pairs = {
    _count: Currency_pairsCountAggregateOutputType | null
    _avg: Currency_pairsAvgAggregateOutputType | null
    _sum: Currency_pairsSumAggregateOutputType | null
    _min: Currency_pairsMinAggregateOutputType | null
    _max: Currency_pairsMaxAggregateOutputType | null
  }

  export type Currency_pairsAvgAggregateOutputType = {
    price_decimals: number | null
    payout: number | null
    latest_price: Decimal | null
  }

  export type Currency_pairsSumAggregateOutputType = {
    price_decimals: number | null
    payout: number | null
    latest_price: Decimal | null
  }

  export type Currency_pairsMinAggregateOutputType = {
    id: string | null
    base: string | null
    quote: string | null
    symbol: string | null
    display: string | null
    provider: string | null
    provider_symbol: string | null
    price_decimals: number | null
    status: $Enums.PairStatus | null
    payout: number | null
    latest_price: Decimal | null
    last_updated: Date | null
    isDeleted: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Currency_pairsMaxAggregateOutputType = {
    id: string | null
    base: string | null
    quote: string | null
    symbol: string | null
    display: string | null
    provider: string | null
    provider_symbol: string | null
    price_decimals: number | null
    status: $Enums.PairStatus | null
    payout: number | null
    latest_price: Decimal | null
    last_updated: Date | null
    isDeleted: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Currency_pairsCountAggregateOutputType = {
    id: number
    base: number
    quote: number
    symbol: number
    display: number
    provider: number
    provider_symbol: number
    price_decimals: number
    status: number
    payout: number
    latest_price: number
    last_updated: number
    isDeleted: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Currency_pairsAvgAggregateInputType = {
    price_decimals?: true
    payout?: true
    latest_price?: true
  }

  export type Currency_pairsSumAggregateInputType = {
    price_decimals?: true
    payout?: true
    latest_price?: true
  }

  export type Currency_pairsMinAggregateInputType = {
    id?: true
    base?: true
    quote?: true
    symbol?: true
    display?: true
    provider?: true
    provider_symbol?: true
    price_decimals?: true
    status?: true
    payout?: true
    latest_price?: true
    last_updated?: true
    isDeleted?: true
    created_at?: true
    updated_at?: true
  }

  export type Currency_pairsMaxAggregateInputType = {
    id?: true
    base?: true
    quote?: true
    symbol?: true
    display?: true
    provider?: true
    provider_symbol?: true
    price_decimals?: true
    status?: true
    payout?: true
    latest_price?: true
    last_updated?: true
    isDeleted?: true
    created_at?: true
    updated_at?: true
  }

  export type Currency_pairsCountAggregateInputType = {
    id?: true
    base?: true
    quote?: true
    symbol?: true
    display?: true
    provider?: true
    provider_symbol?: true
    price_decimals?: true
    status?: true
    payout?: true
    latest_price?: true
    last_updated?: true
    isDeleted?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Currency_pairsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which currency_pairs to aggregate.
     */
    where?: currency_pairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currency_pairs to fetch.
     */
    orderBy?: currency_pairsOrderByWithRelationInput | currency_pairsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: currency_pairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currency_pairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currency_pairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned currency_pairs
    **/
    _count?: true | Currency_pairsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Currency_pairsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Currency_pairsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Currency_pairsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Currency_pairsMaxAggregateInputType
  }

  export type GetCurrency_pairsAggregateType<T extends Currency_pairsAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency_pairs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency_pairs[P]>
      : GetScalarType<T[P], AggregateCurrency_pairs[P]>
  }




  export type currency_pairsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: currency_pairsWhereInput
    orderBy?: currency_pairsOrderByWithAggregationInput | currency_pairsOrderByWithAggregationInput[]
    by: Currency_pairsScalarFieldEnum[] | Currency_pairsScalarFieldEnum
    having?: currency_pairsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Currency_pairsCountAggregateInputType | true
    _avg?: Currency_pairsAvgAggregateInputType
    _sum?: Currency_pairsSumAggregateInputType
    _min?: Currency_pairsMinAggregateInputType
    _max?: Currency_pairsMaxAggregateInputType
  }

  export type Currency_pairsGroupByOutputType = {
    id: string
    base: string
    quote: string
    symbol: string
    display: string | null
    provider: string | null
    provider_symbol: string | null
    price_decimals: number | null
    status: $Enums.PairStatus
    payout: number | null
    latest_price: Decimal | null
    last_updated: Date | null
    isDeleted: boolean
    created_at: Date
    updated_at: Date
    _count: Currency_pairsCountAggregateOutputType | null
    _avg: Currency_pairsAvgAggregateOutputType | null
    _sum: Currency_pairsSumAggregateOutputType | null
    _min: Currency_pairsMinAggregateOutputType | null
    _max: Currency_pairsMaxAggregateOutputType | null
  }

  type GetCurrency_pairsGroupByPayload<T extends currency_pairsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Currency_pairsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Currency_pairsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Currency_pairsGroupByOutputType[P]>
            : GetScalarType<T[P], Currency_pairsGroupByOutputType[P]>
        }
      >
    >


  export type currency_pairsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    base?: boolean
    quote?: boolean
    symbol?: boolean
    display?: boolean
    provider?: boolean
    provider_symbol?: boolean
    price_decimals?: boolean
    status?: boolean
    payout?: boolean
    latest_price?: boolean
    last_updated?: boolean
    isDeleted?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["currency_pairs"]>

  export type currency_pairsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    base?: boolean
    quote?: boolean
    symbol?: boolean
    display?: boolean
    provider?: boolean
    provider_symbol?: boolean
    price_decimals?: boolean
    status?: boolean
    payout?: boolean
    latest_price?: boolean
    last_updated?: boolean
    isDeleted?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["currency_pairs"]>

  export type currency_pairsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    base?: boolean
    quote?: boolean
    symbol?: boolean
    display?: boolean
    provider?: boolean
    provider_symbol?: boolean
    price_decimals?: boolean
    status?: boolean
    payout?: boolean
    latest_price?: boolean
    last_updated?: boolean
    isDeleted?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["currency_pairs"]>

  export type currency_pairsSelectScalar = {
    id?: boolean
    base?: boolean
    quote?: boolean
    symbol?: boolean
    display?: boolean
    provider?: boolean
    provider_symbol?: boolean
    price_decimals?: boolean
    status?: boolean
    payout?: boolean
    latest_price?: boolean
    last_updated?: boolean
    isDeleted?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type currency_pairsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "base" | "quote" | "symbol" | "display" | "provider" | "provider_symbol" | "price_decimals" | "status" | "payout" | "latest_price" | "last_updated" | "isDeleted" | "created_at" | "updated_at", ExtArgs["result"]["currency_pairs"]>

  export type $currency_pairsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "currency_pairs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      base: string
      quote: string
      symbol: string
      display: string | null
      provider: string | null
      provider_symbol: string | null
      price_decimals: number | null
      status: $Enums.PairStatus
      payout: number | null
      latest_price: Prisma.Decimal | null
      last_updated: Date | null
      isDeleted: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["currency_pairs"]>
    composites: {}
  }

  type currency_pairsGetPayload<S extends boolean | null | undefined | currency_pairsDefaultArgs> = $Result.GetResult<Prisma.$currency_pairsPayload, S>

  type currency_pairsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<currency_pairsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Currency_pairsCountAggregateInputType | true
    }

  export interface currency_pairsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['currency_pairs'], meta: { name: 'currency_pairs' } }
    /**
     * Find zero or one Currency_pairs that matches the filter.
     * @param {currency_pairsFindUniqueArgs} args - Arguments to find a Currency_pairs
     * @example
     * // Get one Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends currency_pairsFindUniqueArgs>(args: SelectSubset<T, currency_pairsFindUniqueArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency_pairs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {currency_pairsFindUniqueOrThrowArgs} args - Arguments to find a Currency_pairs
     * @example
     * // Get one Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends currency_pairsFindUniqueOrThrowArgs>(args: SelectSubset<T, currency_pairsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency_pairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currency_pairsFindFirstArgs} args - Arguments to find a Currency_pairs
     * @example
     * // Get one Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends currency_pairsFindFirstArgs>(args?: SelectSubset<T, currency_pairsFindFirstArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency_pairs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currency_pairsFindFirstOrThrowArgs} args - Arguments to find a Currency_pairs
     * @example
     * // Get one Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends currency_pairsFindFirstOrThrowArgs>(args?: SelectSubset<T, currency_pairsFindFirstOrThrowArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currency_pairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currency_pairsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.findMany()
     * 
     * // Get first 10 Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currency_pairsWithIdOnly = await prisma.currency_pairs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends currency_pairsFindManyArgs>(args?: SelectSubset<T, currency_pairsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency_pairs.
     * @param {currency_pairsCreateArgs} args - Arguments to create a Currency_pairs.
     * @example
     * // Create one Currency_pairs
     * const Currency_pairs = await prisma.currency_pairs.create({
     *   data: {
     *     // ... data to create a Currency_pairs
     *   }
     * })
     * 
     */
    create<T extends currency_pairsCreateArgs>(args: SelectSubset<T, currency_pairsCreateArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currency_pairs.
     * @param {currency_pairsCreateManyArgs} args - Arguments to create many Currency_pairs.
     * @example
     * // Create many Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends currency_pairsCreateManyArgs>(args?: SelectSubset<T, currency_pairsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currency_pairs and returns the data saved in the database.
     * @param {currency_pairsCreateManyAndReturnArgs} args - Arguments to create many Currency_pairs.
     * @example
     * // Create many Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currency_pairs and only return the `id`
     * const currency_pairsWithIdOnly = await prisma.currency_pairs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends currency_pairsCreateManyAndReturnArgs>(args?: SelectSubset<T, currency_pairsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency_pairs.
     * @param {currency_pairsDeleteArgs} args - Arguments to delete one Currency_pairs.
     * @example
     * // Delete one Currency_pairs
     * const Currency_pairs = await prisma.currency_pairs.delete({
     *   where: {
     *     // ... filter to delete one Currency_pairs
     *   }
     * })
     * 
     */
    delete<T extends currency_pairsDeleteArgs>(args: SelectSubset<T, currency_pairsDeleteArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency_pairs.
     * @param {currency_pairsUpdateArgs} args - Arguments to update one Currency_pairs.
     * @example
     * // Update one Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends currency_pairsUpdateArgs>(args: SelectSubset<T, currency_pairsUpdateArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currency_pairs.
     * @param {currency_pairsDeleteManyArgs} args - Arguments to filter Currency_pairs to delete.
     * @example
     * // Delete a few Currency_pairs
     * const { count } = await prisma.currency_pairs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends currency_pairsDeleteManyArgs>(args?: SelectSubset<T, currency_pairsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currency_pairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currency_pairsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends currency_pairsUpdateManyArgs>(args: SelectSubset<T, currency_pairsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currency_pairs and returns the data updated in the database.
     * @param {currency_pairsUpdateManyAndReturnArgs} args - Arguments to update many Currency_pairs.
     * @example
     * // Update many Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currency_pairs and only return the `id`
     * const currency_pairsWithIdOnly = await prisma.currency_pairs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends currency_pairsUpdateManyAndReturnArgs>(args: SelectSubset<T, currency_pairsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency_pairs.
     * @param {currency_pairsUpsertArgs} args - Arguments to update or create a Currency_pairs.
     * @example
     * // Update or create a Currency_pairs
     * const currency_pairs = await prisma.currency_pairs.upsert({
     *   create: {
     *     // ... data to create a Currency_pairs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency_pairs we want to update
     *   }
     * })
     */
    upsert<T extends currency_pairsUpsertArgs>(args: SelectSubset<T, currency_pairsUpsertArgs<ExtArgs>>): Prisma__currency_pairsClient<$Result.GetResult<Prisma.$currency_pairsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currency_pairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currency_pairsCountArgs} args - Arguments to filter Currency_pairs to count.
     * @example
     * // Count the number of Currency_pairs
     * const count = await prisma.currency_pairs.count({
     *   where: {
     *     // ... the filter for the Currency_pairs we want to count
     *   }
     * })
    **/
    count<T extends currency_pairsCountArgs>(
      args?: Subset<T, currency_pairsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Currency_pairsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency_pairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Currency_pairsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Currency_pairsAggregateArgs>(args: Subset<T, Currency_pairsAggregateArgs>): Prisma.PrismaPromise<GetCurrency_pairsAggregateType<T>>

    /**
     * Group by Currency_pairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currency_pairsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends currency_pairsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: currency_pairsGroupByArgs['orderBy'] }
        : { orderBy?: currency_pairsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, currency_pairsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrency_pairsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the currency_pairs model
   */
  readonly fields: currency_pairsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for currency_pairs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__currency_pairsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the currency_pairs model
   */
  interface currency_pairsFieldRefs {
    readonly id: FieldRef<"currency_pairs", 'String'>
    readonly base: FieldRef<"currency_pairs", 'String'>
    readonly quote: FieldRef<"currency_pairs", 'String'>
    readonly symbol: FieldRef<"currency_pairs", 'String'>
    readonly display: FieldRef<"currency_pairs", 'String'>
    readonly provider: FieldRef<"currency_pairs", 'String'>
    readonly provider_symbol: FieldRef<"currency_pairs", 'String'>
    readonly price_decimals: FieldRef<"currency_pairs", 'Int'>
    readonly status: FieldRef<"currency_pairs", 'PairStatus'>
    readonly payout: FieldRef<"currency_pairs", 'Int'>
    readonly latest_price: FieldRef<"currency_pairs", 'Decimal'>
    readonly last_updated: FieldRef<"currency_pairs", 'DateTime'>
    readonly isDeleted: FieldRef<"currency_pairs", 'Boolean'>
    readonly created_at: FieldRef<"currency_pairs", 'DateTime'>
    readonly updated_at: FieldRef<"currency_pairs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * currency_pairs findUnique
   */
  export type currency_pairsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * Filter, which currency_pairs to fetch.
     */
    where: currency_pairsWhereUniqueInput
  }

  /**
   * currency_pairs findUniqueOrThrow
   */
  export type currency_pairsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * Filter, which currency_pairs to fetch.
     */
    where: currency_pairsWhereUniqueInput
  }

  /**
   * currency_pairs findFirst
   */
  export type currency_pairsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * Filter, which currency_pairs to fetch.
     */
    where?: currency_pairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currency_pairs to fetch.
     */
    orderBy?: currency_pairsOrderByWithRelationInput | currency_pairsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currency_pairs.
     */
    cursor?: currency_pairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currency_pairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currency_pairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currency_pairs.
     */
    distinct?: Currency_pairsScalarFieldEnum | Currency_pairsScalarFieldEnum[]
  }

  /**
   * currency_pairs findFirstOrThrow
   */
  export type currency_pairsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * Filter, which currency_pairs to fetch.
     */
    where?: currency_pairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currency_pairs to fetch.
     */
    orderBy?: currency_pairsOrderByWithRelationInput | currency_pairsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currency_pairs.
     */
    cursor?: currency_pairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currency_pairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currency_pairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currency_pairs.
     */
    distinct?: Currency_pairsScalarFieldEnum | Currency_pairsScalarFieldEnum[]
  }

  /**
   * currency_pairs findMany
   */
  export type currency_pairsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * Filter, which currency_pairs to fetch.
     */
    where?: currency_pairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currency_pairs to fetch.
     */
    orderBy?: currency_pairsOrderByWithRelationInput | currency_pairsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing currency_pairs.
     */
    cursor?: currency_pairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currency_pairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currency_pairs.
     */
    skip?: number
    distinct?: Currency_pairsScalarFieldEnum | Currency_pairsScalarFieldEnum[]
  }

  /**
   * currency_pairs create
   */
  export type currency_pairsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * The data needed to create a currency_pairs.
     */
    data: XOR<currency_pairsCreateInput, currency_pairsUncheckedCreateInput>
  }

  /**
   * currency_pairs createMany
   */
  export type currency_pairsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many currency_pairs.
     */
    data: currency_pairsCreateManyInput | currency_pairsCreateManyInput[]
  }

  /**
   * currency_pairs createManyAndReturn
   */
  export type currency_pairsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * The data used to create many currency_pairs.
     */
    data: currency_pairsCreateManyInput | currency_pairsCreateManyInput[]
  }

  /**
   * currency_pairs update
   */
  export type currency_pairsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * The data needed to update a currency_pairs.
     */
    data: XOR<currency_pairsUpdateInput, currency_pairsUncheckedUpdateInput>
    /**
     * Choose, which currency_pairs to update.
     */
    where: currency_pairsWhereUniqueInput
  }

  /**
   * currency_pairs updateMany
   */
  export type currency_pairsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update currency_pairs.
     */
    data: XOR<currency_pairsUpdateManyMutationInput, currency_pairsUncheckedUpdateManyInput>
    /**
     * Filter which currency_pairs to update
     */
    where?: currency_pairsWhereInput
    /**
     * Limit how many currency_pairs to update.
     */
    limit?: number
  }

  /**
   * currency_pairs updateManyAndReturn
   */
  export type currency_pairsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * The data used to update currency_pairs.
     */
    data: XOR<currency_pairsUpdateManyMutationInput, currency_pairsUncheckedUpdateManyInput>
    /**
     * Filter which currency_pairs to update
     */
    where?: currency_pairsWhereInput
    /**
     * Limit how many currency_pairs to update.
     */
    limit?: number
  }

  /**
   * currency_pairs upsert
   */
  export type currency_pairsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * The filter to search for the currency_pairs to update in case it exists.
     */
    where: currency_pairsWhereUniqueInput
    /**
     * In case the currency_pairs found by the `where` argument doesn't exist, create a new currency_pairs with this data.
     */
    create: XOR<currency_pairsCreateInput, currency_pairsUncheckedCreateInput>
    /**
     * In case the currency_pairs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<currency_pairsUpdateInput, currency_pairsUncheckedUpdateInput>
  }

  /**
   * currency_pairs delete
   */
  export type currency_pairsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
    /**
     * Filter which currency_pairs to delete.
     */
    where: currency_pairsWhereUniqueInput
  }

  /**
   * currency_pairs deleteMany
   */
  export type currency_pairsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which currency_pairs to delete
     */
    where?: currency_pairsWhereInput
    /**
     * Limit how many currency_pairs to delete.
     */
    limit?: number
  }

  /**
   * currency_pairs without action
   */
  export type currency_pairsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency_pairs
     */
    select?: currency_pairsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency_pairs
     */
    omit?: currency_pairsOmit<ExtArgs> | null
  }


  /**
   * Model forex_candles
   */

  export type AggregateForex_candles = {
    _count: Forex_candlesCountAggregateOutputType | null
    _avg: Forex_candlesAvgAggregateOutputType | null
    _sum: Forex_candlesSumAggregateOutputType | null
    _min: Forex_candlesMinAggregateOutputType | null
    _max: Forex_candlesMaxAggregateOutputType | null
  }

  export type Forex_candlesAvgAggregateOutputType = {
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
  }

  export type Forex_candlesSumAggregateOutputType = {
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
  }

  export type Forex_candlesMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    interval: string | null
    time: Date | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Forex_candlesMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    interval: string | null
    time: Date | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Forex_candlesCountAggregateOutputType = {
    id: number
    symbol: number
    interval: number
    time: number
    open: number
    high: number
    low: number
    close: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Forex_candlesAvgAggregateInputType = {
    open?: true
    high?: true
    low?: true
    close?: true
  }

  export type Forex_candlesSumAggregateInputType = {
    open?: true
    high?: true
    low?: true
    close?: true
  }

  export type Forex_candlesMinAggregateInputType = {
    id?: true
    symbol?: true
    interval?: true
    time?: true
    open?: true
    high?: true
    low?: true
    close?: true
    created_at?: true
    updated_at?: true
  }

  export type Forex_candlesMaxAggregateInputType = {
    id?: true
    symbol?: true
    interval?: true
    time?: true
    open?: true
    high?: true
    low?: true
    close?: true
    created_at?: true
    updated_at?: true
  }

  export type Forex_candlesCountAggregateInputType = {
    id?: true
    symbol?: true
    interval?: true
    time?: true
    open?: true
    high?: true
    low?: true
    close?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Forex_candlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forex_candles to aggregate.
     */
    where?: forex_candlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forex_candles to fetch.
     */
    orderBy?: forex_candlesOrderByWithRelationInput | forex_candlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: forex_candlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forex_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forex_candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forex_candles
    **/
    _count?: true | Forex_candlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Forex_candlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Forex_candlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Forex_candlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Forex_candlesMaxAggregateInputType
  }

  export type GetForex_candlesAggregateType<T extends Forex_candlesAggregateArgs> = {
        [P in keyof T & keyof AggregateForex_candles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForex_candles[P]>
      : GetScalarType<T[P], AggregateForex_candles[P]>
  }




  export type forex_candlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forex_candlesWhereInput
    orderBy?: forex_candlesOrderByWithAggregationInput | forex_candlesOrderByWithAggregationInput[]
    by: Forex_candlesScalarFieldEnum[] | Forex_candlesScalarFieldEnum
    having?: forex_candlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Forex_candlesCountAggregateInputType | true
    _avg?: Forex_candlesAvgAggregateInputType
    _sum?: Forex_candlesSumAggregateInputType
    _min?: Forex_candlesMinAggregateInputType
    _max?: Forex_candlesMaxAggregateInputType
  }

  export type Forex_candlesGroupByOutputType = {
    id: string
    symbol: string
    interval: string
    time: Date
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    created_at: Date
    updated_at: Date
    _count: Forex_candlesCountAggregateOutputType | null
    _avg: Forex_candlesAvgAggregateOutputType | null
    _sum: Forex_candlesSumAggregateOutputType | null
    _min: Forex_candlesMinAggregateOutputType | null
    _max: Forex_candlesMaxAggregateOutputType | null
  }

  type GetForex_candlesGroupByPayload<T extends forex_candlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Forex_candlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Forex_candlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Forex_candlesGroupByOutputType[P]>
            : GetScalarType<T[P], Forex_candlesGroupByOutputType[P]>
        }
      >
    >


  export type forex_candlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    interval?: boolean
    time?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["forex_candles"]>

  export type forex_candlesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    interval?: boolean
    time?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["forex_candles"]>

  export type forex_candlesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    interval?: boolean
    time?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["forex_candles"]>

  export type forex_candlesSelectScalar = {
    id?: boolean
    symbol?: boolean
    interval?: boolean
    time?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type forex_candlesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "interval" | "time" | "open" | "high" | "low" | "close" | "created_at" | "updated_at", ExtArgs["result"]["forex_candles"]>

  export type $forex_candlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "forex_candles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      interval: string
      time: Date
      open: Prisma.Decimal
      high: Prisma.Decimal
      low: Prisma.Decimal
      close: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["forex_candles"]>
    composites: {}
  }

  type forex_candlesGetPayload<S extends boolean | null | undefined | forex_candlesDefaultArgs> = $Result.GetResult<Prisma.$forex_candlesPayload, S>

  type forex_candlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<forex_candlesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Forex_candlesCountAggregateInputType | true
    }

  export interface forex_candlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['forex_candles'], meta: { name: 'forex_candles' } }
    /**
     * Find zero or one Forex_candles that matches the filter.
     * @param {forex_candlesFindUniqueArgs} args - Arguments to find a Forex_candles
     * @example
     * // Get one Forex_candles
     * const forex_candles = await prisma.forex_candles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends forex_candlesFindUniqueArgs>(args: SelectSubset<T, forex_candlesFindUniqueArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Forex_candles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {forex_candlesFindUniqueOrThrowArgs} args - Arguments to find a Forex_candles
     * @example
     * // Get one Forex_candles
     * const forex_candles = await prisma.forex_candles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends forex_candlesFindUniqueOrThrowArgs>(args: SelectSubset<T, forex_candlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Forex_candles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forex_candlesFindFirstArgs} args - Arguments to find a Forex_candles
     * @example
     * // Get one Forex_candles
     * const forex_candles = await prisma.forex_candles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends forex_candlesFindFirstArgs>(args?: SelectSubset<T, forex_candlesFindFirstArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Forex_candles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forex_candlesFindFirstOrThrowArgs} args - Arguments to find a Forex_candles
     * @example
     * // Get one Forex_candles
     * const forex_candles = await prisma.forex_candles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends forex_candlesFindFirstOrThrowArgs>(args?: SelectSubset<T, forex_candlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Forex_candles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forex_candlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forex_candles
     * const forex_candles = await prisma.forex_candles.findMany()
     * 
     * // Get first 10 Forex_candles
     * const forex_candles = await prisma.forex_candles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forex_candlesWithIdOnly = await prisma.forex_candles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends forex_candlesFindManyArgs>(args?: SelectSubset<T, forex_candlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Forex_candles.
     * @param {forex_candlesCreateArgs} args - Arguments to create a Forex_candles.
     * @example
     * // Create one Forex_candles
     * const Forex_candles = await prisma.forex_candles.create({
     *   data: {
     *     // ... data to create a Forex_candles
     *   }
     * })
     * 
     */
    create<T extends forex_candlesCreateArgs>(args: SelectSubset<T, forex_candlesCreateArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Forex_candles.
     * @param {forex_candlesCreateManyArgs} args - Arguments to create many Forex_candles.
     * @example
     * // Create many Forex_candles
     * const forex_candles = await prisma.forex_candles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends forex_candlesCreateManyArgs>(args?: SelectSubset<T, forex_candlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forex_candles and returns the data saved in the database.
     * @param {forex_candlesCreateManyAndReturnArgs} args - Arguments to create many Forex_candles.
     * @example
     * // Create many Forex_candles
     * const forex_candles = await prisma.forex_candles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forex_candles and only return the `id`
     * const forex_candlesWithIdOnly = await prisma.forex_candles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends forex_candlesCreateManyAndReturnArgs>(args?: SelectSubset<T, forex_candlesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Forex_candles.
     * @param {forex_candlesDeleteArgs} args - Arguments to delete one Forex_candles.
     * @example
     * // Delete one Forex_candles
     * const Forex_candles = await prisma.forex_candles.delete({
     *   where: {
     *     // ... filter to delete one Forex_candles
     *   }
     * })
     * 
     */
    delete<T extends forex_candlesDeleteArgs>(args: SelectSubset<T, forex_candlesDeleteArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Forex_candles.
     * @param {forex_candlesUpdateArgs} args - Arguments to update one Forex_candles.
     * @example
     * // Update one Forex_candles
     * const forex_candles = await prisma.forex_candles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends forex_candlesUpdateArgs>(args: SelectSubset<T, forex_candlesUpdateArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Forex_candles.
     * @param {forex_candlesDeleteManyArgs} args - Arguments to filter Forex_candles to delete.
     * @example
     * // Delete a few Forex_candles
     * const { count } = await prisma.forex_candles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends forex_candlesDeleteManyArgs>(args?: SelectSubset<T, forex_candlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forex_candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forex_candlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forex_candles
     * const forex_candles = await prisma.forex_candles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends forex_candlesUpdateManyArgs>(args: SelectSubset<T, forex_candlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forex_candles and returns the data updated in the database.
     * @param {forex_candlesUpdateManyAndReturnArgs} args - Arguments to update many Forex_candles.
     * @example
     * // Update many Forex_candles
     * const forex_candles = await prisma.forex_candles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Forex_candles and only return the `id`
     * const forex_candlesWithIdOnly = await prisma.forex_candles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends forex_candlesUpdateManyAndReturnArgs>(args: SelectSubset<T, forex_candlesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Forex_candles.
     * @param {forex_candlesUpsertArgs} args - Arguments to update or create a Forex_candles.
     * @example
     * // Update or create a Forex_candles
     * const forex_candles = await prisma.forex_candles.upsert({
     *   create: {
     *     // ... data to create a Forex_candles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Forex_candles we want to update
     *   }
     * })
     */
    upsert<T extends forex_candlesUpsertArgs>(args: SelectSubset<T, forex_candlesUpsertArgs<ExtArgs>>): Prisma__forex_candlesClient<$Result.GetResult<Prisma.$forex_candlesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Forex_candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forex_candlesCountArgs} args - Arguments to filter Forex_candles to count.
     * @example
     * // Count the number of Forex_candles
     * const count = await prisma.forex_candles.count({
     *   where: {
     *     // ... the filter for the Forex_candles we want to count
     *   }
     * })
    **/
    count<T extends forex_candlesCountArgs>(
      args?: Subset<T, forex_candlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Forex_candlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Forex_candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Forex_candlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Forex_candlesAggregateArgs>(args: Subset<T, Forex_candlesAggregateArgs>): Prisma.PrismaPromise<GetForex_candlesAggregateType<T>>

    /**
     * Group by Forex_candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forex_candlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends forex_candlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: forex_candlesGroupByArgs['orderBy'] }
        : { orderBy?: forex_candlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, forex_candlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForex_candlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the forex_candles model
   */
  readonly fields: forex_candlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for forex_candles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__forex_candlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the forex_candles model
   */
  interface forex_candlesFieldRefs {
    readonly id: FieldRef<"forex_candles", 'String'>
    readonly symbol: FieldRef<"forex_candles", 'String'>
    readonly interval: FieldRef<"forex_candles", 'String'>
    readonly time: FieldRef<"forex_candles", 'DateTime'>
    readonly open: FieldRef<"forex_candles", 'Decimal'>
    readonly high: FieldRef<"forex_candles", 'Decimal'>
    readonly low: FieldRef<"forex_candles", 'Decimal'>
    readonly close: FieldRef<"forex_candles", 'Decimal'>
    readonly created_at: FieldRef<"forex_candles", 'DateTime'>
    readonly updated_at: FieldRef<"forex_candles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * forex_candles findUnique
   */
  export type forex_candlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * Filter, which forex_candles to fetch.
     */
    where: forex_candlesWhereUniqueInput
  }

  /**
   * forex_candles findUniqueOrThrow
   */
  export type forex_candlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * Filter, which forex_candles to fetch.
     */
    where: forex_candlesWhereUniqueInput
  }

  /**
   * forex_candles findFirst
   */
  export type forex_candlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * Filter, which forex_candles to fetch.
     */
    where?: forex_candlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forex_candles to fetch.
     */
    orderBy?: forex_candlesOrderByWithRelationInput | forex_candlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forex_candles.
     */
    cursor?: forex_candlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forex_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forex_candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forex_candles.
     */
    distinct?: Forex_candlesScalarFieldEnum | Forex_candlesScalarFieldEnum[]
  }

  /**
   * forex_candles findFirstOrThrow
   */
  export type forex_candlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * Filter, which forex_candles to fetch.
     */
    where?: forex_candlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forex_candles to fetch.
     */
    orderBy?: forex_candlesOrderByWithRelationInput | forex_candlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forex_candles.
     */
    cursor?: forex_candlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forex_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forex_candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forex_candles.
     */
    distinct?: Forex_candlesScalarFieldEnum | Forex_candlesScalarFieldEnum[]
  }

  /**
   * forex_candles findMany
   */
  export type forex_candlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * Filter, which forex_candles to fetch.
     */
    where?: forex_candlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forex_candles to fetch.
     */
    orderBy?: forex_candlesOrderByWithRelationInput | forex_candlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forex_candles.
     */
    cursor?: forex_candlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forex_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forex_candles.
     */
    skip?: number
    distinct?: Forex_candlesScalarFieldEnum | Forex_candlesScalarFieldEnum[]
  }

  /**
   * forex_candles create
   */
  export type forex_candlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * The data needed to create a forex_candles.
     */
    data: XOR<forex_candlesCreateInput, forex_candlesUncheckedCreateInput>
  }

  /**
   * forex_candles createMany
   */
  export type forex_candlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many forex_candles.
     */
    data: forex_candlesCreateManyInput | forex_candlesCreateManyInput[]
  }

  /**
   * forex_candles createManyAndReturn
   */
  export type forex_candlesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * The data used to create many forex_candles.
     */
    data: forex_candlesCreateManyInput | forex_candlesCreateManyInput[]
  }

  /**
   * forex_candles update
   */
  export type forex_candlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * The data needed to update a forex_candles.
     */
    data: XOR<forex_candlesUpdateInput, forex_candlesUncheckedUpdateInput>
    /**
     * Choose, which forex_candles to update.
     */
    where: forex_candlesWhereUniqueInput
  }

  /**
   * forex_candles updateMany
   */
  export type forex_candlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update forex_candles.
     */
    data: XOR<forex_candlesUpdateManyMutationInput, forex_candlesUncheckedUpdateManyInput>
    /**
     * Filter which forex_candles to update
     */
    where?: forex_candlesWhereInput
    /**
     * Limit how many forex_candles to update.
     */
    limit?: number
  }

  /**
   * forex_candles updateManyAndReturn
   */
  export type forex_candlesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * The data used to update forex_candles.
     */
    data: XOR<forex_candlesUpdateManyMutationInput, forex_candlesUncheckedUpdateManyInput>
    /**
     * Filter which forex_candles to update
     */
    where?: forex_candlesWhereInput
    /**
     * Limit how many forex_candles to update.
     */
    limit?: number
  }

  /**
   * forex_candles upsert
   */
  export type forex_candlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * The filter to search for the forex_candles to update in case it exists.
     */
    where: forex_candlesWhereUniqueInput
    /**
     * In case the forex_candles found by the `where` argument doesn't exist, create a new forex_candles with this data.
     */
    create: XOR<forex_candlesCreateInput, forex_candlesUncheckedCreateInput>
    /**
     * In case the forex_candles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<forex_candlesUpdateInput, forex_candlesUncheckedUpdateInput>
  }

  /**
   * forex_candles delete
   */
  export type forex_candlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
    /**
     * Filter which forex_candles to delete.
     */
    where: forex_candlesWhereUniqueInput
  }

  /**
   * forex_candles deleteMany
   */
  export type forex_candlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forex_candles to delete
     */
    where?: forex_candlesWhereInput
    /**
     * Limit how many forex_candles to delete.
     */
    limit?: number
  }

  /**
   * forex_candles without action
   */
  export type forex_candlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forex_candles
     */
    select?: forex_candlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forex_candles
     */
    omit?: forex_candlesOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    balance: Decimal | null
    demo_balance: Decimal | null
  }

  export type UsersSumAggregateOutputType = {
    balance: Decimal | null
    demo_balance: Decimal | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    country: string | null
    date_of_birth: string | null
    address: string | null
    city: string | null
    postal_code: string | null
    balance: Decimal | null
    is_verified: boolean | null
    is_admin: boolean | null
    is_suspended: boolean | null
    avatar_url: string | null
    created_at: Date | null
    updated_at: Date | null
    demo_balance: Decimal | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    country: string | null
    date_of_birth: string | null
    address: string | null
    city: string | null
    postal_code: string | null
    balance: Decimal | null
    is_verified: boolean | null
    is_admin: boolean | null
    is_suspended: boolean | null
    avatar_url: string | null
    created_at: Date | null
    updated_at: Date | null
    demo_balance: Decimal | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    last_name: number
    email: number
    password_hash: number
    phone: number
    country: number
    date_of_birth: number
    address: number
    city: number
    postal_code: number
    balance: number
    is_verified: number
    is_admin: number
    is_suspended: number
    avatar_url: number
    created_at: number
    updated_at: number
    demo_balance: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    balance?: true
    demo_balance?: true
  }

  export type UsersSumAggregateInputType = {
    balance?: true
    demo_balance?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    phone?: true
    country?: true
    date_of_birth?: true
    address?: true
    city?: true
    postal_code?: true
    balance?: true
    is_verified?: true
    is_admin?: true
    is_suspended?: true
    avatar_url?: true
    created_at?: true
    updated_at?: true
    demo_balance?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    phone?: true
    country?: true
    date_of_birth?: true
    address?: true
    city?: true
    postal_code?: true
    balance?: true
    is_verified?: true
    is_admin?: true
    is_suspended?: true
    avatar_url?: true
    created_at?: true
    updated_at?: true
    demo_balance?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    phone?: true
    country?: true
    date_of_birth?: true
    address?: true
    city?: true
    postal_code?: true
    balance?: true
    is_verified?: true
    is_admin?: true
    is_suspended?: true
    avatar_url?: true
    created_at?: true
    updated_at?: true
    demo_balance?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string | null
    first_name: string | null
    last_name: string | null
    email: string
    password_hash: string | null
    phone: string | null
    country: string | null
    date_of_birth: string | null
    address: string | null
    city: string | null
    postal_code: string | null
    balance: Decimal | null
    is_verified: boolean
    is_admin: boolean
    is_suspended: boolean
    avatar_url: string | null
    created_at: Date
    updated_at: Date
    demo_balance: Decimal | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    country?: boolean
    date_of_birth?: boolean
    address?: boolean
    city?: boolean
    postal_code?: boolean
    balance?: boolean
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    demo_balance?: boolean
    chat_messages?: boolean | users$chat_messagesArgs<ExtArgs>
    deposits?: boolean | users$depositsArgs<ExtArgs>
    leaderboard?: boolean | users$leaderboardArgs<ExtArgs>
    settings?: boolean | users$settingsArgs<ExtArgs>
    support_messages?: boolean | users$support_messagesArgs<ExtArgs>
    trades?: boolean | users$tradesArgs<ExtArgs>
    withdrawals?: boolean | users$withdrawalsArgs<ExtArgs>
    deposit_sessions?: boolean | users$deposit_sessionsArgs<ExtArgs>
    wallet_ledger?: boolean | users$wallet_ledgerArgs<ExtArgs>
    p2p_offers?: boolean | users$p2p_offersArgs<ExtArgs>
    user_payment_methods?: boolean | users$user_payment_methodsArgs<ExtArgs>
    p2p_maker_orders?: boolean | users$p2p_maker_ordersArgs<ExtArgs>
    p2p_taker_orders?: boolean | users$p2p_taker_ordersArgs<ExtArgs>
    p2p_messages_sent?: boolean | users$p2p_messages_sentArgs<ExtArgs>
    p2p_disputes_raised?: boolean | users$p2p_disputes_raisedArgs<ExtArgs>
    p2p_ratings_from?: boolean | users$p2p_ratings_fromArgs<ExtArgs>
    p2p_ratings_to?: boolean | users$p2p_ratings_toArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    country?: boolean
    date_of_birth?: boolean
    address?: boolean
    city?: boolean
    postal_code?: boolean
    balance?: boolean
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    demo_balance?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    country?: boolean
    date_of_birth?: boolean
    address?: boolean
    city?: boolean
    postal_code?: boolean
    balance?: boolean
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    demo_balance?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    country?: boolean
    date_of_birth?: boolean
    address?: boolean
    city?: boolean
    postal_code?: boolean
    balance?: boolean
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    demo_balance?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "last_name" | "email" | "password_hash" | "phone" | "country" | "date_of_birth" | "address" | "city" | "postal_code" | "balance" | "is_verified" | "is_admin" | "is_suspended" | "avatar_url" | "created_at" | "updated_at" | "demo_balance", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | users$chat_messagesArgs<ExtArgs>
    deposits?: boolean | users$depositsArgs<ExtArgs>
    leaderboard?: boolean | users$leaderboardArgs<ExtArgs>
    settings?: boolean | users$settingsArgs<ExtArgs>
    support_messages?: boolean | users$support_messagesArgs<ExtArgs>
    trades?: boolean | users$tradesArgs<ExtArgs>
    withdrawals?: boolean | users$withdrawalsArgs<ExtArgs>
    deposit_sessions?: boolean | users$deposit_sessionsArgs<ExtArgs>
    wallet_ledger?: boolean | users$wallet_ledgerArgs<ExtArgs>
    p2p_offers?: boolean | users$p2p_offersArgs<ExtArgs>
    user_payment_methods?: boolean | users$user_payment_methodsArgs<ExtArgs>
    p2p_maker_orders?: boolean | users$p2p_maker_ordersArgs<ExtArgs>
    p2p_taker_orders?: boolean | users$p2p_taker_ordersArgs<ExtArgs>
    p2p_messages_sent?: boolean | users$p2p_messages_sentArgs<ExtArgs>
    p2p_disputes_raised?: boolean | users$p2p_disputes_raisedArgs<ExtArgs>
    p2p_ratings_from?: boolean | users$p2p_ratings_fromArgs<ExtArgs>
    p2p_ratings_to?: boolean | users$p2p_ratings_toArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      chat_messages: Prisma.$chat_messagesPayload<ExtArgs>[]
      deposits: Prisma.$depositsPayload<ExtArgs>[]
      leaderboard: Prisma.$leaderboardPayload<ExtArgs>[]
      settings: Prisma.$settingsPayload<ExtArgs>[]
      support_messages: Prisma.$support_messagesPayload<ExtArgs>[]
      trades: Prisma.$tradesPayload<ExtArgs>[]
      withdrawals: Prisma.$withdrawalsPayload<ExtArgs>[]
      deposit_sessions: Prisma.$deposit_sessionsPayload<ExtArgs>[]
      wallet_ledger: Prisma.$wallet_ledgerPayload<ExtArgs>[]
      p2p_offers: Prisma.$p2p_offersPayload<ExtArgs>[]
      user_payment_methods: Prisma.$user_payment_methodsPayload<ExtArgs>[]
      p2p_maker_orders: Prisma.$p2p_ordersPayload<ExtArgs>[]
      p2p_taker_orders: Prisma.$p2p_ordersPayload<ExtArgs>[]
      p2p_messages_sent: Prisma.$p2p_messagesPayload<ExtArgs>[]
      p2p_disputes_raised: Prisma.$p2p_disputesPayload<ExtArgs>[]
      p2p_ratings_from: Prisma.$p2p_ratingsPayload<ExtArgs>[]
      p2p_ratings_to: Prisma.$p2p_ratingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      first_name: string | null
      last_name: string | null
      email: string
      password_hash: string | null
      phone: string | null
      country: string | null
      date_of_birth: string | null
      address: string | null
      city: string | null
      postal_code: string | null
      balance: Prisma.Decimal | null
      is_verified: boolean
      is_admin: boolean
      is_suspended: boolean
      avatar_url: string | null
      created_at: Date
      updated_at: Date
      demo_balance: Prisma.Decimal | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_messages<T extends users$chat_messagesArgs<ExtArgs> = {}>(args?: Subset<T, users$chat_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deposits<T extends users$depositsArgs<ExtArgs> = {}>(args?: Subset<T, users$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboard<T extends users$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, users$leaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends users$settingsArgs<ExtArgs> = {}>(args?: Subset<T, users$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    support_messages<T extends users$support_messagesArgs<ExtArgs> = {}>(args?: Subset<T, users$support_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trades<T extends users$tradesArgs<ExtArgs> = {}>(args?: Subset<T, users$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    withdrawals<T extends users$withdrawalsArgs<ExtArgs> = {}>(args?: Subset<T, users$withdrawalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deposit_sessions<T extends users$deposit_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$deposit_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet_ledger<T extends users$wallet_ledgerArgs<ExtArgs> = {}>(args?: Subset<T, users$wallet_ledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_offers<T extends users$p2p_offersArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_payment_methods<T extends users$user_payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_payment_methodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_maker_orders<T extends users$p2p_maker_ordersArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_maker_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_taker_orders<T extends users$p2p_taker_ordersArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_taker_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_messages_sent<T extends users$p2p_messages_sentArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_messages_sentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_disputes_raised<T extends users$p2p_disputes_raisedArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_disputes_raisedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_ratings_from<T extends users$p2p_ratings_fromArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_ratings_fromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    p2p_ratings_to<T extends users$p2p_ratings_toArgs<ExtArgs> = {}>(args?: Subset<T, users$p2p_ratings_toArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly country: FieldRef<"users", 'String'>
    readonly date_of_birth: FieldRef<"users", 'String'>
    readonly address: FieldRef<"users", 'String'>
    readonly city: FieldRef<"users", 'String'>
    readonly postal_code: FieldRef<"users", 'String'>
    readonly balance: FieldRef<"users", 'Decimal'>
    readonly is_verified: FieldRef<"users", 'Boolean'>
    readonly is_admin: FieldRef<"users", 'Boolean'>
    readonly is_suspended: FieldRef<"users", 'Boolean'>
    readonly avatar_url: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly demo_balance: FieldRef<"users", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.chat_messages
   */
  export type users$chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * users.deposits
   */
  export type users$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    where?: depositsWhereInput
    orderBy?: depositsOrderByWithRelationInput | depositsOrderByWithRelationInput[]
    cursor?: depositsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * users.leaderboard
   */
  export type users$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    where?: leaderboardWhereInput
    orderBy?: leaderboardOrderByWithRelationInput | leaderboardOrderByWithRelationInput[]
    cursor?: leaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * users.settings
   */
  export type users$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    cursor?: settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * users.support_messages
   */
  export type users$support_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    where?: support_messagesWhereInput
    orderBy?: support_messagesOrderByWithRelationInput | support_messagesOrderByWithRelationInput[]
    cursor?: support_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Support_messagesScalarFieldEnum | Support_messagesScalarFieldEnum[]
  }

  /**
   * users.trades
   */
  export type users$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    where?: tradesWhereInput
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    cursor?: tradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * users.withdrawals
   */
  export type users$withdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    where?: withdrawalsWhereInput
    orderBy?: withdrawalsOrderByWithRelationInput | withdrawalsOrderByWithRelationInput[]
    cursor?: withdrawalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * users.deposit_sessions
   */
  export type users$deposit_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    where?: deposit_sessionsWhereInput
    orderBy?: deposit_sessionsOrderByWithRelationInput | deposit_sessionsOrderByWithRelationInput[]
    cursor?: deposit_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Deposit_sessionsScalarFieldEnum | Deposit_sessionsScalarFieldEnum[]
  }

  /**
   * users.wallet_ledger
   */
  export type users$wallet_ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    where?: wallet_ledgerWhereInput
    orderBy?: wallet_ledgerOrderByWithRelationInput | wallet_ledgerOrderByWithRelationInput[]
    cursor?: wallet_ledgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Wallet_ledgerScalarFieldEnum | Wallet_ledgerScalarFieldEnum[]
  }

  /**
   * users.p2p_offers
   */
  export type users$p2p_offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    where?: p2p_offersWhereInput
    orderBy?: p2p_offersOrderByWithRelationInput | p2p_offersOrderByWithRelationInput[]
    cursor?: p2p_offersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_offersScalarFieldEnum | P2p_offersScalarFieldEnum[]
  }

  /**
   * users.user_payment_methods
   */
  export type users$user_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    where?: user_payment_methodsWhereInput
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    cursor?: user_payment_methodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * users.p2p_maker_orders
   */
  export type users$p2p_maker_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    where?: p2p_ordersWhereInput
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    cursor?: p2p_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_ordersScalarFieldEnum | P2p_ordersScalarFieldEnum[]
  }

  /**
   * users.p2p_taker_orders
   */
  export type users$p2p_taker_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    where?: p2p_ordersWhereInput
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    cursor?: p2p_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_ordersScalarFieldEnum | P2p_ordersScalarFieldEnum[]
  }

  /**
   * users.p2p_messages_sent
   */
  export type users$p2p_messages_sentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    where?: p2p_messagesWhereInput
    orderBy?: p2p_messagesOrderByWithRelationInput | p2p_messagesOrderByWithRelationInput[]
    cursor?: p2p_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_messagesScalarFieldEnum | P2p_messagesScalarFieldEnum[]
  }

  /**
   * users.p2p_disputes_raised
   */
  export type users$p2p_disputes_raisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    where?: p2p_disputesWhereInput
    orderBy?: p2p_disputesOrderByWithRelationInput | p2p_disputesOrderByWithRelationInput[]
    cursor?: p2p_disputesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_disputesScalarFieldEnum | P2p_disputesScalarFieldEnum[]
  }

  /**
   * users.p2p_ratings_from
   */
  export type users$p2p_ratings_fromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    where?: p2p_ratingsWhereInput
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    cursor?: p2p_ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_ratingsScalarFieldEnum | P2p_ratingsScalarFieldEnum[]
  }

  /**
   * users.p2p_ratings_to
   */
  export type users$p2p_ratings_toArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    where?: p2p_ratingsWhereInput
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    cursor?: p2p_ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_ratingsScalarFieldEnum | P2p_ratingsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model deposits
   */

  export type AggregateDeposits = {
    _count: DepositsCountAggregateOutputType | null
    _avg: DepositsAvgAggregateOutputType | null
    _sum: DepositsSumAggregateOutputType | null
    _min: DepositsMinAggregateOutputType | null
    _max: DepositsMaxAggregateOutputType | null
  }

  export type DepositsAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type DepositsSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type DepositsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    created_at: Date | null
  }

  export type DepositsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    created_at: Date | null
  }

  export type DepositsCountAggregateOutputType = {
    id: number
    user_id: number
    amount: number
    method: number
    status: number
    created_at: number
    _all: number
  }


  export type DepositsAvgAggregateInputType = {
    amount?: true
  }

  export type DepositsSumAggregateInputType = {
    amount?: true
  }

  export type DepositsMinAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    method?: true
    status?: true
    created_at?: true
  }

  export type DepositsMaxAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    method?: true
    status?: true
    created_at?: true
  }

  export type DepositsCountAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    method?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type DepositsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deposits to aggregate.
     */
    where?: depositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposits to fetch.
     */
    orderBy?: depositsOrderByWithRelationInput | depositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: depositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deposits
    **/
    _count?: true | DepositsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositsMaxAggregateInputType
  }

  export type GetDepositsAggregateType<T extends DepositsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposits[P]>
      : GetScalarType<T[P], AggregateDeposits[P]>
  }




  export type depositsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: depositsWhereInput
    orderBy?: depositsOrderByWithAggregationInput | depositsOrderByWithAggregationInput[]
    by: DepositsScalarFieldEnum[] | DepositsScalarFieldEnum
    having?: depositsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositsCountAggregateInputType | true
    _avg?: DepositsAvgAggregateInputType
    _sum?: DepositsSumAggregateInputType
    _min?: DepositsMinAggregateInputType
    _max?: DepositsMaxAggregateInputType
  }

  export type DepositsGroupByOutputType = {
    id: string
    user_id: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    created_at: Date
    _count: DepositsCountAggregateOutputType | null
    _avg: DepositsAvgAggregateOutputType | null
    _sum: DepositsSumAggregateOutputType | null
    _min: DepositsMinAggregateOutputType | null
    _max: DepositsMaxAggregateOutputType | null
  }

  type GetDepositsGroupByPayload<T extends depositsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositsGroupByOutputType[P]>
            : GetScalarType<T[P], DepositsGroupByOutputType[P]>
        }
      >
    >


  export type depositsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    created_at?: boolean
    users?: boolean | deposits$usersArgs<ExtArgs>
  }, ExtArgs["result"]["deposits"]>

  export type depositsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    created_at?: boolean
    users?: boolean | deposits$usersArgs<ExtArgs>
  }, ExtArgs["result"]["deposits"]>

  export type depositsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    created_at?: boolean
    users?: boolean | deposits$usersArgs<ExtArgs>
  }, ExtArgs["result"]["deposits"]>

  export type depositsSelectScalar = {
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type depositsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "amount" | "method" | "status" | "created_at", ExtArgs["result"]["deposits"]>
  export type depositsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | deposits$usersArgs<ExtArgs>
  }
  export type depositsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | deposits$usersArgs<ExtArgs>
  }
  export type depositsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | deposits$usersArgs<ExtArgs>
  }

  export type $depositsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deposits"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      amount: Prisma.Decimal | null
      method: string | null
      status: string | null
      created_at: Date
    }, ExtArgs["result"]["deposits"]>
    composites: {}
  }

  type depositsGetPayload<S extends boolean | null | undefined | depositsDefaultArgs> = $Result.GetResult<Prisma.$depositsPayload, S>

  type depositsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<depositsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositsCountAggregateInputType | true
    }

  export interface depositsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deposits'], meta: { name: 'deposits' } }
    /**
     * Find zero or one Deposits that matches the filter.
     * @param {depositsFindUniqueArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends depositsFindUniqueArgs>(args: SelectSubset<T, depositsFindUniqueArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposits that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {depositsFindUniqueOrThrowArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends depositsFindUniqueOrThrowArgs>(args: SelectSubset<T, depositsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositsFindFirstArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends depositsFindFirstArgs>(args?: SelectSubset<T, depositsFindFirstArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositsFindFirstOrThrowArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends depositsFindFirstOrThrowArgs>(args?: SelectSubset<T, depositsFindFirstOrThrowArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposits
     * const deposits = await prisma.deposits.findMany()
     * 
     * // Get first 10 Deposits
     * const deposits = await prisma.deposits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositsWithIdOnly = await prisma.deposits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends depositsFindManyArgs>(args?: SelectSubset<T, depositsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposits.
     * @param {depositsCreateArgs} args - Arguments to create a Deposits.
     * @example
     * // Create one Deposits
     * const Deposits = await prisma.deposits.create({
     *   data: {
     *     // ... data to create a Deposits
     *   }
     * })
     * 
     */
    create<T extends depositsCreateArgs>(args: SelectSubset<T, depositsCreateArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deposits.
     * @param {depositsCreateManyArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposits = await prisma.deposits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends depositsCreateManyArgs>(args?: SelectSubset<T, depositsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposits and returns the data saved in the database.
     * @param {depositsCreateManyAndReturnArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposits = await prisma.deposits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposits and only return the `id`
     * const depositsWithIdOnly = await prisma.deposits.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends depositsCreateManyAndReturnArgs>(args?: SelectSubset<T, depositsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deposits.
     * @param {depositsDeleteArgs} args - Arguments to delete one Deposits.
     * @example
     * // Delete one Deposits
     * const Deposits = await prisma.deposits.delete({
     *   where: {
     *     // ... filter to delete one Deposits
     *   }
     * })
     * 
     */
    delete<T extends depositsDeleteArgs>(args: SelectSubset<T, depositsDeleteArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposits.
     * @param {depositsUpdateArgs} args - Arguments to update one Deposits.
     * @example
     * // Update one Deposits
     * const deposits = await prisma.deposits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends depositsUpdateArgs>(args: SelectSubset<T, depositsUpdateArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deposits.
     * @param {depositsDeleteManyArgs} args - Arguments to filter Deposits to delete.
     * @example
     * // Delete a few Deposits
     * const { count } = await prisma.deposits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends depositsDeleteManyArgs>(args?: SelectSubset<T, depositsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposits
     * const deposits = await prisma.deposits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends depositsUpdateManyArgs>(args: SelectSubset<T, depositsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits and returns the data updated in the database.
     * @param {depositsUpdateManyAndReturnArgs} args - Arguments to update many Deposits.
     * @example
     * // Update many Deposits
     * const deposits = await prisma.deposits.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deposits and only return the `id`
     * const depositsWithIdOnly = await prisma.deposits.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends depositsUpdateManyAndReturnArgs>(args: SelectSubset<T, depositsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deposits.
     * @param {depositsUpsertArgs} args - Arguments to update or create a Deposits.
     * @example
     * // Update or create a Deposits
     * const deposits = await prisma.deposits.upsert({
     *   create: {
     *     // ... data to create a Deposits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposits we want to update
     *   }
     * })
     */
    upsert<T extends depositsUpsertArgs>(args: SelectSubset<T, depositsUpsertArgs<ExtArgs>>): Prisma__depositsClient<$Result.GetResult<Prisma.$depositsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositsCountArgs} args - Arguments to filter Deposits to count.
     * @example
     * // Count the number of Deposits
     * const count = await prisma.deposits.count({
     *   where: {
     *     // ... the filter for the Deposits we want to count
     *   }
     * })
    **/
    count<T extends depositsCountArgs>(
      args?: Subset<T, depositsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositsAggregateArgs>(args: Subset<T, DepositsAggregateArgs>): Prisma.PrismaPromise<GetDepositsAggregateType<T>>

    /**
     * Group by Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends depositsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: depositsGroupByArgs['orderBy'] }
        : { orderBy?: depositsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, depositsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deposits model
   */
  readonly fields: depositsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deposits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__depositsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends deposits$usersArgs<ExtArgs> = {}>(args?: Subset<T, deposits$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deposits model
   */
  interface depositsFieldRefs {
    readonly id: FieldRef<"deposits", 'String'>
    readonly user_id: FieldRef<"deposits", 'String'>
    readonly amount: FieldRef<"deposits", 'Decimal'>
    readonly method: FieldRef<"deposits", 'String'>
    readonly status: FieldRef<"deposits", 'String'>
    readonly created_at: FieldRef<"deposits", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * deposits findUnique
   */
  export type depositsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * Filter, which deposits to fetch.
     */
    where: depositsWhereUniqueInput
  }

  /**
   * deposits findUniqueOrThrow
   */
  export type depositsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * Filter, which deposits to fetch.
     */
    where: depositsWhereUniqueInput
  }

  /**
   * deposits findFirst
   */
  export type depositsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * Filter, which deposits to fetch.
     */
    where?: depositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposits to fetch.
     */
    orderBy?: depositsOrderByWithRelationInput | depositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deposits.
     */
    cursor?: depositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deposits.
     */
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * deposits findFirstOrThrow
   */
  export type depositsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * Filter, which deposits to fetch.
     */
    where?: depositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposits to fetch.
     */
    orderBy?: depositsOrderByWithRelationInput | depositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deposits.
     */
    cursor?: depositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deposits.
     */
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * deposits findMany
   */
  export type depositsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * Filter, which deposits to fetch.
     */
    where?: depositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposits to fetch.
     */
    orderBy?: depositsOrderByWithRelationInput | depositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deposits.
     */
    cursor?: depositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposits.
     */
    skip?: number
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * deposits create
   */
  export type depositsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * The data needed to create a deposits.
     */
    data?: XOR<depositsCreateInput, depositsUncheckedCreateInput>
  }

  /**
   * deposits createMany
   */
  export type depositsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deposits.
     */
    data: depositsCreateManyInput | depositsCreateManyInput[]
  }

  /**
   * deposits createManyAndReturn
   */
  export type depositsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * The data used to create many deposits.
     */
    data: depositsCreateManyInput | depositsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * deposits update
   */
  export type depositsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * The data needed to update a deposits.
     */
    data: XOR<depositsUpdateInput, depositsUncheckedUpdateInput>
    /**
     * Choose, which deposits to update.
     */
    where: depositsWhereUniqueInput
  }

  /**
   * deposits updateMany
   */
  export type depositsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deposits.
     */
    data: XOR<depositsUpdateManyMutationInput, depositsUncheckedUpdateManyInput>
    /**
     * Filter which deposits to update
     */
    where?: depositsWhereInput
    /**
     * Limit how many deposits to update.
     */
    limit?: number
  }

  /**
   * deposits updateManyAndReturn
   */
  export type depositsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * The data used to update deposits.
     */
    data: XOR<depositsUpdateManyMutationInput, depositsUncheckedUpdateManyInput>
    /**
     * Filter which deposits to update
     */
    where?: depositsWhereInput
    /**
     * Limit how many deposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * deposits upsert
   */
  export type depositsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * The filter to search for the deposits to update in case it exists.
     */
    where: depositsWhereUniqueInput
    /**
     * In case the deposits found by the `where` argument doesn't exist, create a new deposits with this data.
     */
    create: XOR<depositsCreateInput, depositsUncheckedCreateInput>
    /**
     * In case the deposits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<depositsUpdateInput, depositsUncheckedUpdateInput>
  }

  /**
   * deposits delete
   */
  export type depositsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
    /**
     * Filter which deposits to delete.
     */
    where: depositsWhereUniqueInput
  }

  /**
   * deposits deleteMany
   */
  export type depositsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deposits to delete
     */
    where?: depositsWhereInput
    /**
     * Limit how many deposits to delete.
     */
    limit?: number
  }

  /**
   * deposits.users
   */
  export type deposits$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * deposits without action
   */
  export type depositsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposits
     */
    select?: depositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposits
     */
    omit?: depositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: depositsInclude<ExtArgs> | null
  }


  /**
   * Model withdrawals
   */

  export type AggregateWithdrawals = {
    _count: WithdrawalsCountAggregateOutputType | null
    _avg: WithdrawalsAvgAggregateOutputType | null
    _sum: WithdrawalsSumAggregateOutputType | null
    _min: WithdrawalsMinAggregateOutputType | null
    _max: WithdrawalsMaxAggregateOutputType | null
  }

  export type WithdrawalsAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type WithdrawalsSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type WithdrawalsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    created_at: Date | null
  }

  export type WithdrawalsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    created_at: Date | null
  }

  export type WithdrawalsCountAggregateOutputType = {
    id: number
    user_id: number
    amount: number
    method: number
    account_info: number
    status: number
    created_at: number
    _all: number
  }


  export type WithdrawalsAvgAggregateInputType = {
    amount?: true
  }

  export type WithdrawalsSumAggregateInputType = {
    amount?: true
  }

  export type WithdrawalsMinAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    method?: true
    status?: true
    created_at?: true
  }

  export type WithdrawalsMaxAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    method?: true
    status?: true
    created_at?: true
  }

  export type WithdrawalsCountAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    method?: true
    account_info?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type WithdrawalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which withdrawals to aggregate.
     */
    where?: withdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalsOrderByWithRelationInput | withdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: withdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned withdrawals
    **/
    _count?: true | WithdrawalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalsMaxAggregateInputType
  }

  export type GetWithdrawalsAggregateType<T extends WithdrawalsAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawals[P]>
      : GetScalarType<T[P], AggregateWithdrawals[P]>
  }




  export type withdrawalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: withdrawalsWhereInput
    orderBy?: withdrawalsOrderByWithAggregationInput | withdrawalsOrderByWithAggregationInput[]
    by: WithdrawalsScalarFieldEnum[] | WithdrawalsScalarFieldEnum
    having?: withdrawalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalsCountAggregateInputType | true
    _avg?: WithdrawalsAvgAggregateInputType
    _sum?: WithdrawalsSumAggregateInputType
    _min?: WithdrawalsMinAggregateInputType
    _max?: WithdrawalsMaxAggregateInputType
  }

  export type WithdrawalsGroupByOutputType = {
    id: string
    user_id: string | null
    amount: Decimal | null
    method: string | null
    account_info: JsonValue | null
    status: string | null
    created_at: Date
    _count: WithdrawalsCountAggregateOutputType | null
    _avg: WithdrawalsAvgAggregateOutputType | null
    _sum: WithdrawalsSumAggregateOutputType | null
    _min: WithdrawalsMinAggregateOutputType | null
    _max: WithdrawalsMaxAggregateOutputType | null
  }

  type GetWithdrawalsGroupByPayload<T extends withdrawalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalsGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalsGroupByOutputType[P]>
        }
      >
    >


  export type withdrawalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    account_info?: boolean
    status?: boolean
    created_at?: boolean
    users?: boolean | withdrawals$usersArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawals"]>

  export type withdrawalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    account_info?: boolean
    status?: boolean
    created_at?: boolean
    users?: boolean | withdrawals$usersArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawals"]>

  export type withdrawalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    account_info?: boolean
    status?: boolean
    created_at?: boolean
    users?: boolean | withdrawals$usersArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawals"]>

  export type withdrawalsSelectScalar = {
    id?: boolean
    user_id?: boolean
    amount?: boolean
    method?: boolean
    account_info?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type withdrawalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "amount" | "method" | "account_info" | "status" | "created_at", ExtArgs["result"]["withdrawals"]>
  export type withdrawalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | withdrawals$usersArgs<ExtArgs>
  }
  export type withdrawalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | withdrawals$usersArgs<ExtArgs>
  }
  export type withdrawalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | withdrawals$usersArgs<ExtArgs>
  }

  export type $withdrawalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "withdrawals"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      amount: Prisma.Decimal | null
      method: string | null
      account_info: Prisma.JsonValue | null
      status: string | null
      created_at: Date
    }, ExtArgs["result"]["withdrawals"]>
    composites: {}
  }

  type withdrawalsGetPayload<S extends boolean | null | undefined | withdrawalsDefaultArgs> = $Result.GetResult<Prisma.$withdrawalsPayload, S>

  type withdrawalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<withdrawalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalsCountAggregateInputType | true
    }

  export interface withdrawalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['withdrawals'], meta: { name: 'withdrawals' } }
    /**
     * Find zero or one Withdrawals that matches the filter.
     * @param {withdrawalsFindUniqueArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends withdrawalsFindUniqueArgs>(args: SelectSubset<T, withdrawalsFindUniqueArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Withdrawals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {withdrawalsFindUniqueOrThrowArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends withdrawalsFindUniqueOrThrowArgs>(args: SelectSubset<T, withdrawalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalsFindFirstArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends withdrawalsFindFirstArgs>(args?: SelectSubset<T, withdrawalsFindFirstArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalsFindFirstOrThrowArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends withdrawalsFindFirstOrThrowArgs>(args?: SelectSubset<T, withdrawalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawals.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalsWithIdOnly = await prisma.withdrawals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends withdrawalsFindManyArgs>(args?: SelectSubset<T, withdrawalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Withdrawals.
     * @param {withdrawalsCreateArgs} args - Arguments to create a Withdrawals.
     * @example
     * // Create one Withdrawals
     * const Withdrawals = await prisma.withdrawals.create({
     *   data: {
     *     // ... data to create a Withdrawals
     *   }
     * })
     * 
     */
    create<T extends withdrawalsCreateArgs>(args: SelectSubset<T, withdrawalsCreateArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Withdrawals.
     * @param {withdrawalsCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawals = await prisma.withdrawals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends withdrawalsCreateManyArgs>(args?: SelectSubset<T, withdrawalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {withdrawalsCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawals = await prisma.withdrawals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalsWithIdOnly = await prisma.withdrawals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends withdrawalsCreateManyAndReturnArgs>(args?: SelectSubset<T, withdrawalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Withdrawals.
     * @param {withdrawalsDeleteArgs} args - Arguments to delete one Withdrawals.
     * @example
     * // Delete one Withdrawals
     * const Withdrawals = await prisma.withdrawals.delete({
     *   where: {
     *     // ... filter to delete one Withdrawals
     *   }
     * })
     * 
     */
    delete<T extends withdrawalsDeleteArgs>(args: SelectSubset<T, withdrawalsDeleteArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Withdrawals.
     * @param {withdrawalsUpdateArgs} args - Arguments to update one Withdrawals.
     * @example
     * // Update one Withdrawals
     * const withdrawals = await prisma.withdrawals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends withdrawalsUpdateArgs>(args: SelectSubset<T, withdrawalsUpdateArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {withdrawalsDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends withdrawalsDeleteManyArgs>(args?: SelectSubset<T, withdrawalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawals = await prisma.withdrawals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends withdrawalsUpdateManyArgs>(args: SelectSubset<T, withdrawalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {withdrawalsUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawals = await prisma.withdrawals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalsWithIdOnly = await prisma.withdrawals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends withdrawalsUpdateManyAndReturnArgs>(args: SelectSubset<T, withdrawalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Withdrawals.
     * @param {withdrawalsUpsertArgs} args - Arguments to update or create a Withdrawals.
     * @example
     * // Update or create a Withdrawals
     * const withdrawals = await prisma.withdrawals.upsert({
     *   create: {
     *     // ... data to create a Withdrawals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawals we want to update
     *   }
     * })
     */
    upsert<T extends withdrawalsUpsertArgs>(args: SelectSubset<T, withdrawalsUpsertArgs<ExtArgs>>): Prisma__withdrawalsClient<$Result.GetResult<Prisma.$withdrawalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalsCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawals.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends withdrawalsCountArgs>(
      args?: Subset<T, withdrawalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalsAggregateArgs>(args: Subset<T, WithdrawalsAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalsAggregateType<T>>

    /**
     * Group by Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends withdrawalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: withdrawalsGroupByArgs['orderBy'] }
        : { orderBy?: withdrawalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, withdrawalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the withdrawals model
   */
  readonly fields: withdrawalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for withdrawals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__withdrawalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends withdrawals$usersArgs<ExtArgs> = {}>(args?: Subset<T, withdrawals$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the withdrawals model
   */
  interface withdrawalsFieldRefs {
    readonly id: FieldRef<"withdrawals", 'String'>
    readonly user_id: FieldRef<"withdrawals", 'String'>
    readonly amount: FieldRef<"withdrawals", 'Decimal'>
    readonly method: FieldRef<"withdrawals", 'String'>
    readonly account_info: FieldRef<"withdrawals", 'Json'>
    readonly status: FieldRef<"withdrawals", 'String'>
    readonly created_at: FieldRef<"withdrawals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * withdrawals findUnique
   */
  export type withdrawalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where: withdrawalsWhereUniqueInput
  }

  /**
   * withdrawals findUniqueOrThrow
   */
  export type withdrawalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where: withdrawalsWhereUniqueInput
  }

  /**
   * withdrawals findFirst
   */
  export type withdrawalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where?: withdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalsOrderByWithRelationInput | withdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawals.
     */
    cursor?: withdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawals.
     */
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * withdrawals findFirstOrThrow
   */
  export type withdrawalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where?: withdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalsOrderByWithRelationInput | withdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawals.
     */
    cursor?: withdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawals.
     */
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * withdrawals findMany
   */
  export type withdrawalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where?: withdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalsOrderByWithRelationInput | withdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing withdrawals.
     */
    cursor?: withdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * withdrawals create
   */
  export type withdrawalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * The data needed to create a withdrawals.
     */
    data?: XOR<withdrawalsCreateInput, withdrawalsUncheckedCreateInput>
  }

  /**
   * withdrawals createMany
   */
  export type withdrawalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many withdrawals.
     */
    data: withdrawalsCreateManyInput | withdrawalsCreateManyInput[]
  }

  /**
   * withdrawals createManyAndReturn
   */
  export type withdrawalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * The data used to create many withdrawals.
     */
    data: withdrawalsCreateManyInput | withdrawalsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * withdrawals update
   */
  export type withdrawalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * The data needed to update a withdrawals.
     */
    data: XOR<withdrawalsUpdateInput, withdrawalsUncheckedUpdateInput>
    /**
     * Choose, which withdrawals to update.
     */
    where: withdrawalsWhereUniqueInput
  }

  /**
   * withdrawals updateMany
   */
  export type withdrawalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update withdrawals.
     */
    data: XOR<withdrawalsUpdateManyMutationInput, withdrawalsUncheckedUpdateManyInput>
    /**
     * Filter which withdrawals to update
     */
    where?: withdrawalsWhereInput
    /**
     * Limit how many withdrawals to update.
     */
    limit?: number
  }

  /**
   * withdrawals updateManyAndReturn
   */
  export type withdrawalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * The data used to update withdrawals.
     */
    data: XOR<withdrawalsUpdateManyMutationInput, withdrawalsUncheckedUpdateManyInput>
    /**
     * Filter which withdrawals to update
     */
    where?: withdrawalsWhereInput
    /**
     * Limit how many withdrawals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * withdrawals upsert
   */
  export type withdrawalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * The filter to search for the withdrawals to update in case it exists.
     */
    where: withdrawalsWhereUniqueInput
    /**
     * In case the withdrawals found by the `where` argument doesn't exist, create a new withdrawals with this data.
     */
    create: XOR<withdrawalsCreateInput, withdrawalsUncheckedCreateInput>
    /**
     * In case the withdrawals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<withdrawalsUpdateInput, withdrawalsUncheckedUpdateInput>
  }

  /**
   * withdrawals delete
   */
  export type withdrawalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
    /**
     * Filter which withdrawals to delete.
     */
    where: withdrawalsWhereUniqueInput
  }

  /**
   * withdrawals deleteMany
   */
  export type withdrawalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which withdrawals to delete
     */
    where?: withdrawalsWhereInput
    /**
     * Limit how many withdrawals to delete.
     */
    limit?: number
  }

  /**
   * withdrawals.users
   */
  export type withdrawals$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * withdrawals without action
   */
  export type withdrawalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawals
     */
    select?: withdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawals
     */
    omit?: withdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalsInclude<ExtArgs> | null
  }


  /**
   * Model trades
   */

  export type AggregateTrades = {
    _count: TradesCountAggregateOutputType | null
    _avg: TradesAvgAggregateOutputType | null
    _sum: TradesSumAggregateOutputType | null
    _min: TradesMinAggregateOutputType | null
    _max: TradesMaxAggregateOutputType | null
  }

  export type TradesAvgAggregateOutputType = {
    amount: Decimal | null
    entry_price: Decimal | null
    payout: Decimal | null
  }

  export type TradesSumAggregateOutputType = {
    amount: Decimal | null
    entry_price: Decimal | null
    payout: Decimal | null
  }

  export type TradesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    symbol: string | null
    amount: Decimal | null
    direction: string | null
    open_time: Date | null
    close_time: Date | null
    result: string | null
    status: string | null
    entry_price: Decimal | null
    payout: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    account_type: string | null
  }

  export type TradesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    symbol: string | null
    amount: Decimal | null
    direction: string | null
    open_time: Date | null
    close_time: Date | null
    result: string | null
    status: string | null
    entry_price: Decimal | null
    payout: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    account_type: string | null
  }

  export type TradesCountAggregateOutputType = {
    id: number
    user_id: number
    symbol: number
    amount: number
    direction: number
    open_time: number
    close_time: number
    result: number
    status: number
    entry_price: number
    payout: number
    created_at: number
    updated_at: number
    account_type: number
    _all: number
  }


  export type TradesAvgAggregateInputType = {
    amount?: true
    entry_price?: true
    payout?: true
  }

  export type TradesSumAggregateInputType = {
    amount?: true
    entry_price?: true
    payout?: true
  }

  export type TradesMinAggregateInputType = {
    id?: true
    user_id?: true
    symbol?: true
    amount?: true
    direction?: true
    open_time?: true
    close_time?: true
    result?: true
    status?: true
    entry_price?: true
    payout?: true
    created_at?: true
    updated_at?: true
    account_type?: true
  }

  export type TradesMaxAggregateInputType = {
    id?: true
    user_id?: true
    symbol?: true
    amount?: true
    direction?: true
    open_time?: true
    close_time?: true
    result?: true
    status?: true
    entry_price?: true
    payout?: true
    created_at?: true
    updated_at?: true
    account_type?: true
  }

  export type TradesCountAggregateInputType = {
    id?: true
    user_id?: true
    symbol?: true
    amount?: true
    direction?: true
    open_time?: true
    close_time?: true
    result?: true
    status?: true
    entry_price?: true
    payout?: true
    created_at?: true
    updated_at?: true
    account_type?: true
    _all?: true
  }

  export type TradesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trades to aggregate.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trades
    **/
    _count?: true | TradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradesMaxAggregateInputType
  }

  export type GetTradesAggregateType<T extends TradesAggregateArgs> = {
        [P in keyof T & keyof AggregateTrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrades[P]>
      : GetScalarType<T[P], AggregateTrades[P]>
  }




  export type tradesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tradesWhereInput
    orderBy?: tradesOrderByWithAggregationInput | tradesOrderByWithAggregationInput[]
    by: TradesScalarFieldEnum[] | TradesScalarFieldEnum
    having?: tradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradesCountAggregateInputType | true
    _avg?: TradesAvgAggregateInputType
    _sum?: TradesSumAggregateInputType
    _min?: TradesMinAggregateInputType
    _max?: TradesMaxAggregateInputType
  }

  export type TradesGroupByOutputType = {
    id: string
    user_id: string | null
    symbol: string | null
    amount: Decimal | null
    direction: string | null
    open_time: Date | null
    close_time: Date | null
    result: string | null
    status: string | null
    entry_price: Decimal | null
    payout: Decimal | null
    created_at: Date
    updated_at: Date
    account_type: string | null
    _count: TradesCountAggregateOutputType | null
    _avg: TradesAvgAggregateOutputType | null
    _sum: TradesSumAggregateOutputType | null
    _min: TradesMinAggregateOutputType | null
    _max: TradesMaxAggregateOutputType | null
  }

  type GetTradesGroupByPayload<T extends tradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradesGroupByOutputType[P]>
            : GetScalarType<T[P], TradesGroupByOutputType[P]>
        }
      >
    >


  export type tradesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    symbol?: boolean
    amount?: boolean
    direction?: boolean
    open_time?: boolean
    close_time?: boolean
    result?: boolean
    status?: boolean
    entry_price?: boolean
    payout?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_type?: boolean
    users?: boolean | trades$usersArgs<ExtArgs>
  }, ExtArgs["result"]["trades"]>

  export type tradesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    symbol?: boolean
    amount?: boolean
    direction?: boolean
    open_time?: boolean
    close_time?: boolean
    result?: boolean
    status?: boolean
    entry_price?: boolean
    payout?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_type?: boolean
    users?: boolean | trades$usersArgs<ExtArgs>
  }, ExtArgs["result"]["trades"]>

  export type tradesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    symbol?: boolean
    amount?: boolean
    direction?: boolean
    open_time?: boolean
    close_time?: boolean
    result?: boolean
    status?: boolean
    entry_price?: boolean
    payout?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_type?: boolean
    users?: boolean | trades$usersArgs<ExtArgs>
  }, ExtArgs["result"]["trades"]>

  export type tradesSelectScalar = {
    id?: boolean
    user_id?: boolean
    symbol?: boolean
    amount?: boolean
    direction?: boolean
    open_time?: boolean
    close_time?: boolean
    result?: boolean
    status?: boolean
    entry_price?: boolean
    payout?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_type?: boolean
  }

  export type tradesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "symbol" | "amount" | "direction" | "open_time" | "close_time" | "result" | "status" | "entry_price" | "payout" | "created_at" | "updated_at" | "account_type", ExtArgs["result"]["trades"]>
  export type tradesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | trades$usersArgs<ExtArgs>
  }
  export type tradesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | trades$usersArgs<ExtArgs>
  }
  export type tradesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | trades$usersArgs<ExtArgs>
  }

  export type $tradesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trades"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      symbol: string | null
      amount: Prisma.Decimal | null
      direction: string | null
      open_time: Date | null
      close_time: Date | null
      result: string | null
      status: string | null
      entry_price: Prisma.Decimal | null
      payout: Prisma.Decimal | null
      created_at: Date
      updated_at: Date
      account_type: string | null
    }, ExtArgs["result"]["trades"]>
    composites: {}
  }

  type tradesGetPayload<S extends boolean | null | undefined | tradesDefaultArgs> = $Result.GetResult<Prisma.$tradesPayload, S>

  type tradesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tradesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradesCountAggregateInputType | true
    }

  export interface tradesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trades'], meta: { name: 'trades' } }
    /**
     * Find zero or one Trades that matches the filter.
     * @param {tradesFindUniqueArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tradesFindUniqueArgs>(args: SelectSubset<T, tradesFindUniqueArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tradesFindUniqueOrThrowArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tradesFindUniqueOrThrowArgs>(args: SelectSubset<T, tradesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesFindFirstArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tradesFindFirstArgs>(args?: SelectSubset<T, tradesFindFirstArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesFindFirstOrThrowArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tradesFindFirstOrThrowArgs>(args?: SelectSubset<T, tradesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trades.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradesWithIdOnly = await prisma.trades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tradesFindManyArgs>(args?: SelectSubset<T, tradesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trades.
     * @param {tradesCreateArgs} args - Arguments to create a Trades.
     * @example
     * // Create one Trades
     * const Trades = await prisma.trades.create({
     *   data: {
     *     // ... data to create a Trades
     *   }
     * })
     * 
     */
    create<T extends tradesCreateArgs>(args: SelectSubset<T, tradesCreateArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trades.
     * @param {tradesCreateManyArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trades = await prisma.trades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tradesCreateManyArgs>(args?: SelectSubset<T, tradesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trades and returns the data saved in the database.
     * @param {tradesCreateManyAndReturnArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trades = await prisma.trades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trades and only return the `id`
     * const tradesWithIdOnly = await prisma.trades.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tradesCreateManyAndReturnArgs>(args?: SelectSubset<T, tradesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trades.
     * @param {tradesDeleteArgs} args - Arguments to delete one Trades.
     * @example
     * // Delete one Trades
     * const Trades = await prisma.trades.delete({
     *   where: {
     *     // ... filter to delete one Trades
     *   }
     * })
     * 
     */
    delete<T extends tradesDeleteArgs>(args: SelectSubset<T, tradesDeleteArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trades.
     * @param {tradesUpdateArgs} args - Arguments to update one Trades.
     * @example
     * // Update one Trades
     * const trades = await prisma.trades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tradesUpdateArgs>(args: SelectSubset<T, tradesUpdateArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trades.
     * @param {tradesDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tradesDeleteManyArgs>(args?: SelectSubset<T, tradesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trades = await prisma.trades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tradesUpdateManyArgs>(args: SelectSubset<T, tradesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades and returns the data updated in the database.
     * @param {tradesUpdateManyAndReturnArgs} args - Arguments to update many Trades.
     * @example
     * // Update many Trades
     * const trades = await prisma.trades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trades and only return the `id`
     * const tradesWithIdOnly = await prisma.trades.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tradesUpdateManyAndReturnArgs>(args: SelectSubset<T, tradesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trades.
     * @param {tradesUpsertArgs} args - Arguments to update or create a Trades.
     * @example
     * // Update or create a Trades
     * const trades = await prisma.trades.upsert({
     *   create: {
     *     // ... data to create a Trades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trades we want to update
     *   }
     * })
     */
    upsert<T extends tradesUpsertArgs>(args: SelectSubset<T, tradesUpsertArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trades.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends tradesCountArgs>(
      args?: Subset<T, tradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradesAggregateArgs>(args: Subset<T, TradesAggregateArgs>): Prisma.PrismaPromise<GetTradesAggregateType<T>>

    /**
     * Group by Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tradesGroupByArgs['orderBy'] }
        : { orderBy?: tradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trades model
   */
  readonly fields: tradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tradesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends trades$usersArgs<ExtArgs> = {}>(args?: Subset<T, trades$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trades model
   */
  interface tradesFieldRefs {
    readonly id: FieldRef<"trades", 'String'>
    readonly user_id: FieldRef<"trades", 'String'>
    readonly symbol: FieldRef<"trades", 'String'>
    readonly amount: FieldRef<"trades", 'Decimal'>
    readonly direction: FieldRef<"trades", 'String'>
    readonly open_time: FieldRef<"trades", 'DateTime'>
    readonly close_time: FieldRef<"trades", 'DateTime'>
    readonly result: FieldRef<"trades", 'String'>
    readonly status: FieldRef<"trades", 'String'>
    readonly entry_price: FieldRef<"trades", 'Decimal'>
    readonly payout: FieldRef<"trades", 'Decimal'>
    readonly created_at: FieldRef<"trades", 'DateTime'>
    readonly updated_at: FieldRef<"trades", 'DateTime'>
    readonly account_type: FieldRef<"trades", 'String'>
  }
    

  // Custom InputTypes
  /**
   * trades findUnique
   */
  export type tradesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades findUniqueOrThrow
   */
  export type tradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades findFirst
   */
  export type tradesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trades.
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trades.
     */
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * trades findFirstOrThrow
   */
  export type tradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trades.
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trades.
     */
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * trades findMany
   */
  export type tradesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trades.
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * trades create
   */
  export type tradesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * The data needed to create a trades.
     */
    data?: XOR<tradesCreateInput, tradesUncheckedCreateInput>
  }

  /**
   * trades createMany
   */
  export type tradesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trades.
     */
    data: tradesCreateManyInput | tradesCreateManyInput[]
  }

  /**
   * trades createManyAndReturn
   */
  export type tradesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * The data used to create many trades.
     */
    data: tradesCreateManyInput | tradesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trades update
   */
  export type tradesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * The data needed to update a trades.
     */
    data: XOR<tradesUpdateInput, tradesUncheckedUpdateInput>
    /**
     * Choose, which trades to update.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades updateMany
   */
  export type tradesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trades.
     */
    data: XOR<tradesUpdateManyMutationInput, tradesUncheckedUpdateManyInput>
    /**
     * Filter which trades to update
     */
    where?: tradesWhereInput
    /**
     * Limit how many trades to update.
     */
    limit?: number
  }

  /**
   * trades updateManyAndReturn
   */
  export type tradesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * The data used to update trades.
     */
    data: XOR<tradesUpdateManyMutationInput, tradesUncheckedUpdateManyInput>
    /**
     * Filter which trades to update
     */
    where?: tradesWhereInput
    /**
     * Limit how many trades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trades upsert
   */
  export type tradesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * The filter to search for the trades to update in case it exists.
     */
    where: tradesWhereUniqueInput
    /**
     * In case the trades found by the `where` argument doesn't exist, create a new trades with this data.
     */
    create: XOR<tradesCreateInput, tradesUncheckedCreateInput>
    /**
     * In case the trades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tradesUpdateInput, tradesUncheckedUpdateInput>
  }

  /**
   * trades delete
   */
  export type tradesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter which trades to delete.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades deleteMany
   */
  export type tradesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trades to delete
     */
    where?: tradesWhereInput
    /**
     * Limit how many trades to delete.
     */
    limit?: number
  }

  /**
   * trades.users
   */
  export type trades$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * trades without action
   */
  export type tradesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
  }


  /**
   * Model leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    amount: Decimal | null
    rank: number | null
  }

  export type LeaderboardSumAggregateOutputType = {
    amount: Decimal | null
    rank: number | null
  }

  export type LeaderboardMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    amount: Decimal | null
    rank: number | null
    updated_at: Date | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    amount: Decimal | null
    rank: number | null
    updated_at: Date | null
  }

  export type LeaderboardCountAggregateOutputType = {
    id: number
    user_id: number
    amount: number
    rank: number
    updated_at: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    amount?: true
    rank?: true
  }

  export type LeaderboardSumAggregateInputType = {
    amount?: true
    rank?: true
  }

  export type LeaderboardMinAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    rank?: true
    updated_at?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    rank?: true
    updated_at?: true
  }

  export type LeaderboardCountAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    rank?: true
    updated_at?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leaderboard to aggregate.
     */
    where?: leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaderboards to fetch.
     */
    orderBy?: leaderboardOrderByWithRelationInput | leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type leaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leaderboardWhereInput
    orderBy?: leaderboardOrderByWithAggregationInput | leaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: leaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    id: string
    user_id: string | null
    amount: Decimal | null
    rank: number | null
    updated_at: Date
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends leaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type leaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    rank?: boolean
    updated_at?: boolean
    users?: boolean | leaderboard$usersArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type leaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    rank?: boolean
    updated_at?: boolean
    users?: boolean | leaderboard$usersArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type leaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    rank?: boolean
    updated_at?: boolean
    users?: boolean | leaderboard$usersArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type leaderboardSelectScalar = {
    id?: boolean
    user_id?: boolean
    amount?: boolean
    rank?: boolean
    updated_at?: boolean
  }

  export type leaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "amount" | "rank" | "updated_at", ExtArgs["result"]["leaderboard"]>
  export type leaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | leaderboard$usersArgs<ExtArgs>
  }
  export type leaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | leaderboard$usersArgs<ExtArgs>
  }
  export type leaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | leaderboard$usersArgs<ExtArgs>
  }

  export type $leaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "leaderboard"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      amount: Prisma.Decimal | null
      rank: number | null
      updated_at: Date
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }

  type leaderboardGetPayload<S extends boolean | null | undefined | leaderboardDefaultArgs> = $Result.GetResult<Prisma.$leaderboardPayload, S>

  type leaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<leaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface leaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['leaderboard'], meta: { name: 'leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {leaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends leaderboardFindUniqueArgs>(args: SelectSubset<T, leaderboardFindUniqueArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {leaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends leaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, leaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends leaderboardFindFirstArgs>(args?: SelectSubset<T, leaderboardFindFirstArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends leaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, leaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends leaderboardFindManyArgs>(args?: SelectSubset<T, leaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leaderboard.
     * @param {leaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
     */
    create<T extends leaderboardCreateArgs>(args: SelectSubset<T, leaderboardCreateArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaderboards.
     * @param {leaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends leaderboardCreateManyArgs>(args?: SelectSubset<T, leaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaderboards and returns the data saved in the database.
     * @param {leaderboardCreateManyAndReturnArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaderboards and only return the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends leaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, leaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leaderboard.
     * @param {leaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
     */
    delete<T extends leaderboardDeleteArgs>(args: SelectSubset<T, leaderboardDeleteArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leaderboard.
     * @param {leaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends leaderboardUpdateArgs>(args: SelectSubset<T, leaderboardUpdateArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaderboards.
     * @param {leaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends leaderboardDeleteManyArgs>(args?: SelectSubset<T, leaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends leaderboardUpdateManyArgs>(args: SelectSubset<T, leaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards and returns the data updated in the database.
     * @param {leaderboardUpdateManyAndReturnArgs} args - Arguments to update many Leaderboards.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaderboards and only return the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends leaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, leaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leaderboard.
     * @param {leaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
     */
    upsert<T extends leaderboardUpsertArgs>(args: SelectSubset<T, leaderboardUpsertArgs<ExtArgs>>): Prisma__leaderboardClient<$Result.GetResult<Prisma.$leaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends leaderboardCountArgs>(
      args?: Subset<T, leaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leaderboardGroupByArgs['orderBy'] }
        : { orderBy?: leaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the leaderboard model
   */
  readonly fields: leaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__leaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends leaderboard$usersArgs<ExtArgs> = {}>(args?: Subset<T, leaderboard$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the leaderboard model
   */
  interface leaderboardFieldRefs {
    readonly id: FieldRef<"leaderboard", 'String'>
    readonly user_id: FieldRef<"leaderboard", 'String'>
    readonly amount: FieldRef<"leaderboard", 'Decimal'>
    readonly rank: FieldRef<"leaderboard", 'Int'>
    readonly updated_at: FieldRef<"leaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * leaderboard findUnique
   */
  export type leaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which leaderboard to fetch.
     */
    where: leaderboardWhereUniqueInput
  }

  /**
   * leaderboard findUniqueOrThrow
   */
  export type leaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which leaderboard to fetch.
     */
    where: leaderboardWhereUniqueInput
  }

  /**
   * leaderboard findFirst
   */
  export type leaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which leaderboard to fetch.
     */
    where?: leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaderboards to fetch.
     */
    orderBy?: leaderboardOrderByWithRelationInput | leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leaderboards.
     */
    cursor?: leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * leaderboard findFirstOrThrow
   */
  export type leaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which leaderboard to fetch.
     */
    where?: leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaderboards to fetch.
     */
    orderBy?: leaderboardOrderByWithRelationInput | leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leaderboards.
     */
    cursor?: leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * leaderboard findMany
   */
  export type leaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which leaderboards to fetch.
     */
    where?: leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaderboards to fetch.
     */
    orderBy?: leaderboardOrderByWithRelationInput | leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leaderboards.
     */
    cursor?: leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * leaderboard create
   */
  export type leaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a leaderboard.
     */
    data?: XOR<leaderboardCreateInput, leaderboardUncheckedCreateInput>
  }

  /**
   * leaderboard createMany
   */
  export type leaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leaderboards.
     */
    data: leaderboardCreateManyInput | leaderboardCreateManyInput[]
  }

  /**
   * leaderboard createManyAndReturn
   */
  export type leaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many leaderboards.
     */
    data: leaderboardCreateManyInput | leaderboardCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * leaderboard update
   */
  export type leaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a leaderboard.
     */
    data: XOR<leaderboardUpdateInput, leaderboardUncheckedUpdateInput>
    /**
     * Choose, which leaderboard to update.
     */
    where: leaderboardWhereUniqueInput
  }

  /**
   * leaderboard updateMany
   */
  export type leaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leaderboards.
     */
    data: XOR<leaderboardUpdateManyMutationInput, leaderboardUncheckedUpdateManyInput>
    /**
     * Filter which leaderboards to update
     */
    where?: leaderboardWhereInput
    /**
     * Limit how many leaderboards to update.
     */
    limit?: number
  }

  /**
   * leaderboard updateManyAndReturn
   */
  export type leaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * The data used to update leaderboards.
     */
    data: XOR<leaderboardUpdateManyMutationInput, leaderboardUncheckedUpdateManyInput>
    /**
     * Filter which leaderboards to update
     */
    where?: leaderboardWhereInput
    /**
     * Limit how many leaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * leaderboard upsert
   */
  export type leaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the leaderboard to update in case it exists.
     */
    where: leaderboardWhereUniqueInput
    /**
     * In case the leaderboard found by the `where` argument doesn't exist, create a new leaderboard with this data.
     */
    create: XOR<leaderboardCreateInput, leaderboardUncheckedCreateInput>
    /**
     * In case the leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leaderboardUpdateInput, leaderboardUncheckedUpdateInput>
  }

  /**
   * leaderboard delete
   */
  export type leaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
    /**
     * Filter which leaderboard to delete.
     */
    where: leaderboardWhereUniqueInput
  }

  /**
   * leaderboard deleteMany
   */
  export type leaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leaderboards to delete
     */
    where?: leaderboardWhereInput
    /**
     * Limit how many leaderboards to delete.
     */
    limit?: number
  }

  /**
   * leaderboard.users
   */
  export type leaderboard$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * leaderboard without action
   */
  export type leaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leaderboard
     */
    select?: leaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leaderboard
     */
    omit?: leaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaderboardInclude<ExtArgs> | null
  }


  /**
   * Model tournaments
   */

  export type AggregateTournaments = {
    _count: TournamentsCountAggregateOutputType | null
    _avg: TournamentsAvgAggregateOutputType | null
    _sum: TournamentsSumAggregateOutputType | null
    _min: TournamentsMinAggregateOutputType | null
    _max: TournamentsMaxAggregateOutputType | null
  }

  export type TournamentsAvgAggregateOutputType = {
    prize_pool: Decimal | null
    entry_fee: Decimal | null
    participants: number | null
  }

  export type TournamentsSumAggregateOutputType = {
    prize_pool: Decimal | null
    entry_fee: Decimal | null
    participants: number | null
  }

  export type TournamentsMinAggregateOutputType = {
    id: string | null
    title: string | null
    prize_pool: Decimal | null
    entry_fee: Decimal | null
    participants: number | null
    duration: string | null
    status: string | null
    created_at: Date | null
  }

  export type TournamentsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    prize_pool: Decimal | null
    entry_fee: Decimal | null
    participants: number | null
    duration: string | null
    status: string | null
    created_at: Date | null
  }

  export type TournamentsCountAggregateOutputType = {
    id: number
    title: number
    prize_pool: number
    entry_fee: number
    participants: number
    duration: number
    status: number
    created_at: number
    _all: number
  }


  export type TournamentsAvgAggregateInputType = {
    prize_pool?: true
    entry_fee?: true
    participants?: true
  }

  export type TournamentsSumAggregateInputType = {
    prize_pool?: true
    entry_fee?: true
    participants?: true
  }

  export type TournamentsMinAggregateInputType = {
    id?: true
    title?: true
    prize_pool?: true
    entry_fee?: true
    participants?: true
    duration?: true
    status?: true
    created_at?: true
  }

  export type TournamentsMaxAggregateInputType = {
    id?: true
    title?: true
    prize_pool?: true
    entry_fee?: true
    participants?: true
    duration?: true
    status?: true
    created_at?: true
  }

  export type TournamentsCountAggregateInputType = {
    id?: true
    title?: true
    prize_pool?: true
    entry_fee?: true
    participants?: true
    duration?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type TournamentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to aggregate.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournaments
    **/
    _count?: true | TournamentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentsMaxAggregateInputType
  }

  export type GetTournamentsAggregateType<T extends TournamentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTournaments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournaments[P]>
      : GetScalarType<T[P], AggregateTournaments[P]>
  }




  export type tournamentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentsWhereInput
    orderBy?: tournamentsOrderByWithAggregationInput | tournamentsOrderByWithAggregationInput[]
    by: TournamentsScalarFieldEnum[] | TournamentsScalarFieldEnum
    having?: tournamentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentsCountAggregateInputType | true
    _avg?: TournamentsAvgAggregateInputType
    _sum?: TournamentsSumAggregateInputType
    _min?: TournamentsMinAggregateInputType
    _max?: TournamentsMaxAggregateInputType
  }

  export type TournamentsGroupByOutputType = {
    id: string
    title: string | null
    prize_pool: Decimal | null
    entry_fee: Decimal | null
    participants: number | null
    duration: string | null
    status: string | null
    created_at: Date
    _count: TournamentsCountAggregateOutputType | null
    _avg: TournamentsAvgAggregateOutputType | null
    _sum: TournamentsSumAggregateOutputType | null
    _min: TournamentsMinAggregateOutputType | null
    _max: TournamentsMaxAggregateOutputType | null
  }

  type GetTournamentsGroupByPayload<T extends tournamentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentsGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentsGroupByOutputType[P]>
        }
      >
    >


  export type tournamentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    prize_pool?: boolean
    entry_fee?: boolean
    participants?: boolean
    duration?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    prize_pool?: boolean
    entry_fee?: boolean
    participants?: boolean
    duration?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    prize_pool?: boolean
    entry_fee?: boolean
    participants?: boolean
    duration?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectScalar = {
    id?: boolean
    title?: boolean
    prize_pool?: boolean
    entry_fee?: boolean
    participants?: boolean
    duration?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type tournamentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "prize_pool" | "entry_fee" | "participants" | "duration" | "status" | "created_at", ExtArgs["result"]["tournaments"]>

  export type $tournamentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournaments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      prize_pool: Prisma.Decimal | null
      entry_fee: Prisma.Decimal | null
      participants: number | null
      duration: string | null
      status: string | null
      created_at: Date
    }, ExtArgs["result"]["tournaments"]>
    composites: {}
  }

  type tournamentsGetPayload<S extends boolean | null | undefined | tournamentsDefaultArgs> = $Result.GetResult<Prisma.$tournamentsPayload, S>

  type tournamentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentsCountAggregateInputType | true
    }

  export interface tournamentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournaments'], meta: { name: 'tournaments' } }
    /**
     * Find zero or one Tournaments that matches the filter.
     * @param {tournamentsFindUniqueArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentsFindUniqueArgs>(args: SelectSubset<T, tournamentsFindUniqueArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournaments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamentsFindUniqueOrThrowArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentsFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindFirstArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentsFindFirstArgs>(args?: SelectSubset<T, tournamentsFindFirstArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournaments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindFirstOrThrowArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentsFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournaments.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournaments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentsFindManyArgs>(args?: SelectSubset<T, tournamentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournaments.
     * @param {tournamentsCreateArgs} args - Arguments to create a Tournaments.
     * @example
     * // Create one Tournaments
     * const Tournaments = await prisma.tournaments.create({
     *   data: {
     *     // ... data to create a Tournaments
     *   }
     * })
     * 
     */
    create<T extends tournamentsCreateArgs>(args: SelectSubset<T, tournamentsCreateArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournaments.
     * @param {tournamentsCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournaments = await prisma.tournaments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentsCreateManyArgs>(args?: SelectSubset<T, tournamentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {tournamentsCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournaments = await prisma.tournaments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentsCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournaments.
     * @param {tournamentsDeleteArgs} args - Arguments to delete one Tournaments.
     * @example
     * // Delete one Tournaments
     * const Tournaments = await prisma.tournaments.delete({
     *   where: {
     *     // ... filter to delete one Tournaments
     *   }
     * })
     * 
     */
    delete<T extends tournamentsDeleteArgs>(args: SelectSubset<T, tournamentsDeleteArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournaments.
     * @param {tournamentsUpdateArgs} args - Arguments to update one Tournaments.
     * @example
     * // Update one Tournaments
     * const tournaments = await prisma.tournaments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentsUpdateArgs>(args: SelectSubset<T, tournamentsUpdateArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournaments.
     * @param {tournamentsDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournaments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentsDeleteManyArgs>(args?: SelectSubset<T, tournamentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournaments = await prisma.tournaments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentsUpdateManyArgs>(args: SelectSubset<T, tournamentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments and returns the data updated in the database.
     * @param {tournamentsUpdateManyAndReturnArgs} args - Arguments to update many Tournaments.
     * @example
     * // Update many Tournaments
     * const tournaments = await prisma.tournaments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournaments and only return the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamentsUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournaments.
     * @param {tournamentsUpsertArgs} args - Arguments to update or create a Tournaments.
     * @example
     * // Update or create a Tournaments
     * const tournaments = await prisma.tournaments.upsert({
     *   create: {
     *     // ... data to create a Tournaments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournaments we want to update
     *   }
     * })
     */
    upsert<T extends tournamentsUpsertArgs>(args: SelectSubset<T, tournamentsUpsertArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournaments.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends tournamentsCountArgs>(
      args?: Subset<T, tournamentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentsAggregateArgs>(args: Subset<T, TournamentsAggregateArgs>): Prisma.PrismaPromise<GetTournamentsAggregateType<T>>

    /**
     * Group by Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentsGroupByArgs['orderBy'] }
        : { orderBy?: tournamentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournaments model
   */
  readonly fields: tournamentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournaments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournaments model
   */
  interface tournamentsFieldRefs {
    readonly id: FieldRef<"tournaments", 'String'>
    readonly title: FieldRef<"tournaments", 'String'>
    readonly prize_pool: FieldRef<"tournaments", 'Decimal'>
    readonly entry_fee: FieldRef<"tournaments", 'Decimal'>
    readonly participants: FieldRef<"tournaments", 'Int'>
    readonly duration: FieldRef<"tournaments", 'String'>
    readonly status: FieldRef<"tournaments", 'String'>
    readonly created_at: FieldRef<"tournaments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tournaments findUnique
   */
  export type tournamentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments findUniqueOrThrow
   */
  export type tournamentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments findFirst
   */
  export type tournamentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments findFirstOrThrow
   */
  export type tournamentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments findMany
   */
  export type tournamentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments create
   */
  export type tournamentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * The data needed to create a tournaments.
     */
    data?: XOR<tournamentsCreateInput, tournamentsUncheckedCreateInput>
  }

  /**
   * tournaments createMany
   */
  export type tournamentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournaments.
     */
    data: tournamentsCreateManyInput | tournamentsCreateManyInput[]
  }

  /**
   * tournaments createManyAndReturn
   */
  export type tournamentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * The data used to create many tournaments.
     */
    data: tournamentsCreateManyInput | tournamentsCreateManyInput[]
  }

  /**
   * tournaments update
   */
  export type tournamentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * The data needed to update a tournaments.
     */
    data: XOR<tournamentsUpdateInput, tournamentsUncheckedUpdateInput>
    /**
     * Choose, which tournaments to update.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments updateMany
   */
  export type tournamentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentsUpdateManyMutationInput, tournamentsUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentsWhereInput
    /**
     * Limit how many tournaments to update.
     */
    limit?: number
  }

  /**
   * tournaments updateManyAndReturn
   */
  export type tournamentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentsUpdateManyMutationInput, tournamentsUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentsWhereInput
    /**
     * Limit how many tournaments to update.
     */
    limit?: number
  }

  /**
   * tournaments upsert
   */
  export type tournamentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * The filter to search for the tournaments to update in case it exists.
     */
    where: tournamentsWhereUniqueInput
    /**
     * In case the tournaments found by the `where` argument doesn't exist, create a new tournaments with this data.
     */
    create: XOR<tournamentsCreateInput, tournamentsUncheckedCreateInput>
    /**
     * In case the tournaments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentsUpdateInput, tournamentsUncheckedUpdateInput>
  }

  /**
   * tournaments delete
   */
  export type tournamentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
    /**
     * Filter which tournaments to delete.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments deleteMany
   */
  export type tournamentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to delete
     */
    where?: tournamentsWhereInput
    /**
     * Limit how many tournaments to delete.
     */
    limit?: number
  }

  /**
   * tournaments without action
   */
  export type tournamentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournaments
     */
    omit?: tournamentsOmit<ExtArgs> | null
  }


  /**
   * Model support_messages
   */

  export type AggregateSupport_messages = {
    _count: Support_messagesCountAggregateOutputType | null
    _min: Support_messagesMinAggregateOutputType | null
    _max: Support_messagesMaxAggregateOutputType | null
  }

  export type Support_messagesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    created_at: Date | null
  }

  export type Support_messagesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    created_at: Date | null
  }

  export type Support_messagesCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    email: number
    subject: number
    message: number
    created_at: number
    _all: number
  }


  export type Support_messagesMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    created_at?: true
  }

  export type Support_messagesMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    created_at?: true
  }

  export type Support_messagesCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    created_at?: true
    _all?: true
  }

  export type Support_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_messages to aggregate.
     */
    where?: support_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_messages to fetch.
     */
    orderBy?: support_messagesOrderByWithRelationInput | support_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_messages
    **/
    _count?: true | Support_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_messagesMaxAggregateInputType
  }

  export type GetSupport_messagesAggregateType<T extends Support_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_messages[P]>
      : GetScalarType<T[P], AggregateSupport_messages[P]>
  }




  export type support_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_messagesWhereInput
    orderBy?: support_messagesOrderByWithAggregationInput | support_messagesOrderByWithAggregationInput[]
    by: Support_messagesScalarFieldEnum[] | Support_messagesScalarFieldEnum
    having?: support_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_messagesCountAggregateInputType | true
    _min?: Support_messagesMinAggregateInputType
    _max?: Support_messagesMaxAggregateInputType
  }

  export type Support_messagesGroupByOutputType = {
    id: string
    user_id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    created_at: Date
    _count: Support_messagesCountAggregateOutputType | null
    _min: Support_messagesMinAggregateOutputType | null
    _max: Support_messagesMaxAggregateOutputType | null
  }

  type GetSupport_messagesGroupByPayload<T extends support_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_messagesGroupByOutputType[P]>
        }
      >
    >


  export type support_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    created_at?: boolean
    users?: boolean | support_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["support_messages"]>

  export type support_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    created_at?: boolean
    users?: boolean | support_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["support_messages"]>

  export type support_messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    created_at?: boolean
    users?: boolean | support_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["support_messages"]>

  export type support_messagesSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    created_at?: boolean
  }

  export type support_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "email" | "subject" | "message" | "created_at", ExtArgs["result"]["support_messages"]>
  export type support_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | support_messages$usersArgs<ExtArgs>
  }
  export type support_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | support_messages$usersArgs<ExtArgs>
  }
  export type support_messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | support_messages$usersArgs<ExtArgs>
  }

  export type $support_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_messages"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      name: string | null
      email: string | null
      subject: string | null
      message: string | null
      created_at: Date
    }, ExtArgs["result"]["support_messages"]>
    composites: {}
  }

  type support_messagesGetPayload<S extends boolean | null | undefined | support_messagesDefaultArgs> = $Result.GetResult<Prisma.$support_messagesPayload, S>

  type support_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_messagesCountAggregateInputType | true
    }

  export interface support_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_messages'], meta: { name: 'support_messages' } }
    /**
     * Find zero or one Support_messages that matches the filter.
     * @param {support_messagesFindUniqueArgs} args - Arguments to find a Support_messages
     * @example
     * // Get one Support_messages
     * const support_messages = await prisma.support_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_messagesFindUniqueArgs>(args: SelectSubset<T, support_messagesFindUniqueArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_messagesFindUniqueOrThrowArgs} args - Arguments to find a Support_messages
     * @example
     * // Get one Support_messages
     * const support_messages = await prisma.support_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_messagesFindFirstArgs} args - Arguments to find a Support_messages
     * @example
     * // Get one Support_messages
     * const support_messages = await prisma.support_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_messagesFindFirstArgs>(args?: SelectSubset<T, support_messagesFindFirstArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_messagesFindFirstOrThrowArgs} args - Arguments to find a Support_messages
     * @example
     * // Get one Support_messages
     * const support_messages = await prisma.support_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_messages
     * const support_messages = await prisma.support_messages.findMany()
     * 
     * // Get first 10 Support_messages
     * const support_messages = await prisma.support_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_messagesWithIdOnly = await prisma.support_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_messagesFindManyArgs>(args?: SelectSubset<T, support_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_messages.
     * @param {support_messagesCreateArgs} args - Arguments to create a Support_messages.
     * @example
     * // Create one Support_messages
     * const Support_messages = await prisma.support_messages.create({
     *   data: {
     *     // ... data to create a Support_messages
     *   }
     * })
     * 
     */
    create<T extends support_messagesCreateArgs>(args: SelectSubset<T, support_messagesCreateArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_messages.
     * @param {support_messagesCreateManyArgs} args - Arguments to create many Support_messages.
     * @example
     * // Create many Support_messages
     * const support_messages = await prisma.support_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_messagesCreateManyArgs>(args?: SelectSubset<T, support_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_messages and returns the data saved in the database.
     * @param {support_messagesCreateManyAndReturnArgs} args - Arguments to create many Support_messages.
     * @example
     * // Create many Support_messages
     * const support_messages = await prisma.support_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_messages and only return the `id`
     * const support_messagesWithIdOnly = await prisma.support_messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_messages.
     * @param {support_messagesDeleteArgs} args - Arguments to delete one Support_messages.
     * @example
     * // Delete one Support_messages
     * const Support_messages = await prisma.support_messages.delete({
     *   where: {
     *     // ... filter to delete one Support_messages
     *   }
     * })
     * 
     */
    delete<T extends support_messagesDeleteArgs>(args: SelectSubset<T, support_messagesDeleteArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_messages.
     * @param {support_messagesUpdateArgs} args - Arguments to update one Support_messages.
     * @example
     * // Update one Support_messages
     * const support_messages = await prisma.support_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_messagesUpdateArgs>(args: SelectSubset<T, support_messagesUpdateArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_messages.
     * @param {support_messagesDeleteManyArgs} args - Arguments to filter Support_messages to delete.
     * @example
     * // Delete a few Support_messages
     * const { count } = await prisma.support_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_messagesDeleteManyArgs>(args?: SelectSubset<T, support_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_messages
     * const support_messages = await prisma.support_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_messagesUpdateManyArgs>(args: SelectSubset<T, support_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_messages and returns the data updated in the database.
     * @param {support_messagesUpdateManyAndReturnArgs} args - Arguments to update many Support_messages.
     * @example
     * // Update many Support_messages
     * const support_messages = await prisma.support_messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_messages and only return the `id`
     * const support_messagesWithIdOnly = await prisma.support_messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_messages.
     * @param {support_messagesUpsertArgs} args - Arguments to update or create a Support_messages.
     * @example
     * // Update or create a Support_messages
     * const support_messages = await prisma.support_messages.upsert({
     *   create: {
     *     // ... data to create a Support_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_messages we want to update
     *   }
     * })
     */
    upsert<T extends support_messagesUpsertArgs>(args: SelectSubset<T, support_messagesUpsertArgs<ExtArgs>>): Prisma__support_messagesClient<$Result.GetResult<Prisma.$support_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_messagesCountArgs} args - Arguments to filter Support_messages to count.
     * @example
     * // Count the number of Support_messages
     * const count = await prisma.support_messages.count({
     *   where: {
     *     // ... the filter for the Support_messages we want to count
     *   }
     * })
    **/
    count<T extends support_messagesCountArgs>(
      args?: Subset<T, support_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_messagesAggregateArgs>(args: Subset<T, Support_messagesAggregateArgs>): Prisma.PrismaPromise<GetSupport_messagesAggregateType<T>>

    /**
     * Group by Support_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_messagesGroupByArgs['orderBy'] }
        : { orderBy?: support_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_messages model
   */
  readonly fields: support_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends support_messages$usersArgs<ExtArgs> = {}>(args?: Subset<T, support_messages$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_messages model
   */
  interface support_messagesFieldRefs {
    readonly id: FieldRef<"support_messages", 'String'>
    readonly user_id: FieldRef<"support_messages", 'String'>
    readonly name: FieldRef<"support_messages", 'String'>
    readonly email: FieldRef<"support_messages", 'String'>
    readonly subject: FieldRef<"support_messages", 'String'>
    readonly message: FieldRef<"support_messages", 'String'>
    readonly created_at: FieldRef<"support_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_messages findUnique
   */
  export type support_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * Filter, which support_messages to fetch.
     */
    where: support_messagesWhereUniqueInput
  }

  /**
   * support_messages findUniqueOrThrow
   */
  export type support_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * Filter, which support_messages to fetch.
     */
    where: support_messagesWhereUniqueInput
  }

  /**
   * support_messages findFirst
   */
  export type support_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * Filter, which support_messages to fetch.
     */
    where?: support_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_messages to fetch.
     */
    orderBy?: support_messagesOrderByWithRelationInput | support_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_messages.
     */
    cursor?: support_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_messages.
     */
    distinct?: Support_messagesScalarFieldEnum | Support_messagesScalarFieldEnum[]
  }

  /**
   * support_messages findFirstOrThrow
   */
  export type support_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * Filter, which support_messages to fetch.
     */
    where?: support_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_messages to fetch.
     */
    orderBy?: support_messagesOrderByWithRelationInput | support_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_messages.
     */
    cursor?: support_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_messages.
     */
    distinct?: Support_messagesScalarFieldEnum | Support_messagesScalarFieldEnum[]
  }

  /**
   * support_messages findMany
   */
  export type support_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * Filter, which support_messages to fetch.
     */
    where?: support_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_messages to fetch.
     */
    orderBy?: support_messagesOrderByWithRelationInput | support_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_messages.
     */
    cursor?: support_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_messages.
     */
    skip?: number
    distinct?: Support_messagesScalarFieldEnum | Support_messagesScalarFieldEnum[]
  }

  /**
   * support_messages create
   */
  export type support_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a support_messages.
     */
    data?: XOR<support_messagesCreateInput, support_messagesUncheckedCreateInput>
  }

  /**
   * support_messages createMany
   */
  export type support_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_messages.
     */
    data: support_messagesCreateManyInput | support_messagesCreateManyInput[]
  }

  /**
   * support_messages createManyAndReturn
   */
  export type support_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * The data used to create many support_messages.
     */
    data: support_messagesCreateManyInput | support_messagesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * support_messages update
   */
  export type support_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a support_messages.
     */
    data: XOR<support_messagesUpdateInput, support_messagesUncheckedUpdateInput>
    /**
     * Choose, which support_messages to update.
     */
    where: support_messagesWhereUniqueInput
  }

  /**
   * support_messages updateMany
   */
  export type support_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_messages.
     */
    data: XOR<support_messagesUpdateManyMutationInput, support_messagesUncheckedUpdateManyInput>
    /**
     * Filter which support_messages to update
     */
    where?: support_messagesWhereInput
    /**
     * Limit how many support_messages to update.
     */
    limit?: number
  }

  /**
   * support_messages updateManyAndReturn
   */
  export type support_messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * The data used to update support_messages.
     */
    data: XOR<support_messagesUpdateManyMutationInput, support_messagesUncheckedUpdateManyInput>
    /**
     * Filter which support_messages to update
     */
    where?: support_messagesWhereInput
    /**
     * Limit how many support_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * support_messages upsert
   */
  export type support_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the support_messages to update in case it exists.
     */
    where: support_messagesWhereUniqueInput
    /**
     * In case the support_messages found by the `where` argument doesn't exist, create a new support_messages with this data.
     */
    create: XOR<support_messagesCreateInput, support_messagesUncheckedCreateInput>
    /**
     * In case the support_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_messagesUpdateInput, support_messagesUncheckedUpdateInput>
  }

  /**
   * support_messages delete
   */
  export type support_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
    /**
     * Filter which support_messages to delete.
     */
    where: support_messagesWhereUniqueInput
  }

  /**
   * support_messages deleteMany
   */
  export type support_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_messages to delete
     */
    where?: support_messagesWhereInput
    /**
     * Limit how many support_messages to delete.
     */
    limit?: number
  }

  /**
   * support_messages.users
   */
  export type support_messages$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * support_messages without action
   */
  export type support_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_messages
     */
    select?: support_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_messages
     */
    omit?: support_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: support_messagesInclude<ExtArgs> | null
  }


  /**
   * Model chat_messages
   */

  export type AggregateChat_messages = {
    _count: Chat_messagesCountAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  export type Chat_messagesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    sender: string | null
    message: string | null
    time: Date | null
  }

  export type Chat_messagesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    sender: string | null
    message: string | null
    time: Date | null
  }

  export type Chat_messagesCountAggregateOutputType = {
    id: number
    user_id: number
    sender: number
    message: number
    time: number
    _all: number
  }


  export type Chat_messagesMinAggregateInputType = {
    id?: true
    user_id?: true
    sender?: true
    message?: true
    time?: true
  }

  export type Chat_messagesMaxAggregateInputType = {
    id?: true
    user_id?: true
    sender?: true
    message?: true
    time?: true
  }

  export type Chat_messagesCountAggregateInputType = {
    id?: true
    user_id?: true
    sender?: true
    message?: true
    time?: true
    _all?: true
  }

  export type Chat_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to aggregate.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_messages
    **/
    _count?: true | Chat_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type GetChat_messagesAggregateType<T extends Chat_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_messages[P]>
      : GetScalarType<T[P], AggregateChat_messages[P]>
  }




  export type chat_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithAggregationInput | chat_messagesOrderByWithAggregationInput[]
    by: Chat_messagesScalarFieldEnum[] | Chat_messagesScalarFieldEnum
    having?: chat_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_messagesCountAggregateInputType | true
    _min?: Chat_messagesMinAggregateInputType
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type Chat_messagesGroupByOutputType = {
    id: string
    user_id: string | null
    sender: string | null
    message: string | null
    time: Date
    _count: Chat_messagesCountAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  type GetChat_messagesGroupByPayload<T extends chat_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
        }
      >
    >


  export type chat_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    sender?: boolean
    message?: boolean
    time?: boolean
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    sender?: boolean
    message?: boolean
    time?: boolean
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    sender?: boolean
    message?: boolean
    time?: boolean
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectScalar = {
    id?: boolean
    user_id?: boolean
    sender?: boolean
    message?: boolean
    time?: boolean
  }

  export type chat_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "sender" | "message" | "time", ExtArgs["result"]["chat_messages"]>
  export type chat_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }
  export type chat_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }
  export type chat_messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }

  export type $chat_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_messages"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      sender: string | null
      message: string | null
      time: Date
    }, ExtArgs["result"]["chat_messages"]>
    composites: {}
  }

  type chat_messagesGetPayload<S extends boolean | null | undefined | chat_messagesDefaultArgs> = $Result.GetResult<Prisma.$chat_messagesPayload, S>

  type chat_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_messagesCountAggregateInputType | true
    }

  export interface chat_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_messages'], meta: { name: 'chat_messages' } }
    /**
     * Find zero or one Chat_messages that matches the filter.
     * @param {chat_messagesFindUniqueArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_messagesFindUniqueArgs>(args: SelectSubset<T, chat_messagesFindUniqueArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_messagesFindUniqueOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_messagesFindFirstArgs>(args?: SelectSubset<T, chat_messagesFindFirstArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany()
     * 
     * // Get first 10 Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_messagesFindManyArgs>(args?: SelectSubset<T, chat_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_messages.
     * @param {chat_messagesCreateArgs} args - Arguments to create a Chat_messages.
     * @example
     * // Create one Chat_messages
     * const Chat_messages = await prisma.chat_messages.create({
     *   data: {
     *     // ... data to create a Chat_messages
     *   }
     * })
     * 
     */
    create<T extends chat_messagesCreateArgs>(args: SelectSubset<T, chat_messagesCreateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_messages.
     * @param {chat_messagesCreateManyArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_messagesCreateManyArgs>(args?: SelectSubset<T, chat_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_messages and returns the data saved in the database.
     * @param {chat_messagesCreateManyAndReturnArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_messages.
     * @param {chat_messagesDeleteArgs} args - Arguments to delete one Chat_messages.
     * @example
     * // Delete one Chat_messages
     * const Chat_messages = await prisma.chat_messages.delete({
     *   where: {
     *     // ... filter to delete one Chat_messages
     *   }
     * })
     * 
     */
    delete<T extends chat_messagesDeleteArgs>(args: SelectSubset<T, chat_messagesDeleteArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_messages.
     * @param {chat_messagesUpdateArgs} args - Arguments to update one Chat_messages.
     * @example
     * // Update one Chat_messages
     * const chat_messages = await prisma.chat_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_messagesUpdateArgs>(args: SelectSubset<T, chat_messagesUpdateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_messages.
     * @param {chat_messagesDeleteManyArgs} args - Arguments to filter Chat_messages to delete.
     * @example
     * // Delete a few Chat_messages
     * const { count } = await prisma.chat_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_messagesDeleteManyArgs>(args?: SelectSubset<T, chat_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_messagesUpdateManyArgs>(args: SelectSubset<T, chat_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages and returns the data updated in the database.
     * @param {chat_messagesUpdateManyAndReturnArgs} args - Arguments to update many Chat_messages.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_messages.
     * @param {chat_messagesUpsertArgs} args - Arguments to update or create a Chat_messages.
     * @example
     * // Update or create a Chat_messages
     * const chat_messages = await prisma.chat_messages.upsert({
     *   create: {
     *     // ... data to create a Chat_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_messages we want to update
     *   }
     * })
     */
    upsert<T extends chat_messagesUpsertArgs>(args: SelectSubset<T, chat_messagesUpsertArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesCountArgs} args - Arguments to filter Chat_messages to count.
     * @example
     * // Count the number of Chat_messages
     * const count = await prisma.chat_messages.count({
     *   where: {
     *     // ... the filter for the Chat_messages we want to count
     *   }
     * })
    **/
    count<T extends chat_messagesCountArgs>(
      args?: Subset<T, chat_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_messagesAggregateArgs>(args: Subset<T, Chat_messagesAggregateArgs>): Prisma.PrismaPromise<GetChat_messagesAggregateType<T>>

    /**
     * Group by Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_messagesGroupByArgs['orderBy'] }
        : { orderBy?: chat_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_messages model
   */
  readonly fields: chat_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends chat_messages$usersArgs<ExtArgs> = {}>(args?: Subset<T, chat_messages$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_messages model
   */
  interface chat_messagesFieldRefs {
    readonly id: FieldRef<"chat_messages", 'String'>
    readonly user_id: FieldRef<"chat_messages", 'String'>
    readonly sender: FieldRef<"chat_messages", 'String'>
    readonly message: FieldRef<"chat_messages", 'String'>
    readonly time: FieldRef<"chat_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chat_messages findUnique
   */
  export type chat_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findUniqueOrThrow
   */
  export type chat_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findFirst
   */
  export type chat_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findFirstOrThrow
   */
  export type chat_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findMany
   */
  export type chat_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages create
   */
  export type chat_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_messages.
     */
    data?: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
  }

  /**
   * chat_messages createMany
   */
  export type chat_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
  }

  /**
   * chat_messages createManyAndReturn
   */
  export type chat_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages update
   */
  export type chat_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_messages.
     */
    data: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
    /**
     * Choose, which chat_messages to update.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages updateMany
   */
  export type chat_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to update.
     */
    limit?: number
  }

  /**
   * chat_messages updateManyAndReturn
   */
  export type chat_messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages upsert
   */
  export type chat_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_messages to update in case it exists.
     */
    where: chat_messagesWhereUniqueInput
    /**
     * In case the chat_messages found by the `where` argument doesn't exist, create a new chat_messages with this data.
     */
    create: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
    /**
     * In case the chat_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
  }

  /**
   * chat_messages delete
   */
  export type chat_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter which chat_messages to delete.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages deleteMany
   */
  export type chat_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to delete
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to delete.
     */
    limit?: number
  }

  /**
   * chat_messages.users
   */
  export type chat_messages$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * chat_messages without action
   */
  export type chat_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
  }


  /**
   * Model settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    notifications: boolean | null
    private: boolean | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    notifications: boolean | null
    private: boolean | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    user_id: number
    notifications: number
    private: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    user_id?: true
    notifications?: true
    private?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    user_id?: true
    notifications?: true
    private?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    user_id?: true
    notifications?: true
    private?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    user_id: string | null
    notifications: boolean | null
    private: boolean | null
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notifications?: boolean
    private?: boolean
    users?: boolean | settings$usersArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notifications?: boolean
    private?: boolean
    users?: boolean | settings$usersArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notifications?: boolean
    private?: boolean
    users?: boolean | settings$usersArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectScalar = {
    id?: boolean
    user_id?: boolean
    notifications?: boolean
    private?: boolean
  }

  export type settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "notifications" | "private", ExtArgs["result"]["settings"]>
  export type settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | settings$usersArgs<ExtArgs>
  }
  export type settingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | settings$usersArgs<ExtArgs>
  }
  export type settingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | settings$usersArgs<ExtArgs>
  }

  export type $settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settings"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      notifications: boolean | null
      private: boolean | null
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type settingsGetPayload<S extends boolean | null | undefined | settingsDefaultArgs> = $Result.GetResult<Prisma.$settingsPayload, S>

  type settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settings'], meta: { name: 'settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingsFindUniqueArgs>(args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingsFindFirstArgs>(args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends settingsFindManyArgs>(args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends settingsCreateArgs>(args: SelectSubset<T, settingsCreateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingsCreateManyArgs>(args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {settingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends settingsDeleteArgs>(args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingsUpdateArgs>(args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingsDeleteManyArgs>(args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingsUpdateManyArgs>(args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {settingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends settingsUpdateManyAndReturnArgs>(args: SelectSubset<T, settingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends settingsUpsertArgs>(args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs['orderBy'] }
        : { orderBy?: settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settings model
   */
  readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends settings$usersArgs<ExtArgs> = {}>(args?: Subset<T, settings$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settings model
   */
  interface settingsFieldRefs {
    readonly id: FieldRef<"settings", 'String'>
    readonly user_id: FieldRef<"settings", 'String'>
    readonly notifications: FieldRef<"settings", 'Boolean'>
    readonly private: FieldRef<"settings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a settings.
     */
    data?: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }

  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
  }

  /**
   * settings createManyAndReturn
   */
  export type settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * settings updateManyAndReturn
   */
  export type settingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }

  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to delete.
     */
    limit?: number
  }

  /**
   * settings.users
   */
  export type settings$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * settings without action
   */
  export type settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
  }


  /**
   * Model crypto_assets
   */

  export type AggregateCrypto_assets = {
    _count: Crypto_assetsCountAggregateOutputType | null
    _avg: Crypto_assetsAvgAggregateOutputType | null
    _sum: Crypto_assetsSumAggregateOutputType | null
    _min: Crypto_assetsMinAggregateOutputType | null
    _max: Crypto_assetsMaxAggregateOutputType | null
  }

  export type Crypto_assetsAvgAggregateOutputType = {
    decimals: number | null
    min_deposit: Decimal | null
  }

  export type Crypto_assetsSumAggregateOutputType = {
    decimals: number | null
    min_deposit: Decimal | null
  }

  export type Crypto_assetsMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    network: string | null
    display_name: string | null
    contract: string | null
    decimals: number | null
    min_deposit: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Crypto_assetsMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    network: string | null
    display_name: string | null
    contract: string | null
    decimals: number | null
    min_deposit: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Crypto_assetsCountAggregateOutputType = {
    id: number
    symbol: number
    network: number
    display_name: number
    contract: number
    decimals: number
    min_deposit: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Crypto_assetsAvgAggregateInputType = {
    decimals?: true
    min_deposit?: true
  }

  export type Crypto_assetsSumAggregateInputType = {
    decimals?: true
    min_deposit?: true
  }

  export type Crypto_assetsMinAggregateInputType = {
    id?: true
    symbol?: true
    network?: true
    display_name?: true
    contract?: true
    decimals?: true
    min_deposit?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Crypto_assetsMaxAggregateInputType = {
    id?: true
    symbol?: true
    network?: true
    display_name?: true
    contract?: true
    decimals?: true
    min_deposit?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Crypto_assetsCountAggregateInputType = {
    id?: true
    symbol?: true
    network?: true
    display_name?: true
    contract?: true
    decimals?: true
    min_deposit?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Crypto_assetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crypto_assets to aggregate.
     */
    where?: crypto_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_assets to fetch.
     */
    orderBy?: crypto_assetsOrderByWithRelationInput | crypto_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crypto_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crypto_assets
    **/
    _count?: true | Crypto_assetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Crypto_assetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Crypto_assetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Crypto_assetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Crypto_assetsMaxAggregateInputType
  }

  export type GetCrypto_assetsAggregateType<T extends Crypto_assetsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrypto_assets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrypto_assets[P]>
      : GetScalarType<T[P], AggregateCrypto_assets[P]>
  }




  export type crypto_assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crypto_assetsWhereInput
    orderBy?: crypto_assetsOrderByWithAggregationInput | crypto_assetsOrderByWithAggregationInput[]
    by: Crypto_assetsScalarFieldEnum[] | Crypto_assetsScalarFieldEnum
    having?: crypto_assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Crypto_assetsCountAggregateInputType | true
    _avg?: Crypto_assetsAvgAggregateInputType
    _sum?: Crypto_assetsSumAggregateInputType
    _min?: Crypto_assetsMinAggregateInputType
    _max?: Crypto_assetsMaxAggregateInputType
  }

  export type Crypto_assetsGroupByOutputType = {
    id: string
    symbol: string
    network: string
    display_name: string | null
    contract: string | null
    decimals: number
    min_deposit: Decimal
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Crypto_assetsCountAggregateOutputType | null
    _avg: Crypto_assetsAvgAggregateOutputType | null
    _sum: Crypto_assetsSumAggregateOutputType | null
    _min: Crypto_assetsMinAggregateOutputType | null
    _max: Crypto_assetsMaxAggregateOutputType | null
  }

  type GetCrypto_assetsGroupByPayload<T extends crypto_assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Crypto_assetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Crypto_assetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Crypto_assetsGroupByOutputType[P]>
            : GetScalarType<T[P], Crypto_assetsGroupByOutputType[P]>
        }
      >
    >


  export type crypto_assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    network?: boolean
    display_name?: boolean
    contract?: boolean
    decimals?: boolean
    min_deposit?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    deposit_sessions?: boolean | crypto_assets$deposit_sessionsArgs<ExtArgs>
    _count?: boolean | Crypto_assetsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crypto_assets"]>

  export type crypto_assetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    network?: boolean
    display_name?: boolean
    contract?: boolean
    decimals?: boolean
    min_deposit?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["crypto_assets"]>

  export type crypto_assetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    network?: boolean
    display_name?: boolean
    contract?: boolean
    decimals?: boolean
    min_deposit?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["crypto_assets"]>

  export type crypto_assetsSelectScalar = {
    id?: boolean
    symbol?: boolean
    network?: boolean
    display_name?: boolean
    contract?: boolean
    decimals?: boolean
    min_deposit?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type crypto_assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "network" | "display_name" | "contract" | "decimals" | "min_deposit" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["crypto_assets"]>
  export type crypto_assetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit_sessions?: boolean | crypto_assets$deposit_sessionsArgs<ExtArgs>
    _count?: boolean | Crypto_assetsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type crypto_assetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type crypto_assetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $crypto_assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "crypto_assets"
    objects: {
      deposit_sessions: Prisma.$deposit_sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      network: string
      display_name: string | null
      contract: string | null
      decimals: number
      min_deposit: Prisma.Decimal
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["crypto_assets"]>
    composites: {}
  }

  type crypto_assetsGetPayload<S extends boolean | null | undefined | crypto_assetsDefaultArgs> = $Result.GetResult<Prisma.$crypto_assetsPayload, S>

  type crypto_assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<crypto_assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Crypto_assetsCountAggregateInputType | true
    }

  export interface crypto_assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crypto_assets'], meta: { name: 'crypto_assets' } }
    /**
     * Find zero or one Crypto_assets that matches the filter.
     * @param {crypto_assetsFindUniqueArgs} args - Arguments to find a Crypto_assets
     * @example
     * // Get one Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends crypto_assetsFindUniqueArgs>(args: SelectSubset<T, crypto_assetsFindUniqueArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crypto_assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {crypto_assetsFindUniqueOrThrowArgs} args - Arguments to find a Crypto_assets
     * @example
     * // Get one Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends crypto_assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, crypto_assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crypto_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_assetsFindFirstArgs} args - Arguments to find a Crypto_assets
     * @example
     * // Get one Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends crypto_assetsFindFirstArgs>(args?: SelectSubset<T, crypto_assetsFindFirstArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crypto_assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_assetsFindFirstOrThrowArgs} args - Arguments to find a Crypto_assets
     * @example
     * // Get one Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends crypto_assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, crypto_assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crypto_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.findMany()
     * 
     * // Get first 10 Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crypto_assetsWithIdOnly = await prisma.crypto_assets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends crypto_assetsFindManyArgs>(args?: SelectSubset<T, crypto_assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crypto_assets.
     * @param {crypto_assetsCreateArgs} args - Arguments to create a Crypto_assets.
     * @example
     * // Create one Crypto_assets
     * const Crypto_assets = await prisma.crypto_assets.create({
     *   data: {
     *     // ... data to create a Crypto_assets
     *   }
     * })
     * 
     */
    create<T extends crypto_assetsCreateArgs>(args: SelectSubset<T, crypto_assetsCreateArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crypto_assets.
     * @param {crypto_assetsCreateManyArgs} args - Arguments to create many Crypto_assets.
     * @example
     * // Create many Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends crypto_assetsCreateManyArgs>(args?: SelectSubset<T, crypto_assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crypto_assets and returns the data saved in the database.
     * @param {crypto_assetsCreateManyAndReturnArgs} args - Arguments to create many Crypto_assets.
     * @example
     * // Create many Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crypto_assets and only return the `id`
     * const crypto_assetsWithIdOnly = await prisma.crypto_assets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends crypto_assetsCreateManyAndReturnArgs>(args?: SelectSubset<T, crypto_assetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crypto_assets.
     * @param {crypto_assetsDeleteArgs} args - Arguments to delete one Crypto_assets.
     * @example
     * // Delete one Crypto_assets
     * const Crypto_assets = await prisma.crypto_assets.delete({
     *   where: {
     *     // ... filter to delete one Crypto_assets
     *   }
     * })
     * 
     */
    delete<T extends crypto_assetsDeleteArgs>(args: SelectSubset<T, crypto_assetsDeleteArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crypto_assets.
     * @param {crypto_assetsUpdateArgs} args - Arguments to update one Crypto_assets.
     * @example
     * // Update one Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends crypto_assetsUpdateArgs>(args: SelectSubset<T, crypto_assetsUpdateArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crypto_assets.
     * @param {crypto_assetsDeleteManyArgs} args - Arguments to filter Crypto_assets to delete.
     * @example
     * // Delete a few Crypto_assets
     * const { count } = await prisma.crypto_assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends crypto_assetsDeleteManyArgs>(args?: SelectSubset<T, crypto_assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crypto_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends crypto_assetsUpdateManyArgs>(args: SelectSubset<T, crypto_assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crypto_assets and returns the data updated in the database.
     * @param {crypto_assetsUpdateManyAndReturnArgs} args - Arguments to update many Crypto_assets.
     * @example
     * // Update many Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crypto_assets and only return the `id`
     * const crypto_assetsWithIdOnly = await prisma.crypto_assets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends crypto_assetsUpdateManyAndReturnArgs>(args: SelectSubset<T, crypto_assetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crypto_assets.
     * @param {crypto_assetsUpsertArgs} args - Arguments to update or create a Crypto_assets.
     * @example
     * // Update or create a Crypto_assets
     * const crypto_assets = await prisma.crypto_assets.upsert({
     *   create: {
     *     // ... data to create a Crypto_assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crypto_assets we want to update
     *   }
     * })
     */
    upsert<T extends crypto_assetsUpsertArgs>(args: SelectSubset<T, crypto_assetsUpsertArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crypto_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_assetsCountArgs} args - Arguments to filter Crypto_assets to count.
     * @example
     * // Count the number of Crypto_assets
     * const count = await prisma.crypto_assets.count({
     *   where: {
     *     // ... the filter for the Crypto_assets we want to count
     *   }
     * })
    **/
    count<T extends crypto_assetsCountArgs>(
      args?: Subset<T, crypto_assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Crypto_assetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crypto_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Crypto_assetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Crypto_assetsAggregateArgs>(args: Subset<T, Crypto_assetsAggregateArgs>): Prisma.PrismaPromise<GetCrypto_assetsAggregateType<T>>

    /**
     * Group by Crypto_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crypto_assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crypto_assetsGroupByArgs['orderBy'] }
        : { orderBy?: crypto_assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crypto_assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrypto_assetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crypto_assets model
   */
  readonly fields: crypto_assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crypto_assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crypto_assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deposit_sessions<T extends crypto_assets$deposit_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, crypto_assets$deposit_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the crypto_assets model
   */
  interface crypto_assetsFieldRefs {
    readonly id: FieldRef<"crypto_assets", 'String'>
    readonly symbol: FieldRef<"crypto_assets", 'String'>
    readonly network: FieldRef<"crypto_assets", 'String'>
    readonly display_name: FieldRef<"crypto_assets", 'String'>
    readonly contract: FieldRef<"crypto_assets", 'String'>
    readonly decimals: FieldRef<"crypto_assets", 'Int'>
    readonly min_deposit: FieldRef<"crypto_assets", 'Decimal'>
    readonly is_active: FieldRef<"crypto_assets", 'Boolean'>
    readonly created_at: FieldRef<"crypto_assets", 'DateTime'>
    readonly updated_at: FieldRef<"crypto_assets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * crypto_assets findUnique
   */
  export type crypto_assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * Filter, which crypto_assets to fetch.
     */
    where: crypto_assetsWhereUniqueInput
  }

  /**
   * crypto_assets findUniqueOrThrow
   */
  export type crypto_assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * Filter, which crypto_assets to fetch.
     */
    where: crypto_assetsWhereUniqueInput
  }

  /**
   * crypto_assets findFirst
   */
  export type crypto_assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * Filter, which crypto_assets to fetch.
     */
    where?: crypto_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_assets to fetch.
     */
    orderBy?: crypto_assetsOrderByWithRelationInput | crypto_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crypto_assets.
     */
    cursor?: crypto_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crypto_assets.
     */
    distinct?: Crypto_assetsScalarFieldEnum | Crypto_assetsScalarFieldEnum[]
  }

  /**
   * crypto_assets findFirstOrThrow
   */
  export type crypto_assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * Filter, which crypto_assets to fetch.
     */
    where?: crypto_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_assets to fetch.
     */
    orderBy?: crypto_assetsOrderByWithRelationInput | crypto_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crypto_assets.
     */
    cursor?: crypto_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crypto_assets.
     */
    distinct?: Crypto_assetsScalarFieldEnum | Crypto_assetsScalarFieldEnum[]
  }

  /**
   * crypto_assets findMany
   */
  export type crypto_assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * Filter, which crypto_assets to fetch.
     */
    where?: crypto_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_assets to fetch.
     */
    orderBy?: crypto_assetsOrderByWithRelationInput | crypto_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crypto_assets.
     */
    cursor?: crypto_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_assets.
     */
    skip?: number
    distinct?: Crypto_assetsScalarFieldEnum | Crypto_assetsScalarFieldEnum[]
  }

  /**
   * crypto_assets create
   */
  export type crypto_assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * The data needed to create a crypto_assets.
     */
    data: XOR<crypto_assetsCreateInput, crypto_assetsUncheckedCreateInput>
  }

  /**
   * crypto_assets createMany
   */
  export type crypto_assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crypto_assets.
     */
    data: crypto_assetsCreateManyInput | crypto_assetsCreateManyInput[]
  }

  /**
   * crypto_assets createManyAndReturn
   */
  export type crypto_assetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * The data used to create many crypto_assets.
     */
    data: crypto_assetsCreateManyInput | crypto_assetsCreateManyInput[]
  }

  /**
   * crypto_assets update
   */
  export type crypto_assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * The data needed to update a crypto_assets.
     */
    data: XOR<crypto_assetsUpdateInput, crypto_assetsUncheckedUpdateInput>
    /**
     * Choose, which crypto_assets to update.
     */
    where: crypto_assetsWhereUniqueInput
  }

  /**
   * crypto_assets updateMany
   */
  export type crypto_assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crypto_assets.
     */
    data: XOR<crypto_assetsUpdateManyMutationInput, crypto_assetsUncheckedUpdateManyInput>
    /**
     * Filter which crypto_assets to update
     */
    where?: crypto_assetsWhereInput
    /**
     * Limit how many crypto_assets to update.
     */
    limit?: number
  }

  /**
   * crypto_assets updateManyAndReturn
   */
  export type crypto_assetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * The data used to update crypto_assets.
     */
    data: XOR<crypto_assetsUpdateManyMutationInput, crypto_assetsUncheckedUpdateManyInput>
    /**
     * Filter which crypto_assets to update
     */
    where?: crypto_assetsWhereInput
    /**
     * Limit how many crypto_assets to update.
     */
    limit?: number
  }

  /**
   * crypto_assets upsert
   */
  export type crypto_assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * The filter to search for the crypto_assets to update in case it exists.
     */
    where: crypto_assetsWhereUniqueInput
    /**
     * In case the crypto_assets found by the `where` argument doesn't exist, create a new crypto_assets with this data.
     */
    create: XOR<crypto_assetsCreateInput, crypto_assetsUncheckedCreateInput>
    /**
     * In case the crypto_assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crypto_assetsUpdateInput, crypto_assetsUncheckedUpdateInput>
  }

  /**
   * crypto_assets delete
   */
  export type crypto_assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
    /**
     * Filter which crypto_assets to delete.
     */
    where: crypto_assetsWhereUniqueInput
  }

  /**
   * crypto_assets deleteMany
   */
  export type crypto_assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crypto_assets to delete
     */
    where?: crypto_assetsWhereInput
    /**
     * Limit how many crypto_assets to delete.
     */
    limit?: number
  }

  /**
   * crypto_assets.deposit_sessions
   */
  export type crypto_assets$deposit_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    where?: deposit_sessionsWhereInput
    orderBy?: deposit_sessionsOrderByWithRelationInput | deposit_sessionsOrderByWithRelationInput[]
    cursor?: deposit_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Deposit_sessionsScalarFieldEnum | Deposit_sessionsScalarFieldEnum[]
  }

  /**
   * crypto_assets without action
   */
  export type crypto_assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_assets
     */
    select?: crypto_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_assets
     */
    omit?: crypto_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crypto_assetsInclude<ExtArgs> | null
  }


  /**
   * Model deposit_sessions
   */

  export type AggregateDeposit_sessions = {
    _count: Deposit_sessionsCountAggregateOutputType | null
    _avg: Deposit_sessionsAvgAggregateOutputType | null
    _sum: Deposit_sessionsSumAggregateOutputType | null
    _min: Deposit_sessionsMinAggregateOutputType | null
    _max: Deposit_sessionsMaxAggregateOutputType | null
  }

  export type Deposit_sessionsAvgAggregateOutputType = {
    amount_expected: Decimal | null
    fiat_locked_usd: Decimal | null
    detected_amount: Decimal | null
    confirmations: number | null
    min_confirmations: number | null
  }

  export type Deposit_sessionsSumAggregateOutputType = {
    amount_expected: Decimal | null
    fiat_locked_usd: Decimal | null
    detected_amount: Decimal | null
    confirmations: number | null
    min_confirmations: number | null
  }

  export type Deposit_sessionsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    crypto_asset_id: string | null
    address: string | null
    derivation_path: string | null
    memo_tag: string | null
    amount_expected: Decimal | null
    fiat_locked_usd: Decimal | null
    rate_source: string | null
    status: $Enums.DepositSessionStatus | null
    tx_hash: string | null
    detected_amount: Decimal | null
    confirmations: number | null
    min_confirmations: number | null
    is_late: boolean | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Deposit_sessionsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    crypto_asset_id: string | null
    address: string | null
    derivation_path: string | null
    memo_tag: string | null
    amount_expected: Decimal | null
    fiat_locked_usd: Decimal | null
    rate_source: string | null
    status: $Enums.DepositSessionStatus | null
    tx_hash: string | null
    detected_amount: Decimal | null
    confirmations: number | null
    min_confirmations: number | null
    is_late: boolean | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Deposit_sessionsCountAggregateOutputType = {
    id: number
    user_id: number
    crypto_asset_id: number
    address: number
    derivation_path: number
    memo_tag: number
    amount_expected: number
    fiat_locked_usd: number
    rate_source: number
    status: number
    tx_hash: number
    detected_amount: number
    confirmations: number
    min_confirmations: number
    is_late: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Deposit_sessionsAvgAggregateInputType = {
    amount_expected?: true
    fiat_locked_usd?: true
    detected_amount?: true
    confirmations?: true
    min_confirmations?: true
  }

  export type Deposit_sessionsSumAggregateInputType = {
    amount_expected?: true
    fiat_locked_usd?: true
    detected_amount?: true
    confirmations?: true
    min_confirmations?: true
  }

  export type Deposit_sessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    crypto_asset_id?: true
    address?: true
    derivation_path?: true
    memo_tag?: true
    amount_expected?: true
    fiat_locked_usd?: true
    rate_source?: true
    status?: true
    tx_hash?: true
    detected_amount?: true
    confirmations?: true
    min_confirmations?: true
    is_late?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Deposit_sessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    crypto_asset_id?: true
    address?: true
    derivation_path?: true
    memo_tag?: true
    amount_expected?: true
    fiat_locked_usd?: true
    rate_source?: true
    status?: true
    tx_hash?: true
    detected_amount?: true
    confirmations?: true
    min_confirmations?: true
    is_late?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Deposit_sessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    crypto_asset_id?: true
    address?: true
    derivation_path?: true
    memo_tag?: true
    amount_expected?: true
    fiat_locked_usd?: true
    rate_source?: true
    status?: true
    tx_hash?: true
    detected_amount?: true
    confirmations?: true
    min_confirmations?: true
    is_late?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Deposit_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deposit_sessions to aggregate.
     */
    where?: deposit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposit_sessions to fetch.
     */
    orderBy?: deposit_sessionsOrderByWithRelationInput | deposit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deposit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposit_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deposit_sessions
    **/
    _count?: true | Deposit_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Deposit_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Deposit_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Deposit_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Deposit_sessionsMaxAggregateInputType
  }

  export type GetDeposit_sessionsAggregateType<T extends Deposit_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposit_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposit_sessions[P]>
      : GetScalarType<T[P], AggregateDeposit_sessions[P]>
  }




  export type deposit_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deposit_sessionsWhereInput
    orderBy?: deposit_sessionsOrderByWithAggregationInput | deposit_sessionsOrderByWithAggregationInput[]
    by: Deposit_sessionsScalarFieldEnum[] | Deposit_sessionsScalarFieldEnum
    having?: deposit_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Deposit_sessionsCountAggregateInputType | true
    _avg?: Deposit_sessionsAvgAggregateInputType
    _sum?: Deposit_sessionsSumAggregateInputType
    _min?: Deposit_sessionsMinAggregateInputType
    _max?: Deposit_sessionsMaxAggregateInputType
  }

  export type Deposit_sessionsGroupByOutputType = {
    id: string
    user_id: string
    crypto_asset_id: string
    address: string
    derivation_path: string | null
    memo_tag: string | null
    amount_expected: Decimal | null
    fiat_locked_usd: Decimal | null
    rate_source: string | null
    status: $Enums.DepositSessionStatus
    tx_hash: string | null
    detected_amount: Decimal | null
    confirmations: number | null
    min_confirmations: number
    is_late: boolean
    expires_at: Date
    created_at: Date
    updated_at: Date
    _count: Deposit_sessionsCountAggregateOutputType | null
    _avg: Deposit_sessionsAvgAggregateOutputType | null
    _sum: Deposit_sessionsSumAggregateOutputType | null
    _min: Deposit_sessionsMinAggregateOutputType | null
    _max: Deposit_sessionsMaxAggregateOutputType | null
  }

  type GetDeposit_sessionsGroupByPayload<T extends deposit_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Deposit_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Deposit_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Deposit_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Deposit_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type deposit_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    crypto_asset_id?: boolean
    address?: boolean
    derivation_path?: boolean
    memo_tag?: boolean
    amount_expected?: boolean
    fiat_locked_usd?: boolean
    rate_source?: boolean
    status?: boolean
    tx_hash?: boolean
    detected_amount?: boolean
    confirmations?: boolean
    min_confirmations?: boolean
    is_late?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    crypto_assets?: boolean | crypto_assetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit_sessions"]>

  export type deposit_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    crypto_asset_id?: boolean
    address?: boolean
    derivation_path?: boolean
    memo_tag?: boolean
    amount_expected?: boolean
    fiat_locked_usd?: boolean
    rate_source?: boolean
    status?: boolean
    tx_hash?: boolean
    detected_amount?: boolean
    confirmations?: boolean
    min_confirmations?: boolean
    is_late?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    crypto_assets?: boolean | crypto_assetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit_sessions"]>

  export type deposit_sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    crypto_asset_id?: boolean
    address?: boolean
    derivation_path?: boolean
    memo_tag?: boolean
    amount_expected?: boolean
    fiat_locked_usd?: boolean
    rate_source?: boolean
    status?: boolean
    tx_hash?: boolean
    detected_amount?: boolean
    confirmations?: boolean
    min_confirmations?: boolean
    is_late?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    crypto_assets?: boolean | crypto_assetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit_sessions"]>

  export type deposit_sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    crypto_asset_id?: boolean
    address?: boolean
    derivation_path?: boolean
    memo_tag?: boolean
    amount_expected?: boolean
    fiat_locked_usd?: boolean
    rate_source?: boolean
    status?: boolean
    tx_hash?: boolean
    detected_amount?: boolean
    confirmations?: boolean
    min_confirmations?: boolean
    is_late?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type deposit_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "crypto_asset_id" | "address" | "derivation_path" | "memo_tag" | "amount_expected" | "fiat_locked_usd" | "rate_source" | "status" | "tx_hash" | "detected_amount" | "confirmations" | "min_confirmations" | "is_late" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["deposit_sessions"]>
  export type deposit_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    crypto_assets?: boolean | crypto_assetsDefaultArgs<ExtArgs>
  }
  export type deposit_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    crypto_assets?: boolean | crypto_assetsDefaultArgs<ExtArgs>
  }
  export type deposit_sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    crypto_assets?: boolean | crypto_assetsDefaultArgs<ExtArgs>
  }

  export type $deposit_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deposit_sessions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      crypto_assets: Prisma.$crypto_assetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      crypto_asset_id: string
      address: string
      derivation_path: string | null
      memo_tag: string | null
      amount_expected: Prisma.Decimal | null
      fiat_locked_usd: Prisma.Decimal | null
      rate_source: string | null
      status: $Enums.DepositSessionStatus
      tx_hash: string | null
      detected_amount: Prisma.Decimal | null
      confirmations: number | null
      min_confirmations: number
      is_late: boolean
      expires_at: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["deposit_sessions"]>
    composites: {}
  }

  type deposit_sessionsGetPayload<S extends boolean | null | undefined | deposit_sessionsDefaultArgs> = $Result.GetResult<Prisma.$deposit_sessionsPayload, S>

  type deposit_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deposit_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Deposit_sessionsCountAggregateInputType | true
    }

  export interface deposit_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deposit_sessions'], meta: { name: 'deposit_sessions' } }
    /**
     * Find zero or one Deposit_sessions that matches the filter.
     * @param {deposit_sessionsFindUniqueArgs} args - Arguments to find a Deposit_sessions
     * @example
     * // Get one Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deposit_sessionsFindUniqueArgs>(args: SelectSubset<T, deposit_sessionsFindUniqueArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposit_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deposit_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Deposit_sessions
     * @example
     * // Get one Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deposit_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, deposit_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deposit_sessionsFindFirstArgs} args - Arguments to find a Deposit_sessions
     * @example
     * // Get one Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deposit_sessionsFindFirstArgs>(args?: SelectSubset<T, deposit_sessionsFindFirstArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deposit_sessionsFindFirstOrThrowArgs} args - Arguments to find a Deposit_sessions
     * @example
     * // Get one Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deposit_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, deposit_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deposit_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deposit_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.findMany()
     * 
     * // Get first 10 Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deposit_sessionsWithIdOnly = await prisma.deposit_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deposit_sessionsFindManyArgs>(args?: SelectSubset<T, deposit_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposit_sessions.
     * @param {deposit_sessionsCreateArgs} args - Arguments to create a Deposit_sessions.
     * @example
     * // Create one Deposit_sessions
     * const Deposit_sessions = await prisma.deposit_sessions.create({
     *   data: {
     *     // ... data to create a Deposit_sessions
     *   }
     * })
     * 
     */
    create<T extends deposit_sessionsCreateArgs>(args: SelectSubset<T, deposit_sessionsCreateArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deposit_sessions.
     * @param {deposit_sessionsCreateManyArgs} args - Arguments to create many Deposit_sessions.
     * @example
     * // Create many Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deposit_sessionsCreateManyArgs>(args?: SelectSubset<T, deposit_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposit_sessions and returns the data saved in the database.
     * @param {deposit_sessionsCreateManyAndReturnArgs} args - Arguments to create many Deposit_sessions.
     * @example
     * // Create many Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposit_sessions and only return the `id`
     * const deposit_sessionsWithIdOnly = await prisma.deposit_sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends deposit_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, deposit_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deposit_sessions.
     * @param {deposit_sessionsDeleteArgs} args - Arguments to delete one Deposit_sessions.
     * @example
     * // Delete one Deposit_sessions
     * const Deposit_sessions = await prisma.deposit_sessions.delete({
     *   where: {
     *     // ... filter to delete one Deposit_sessions
     *   }
     * })
     * 
     */
    delete<T extends deposit_sessionsDeleteArgs>(args: SelectSubset<T, deposit_sessionsDeleteArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposit_sessions.
     * @param {deposit_sessionsUpdateArgs} args - Arguments to update one Deposit_sessions.
     * @example
     * // Update one Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deposit_sessionsUpdateArgs>(args: SelectSubset<T, deposit_sessionsUpdateArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deposit_sessions.
     * @param {deposit_sessionsDeleteManyArgs} args - Arguments to filter Deposit_sessions to delete.
     * @example
     * // Delete a few Deposit_sessions
     * const { count } = await prisma.deposit_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deposit_sessionsDeleteManyArgs>(args?: SelectSubset<T, deposit_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deposit_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deposit_sessionsUpdateManyArgs>(args: SelectSubset<T, deposit_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposit_sessions and returns the data updated in the database.
     * @param {deposit_sessionsUpdateManyAndReturnArgs} args - Arguments to update many Deposit_sessions.
     * @example
     * // Update many Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deposit_sessions and only return the `id`
     * const deposit_sessionsWithIdOnly = await prisma.deposit_sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends deposit_sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, deposit_sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deposit_sessions.
     * @param {deposit_sessionsUpsertArgs} args - Arguments to update or create a Deposit_sessions.
     * @example
     * // Update or create a Deposit_sessions
     * const deposit_sessions = await prisma.deposit_sessions.upsert({
     *   create: {
     *     // ... data to create a Deposit_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposit_sessions we want to update
     *   }
     * })
     */
    upsert<T extends deposit_sessionsUpsertArgs>(args: SelectSubset<T, deposit_sessionsUpsertArgs<ExtArgs>>): Prisma__deposit_sessionsClient<$Result.GetResult<Prisma.$deposit_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deposit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deposit_sessionsCountArgs} args - Arguments to filter Deposit_sessions to count.
     * @example
     * // Count the number of Deposit_sessions
     * const count = await prisma.deposit_sessions.count({
     *   where: {
     *     // ... the filter for the Deposit_sessions we want to count
     *   }
     * })
    **/
    count<T extends deposit_sessionsCountArgs>(
      args?: Subset<T, deposit_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Deposit_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Deposit_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Deposit_sessionsAggregateArgs>(args: Subset<T, Deposit_sessionsAggregateArgs>): Prisma.PrismaPromise<GetDeposit_sessionsAggregateType<T>>

    /**
     * Group by Deposit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deposit_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deposit_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deposit_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: deposit_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deposit_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeposit_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deposit_sessions model
   */
  readonly fields: deposit_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deposit_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deposit_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    crypto_assets<T extends crypto_assetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, crypto_assetsDefaultArgs<ExtArgs>>): Prisma__crypto_assetsClient<$Result.GetResult<Prisma.$crypto_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deposit_sessions model
   */
  interface deposit_sessionsFieldRefs {
    readonly id: FieldRef<"deposit_sessions", 'String'>
    readonly user_id: FieldRef<"deposit_sessions", 'String'>
    readonly crypto_asset_id: FieldRef<"deposit_sessions", 'String'>
    readonly address: FieldRef<"deposit_sessions", 'String'>
    readonly derivation_path: FieldRef<"deposit_sessions", 'String'>
    readonly memo_tag: FieldRef<"deposit_sessions", 'String'>
    readonly amount_expected: FieldRef<"deposit_sessions", 'Decimal'>
    readonly fiat_locked_usd: FieldRef<"deposit_sessions", 'Decimal'>
    readonly rate_source: FieldRef<"deposit_sessions", 'String'>
    readonly status: FieldRef<"deposit_sessions", 'DepositSessionStatus'>
    readonly tx_hash: FieldRef<"deposit_sessions", 'String'>
    readonly detected_amount: FieldRef<"deposit_sessions", 'Decimal'>
    readonly confirmations: FieldRef<"deposit_sessions", 'Int'>
    readonly min_confirmations: FieldRef<"deposit_sessions", 'Int'>
    readonly is_late: FieldRef<"deposit_sessions", 'Boolean'>
    readonly expires_at: FieldRef<"deposit_sessions", 'DateTime'>
    readonly created_at: FieldRef<"deposit_sessions", 'DateTime'>
    readonly updated_at: FieldRef<"deposit_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * deposit_sessions findUnique
   */
  export type deposit_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which deposit_sessions to fetch.
     */
    where: deposit_sessionsWhereUniqueInput
  }

  /**
   * deposit_sessions findUniqueOrThrow
   */
  export type deposit_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which deposit_sessions to fetch.
     */
    where: deposit_sessionsWhereUniqueInput
  }

  /**
   * deposit_sessions findFirst
   */
  export type deposit_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which deposit_sessions to fetch.
     */
    where?: deposit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposit_sessions to fetch.
     */
    orderBy?: deposit_sessionsOrderByWithRelationInput | deposit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deposit_sessions.
     */
    cursor?: deposit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposit_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deposit_sessions.
     */
    distinct?: Deposit_sessionsScalarFieldEnum | Deposit_sessionsScalarFieldEnum[]
  }

  /**
   * deposit_sessions findFirstOrThrow
   */
  export type deposit_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which deposit_sessions to fetch.
     */
    where?: deposit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposit_sessions to fetch.
     */
    orderBy?: deposit_sessionsOrderByWithRelationInput | deposit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deposit_sessions.
     */
    cursor?: deposit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposit_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deposit_sessions.
     */
    distinct?: Deposit_sessionsScalarFieldEnum | Deposit_sessionsScalarFieldEnum[]
  }

  /**
   * deposit_sessions findMany
   */
  export type deposit_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which deposit_sessions to fetch.
     */
    where?: deposit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deposit_sessions to fetch.
     */
    orderBy?: deposit_sessionsOrderByWithRelationInput | deposit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deposit_sessions.
     */
    cursor?: deposit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deposit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deposit_sessions.
     */
    skip?: number
    distinct?: Deposit_sessionsScalarFieldEnum | Deposit_sessionsScalarFieldEnum[]
  }

  /**
   * deposit_sessions create
   */
  export type deposit_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a deposit_sessions.
     */
    data: XOR<deposit_sessionsCreateInput, deposit_sessionsUncheckedCreateInput>
  }

  /**
   * deposit_sessions createMany
   */
  export type deposit_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deposit_sessions.
     */
    data: deposit_sessionsCreateManyInput | deposit_sessionsCreateManyInput[]
  }

  /**
   * deposit_sessions createManyAndReturn
   */
  export type deposit_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many deposit_sessions.
     */
    data: deposit_sessionsCreateManyInput | deposit_sessionsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * deposit_sessions update
   */
  export type deposit_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a deposit_sessions.
     */
    data: XOR<deposit_sessionsUpdateInput, deposit_sessionsUncheckedUpdateInput>
    /**
     * Choose, which deposit_sessions to update.
     */
    where: deposit_sessionsWhereUniqueInput
  }

  /**
   * deposit_sessions updateMany
   */
  export type deposit_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deposit_sessions.
     */
    data: XOR<deposit_sessionsUpdateManyMutationInput, deposit_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which deposit_sessions to update
     */
    where?: deposit_sessionsWhereInput
    /**
     * Limit how many deposit_sessions to update.
     */
    limit?: number
  }

  /**
   * deposit_sessions updateManyAndReturn
   */
  export type deposit_sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * The data used to update deposit_sessions.
     */
    data: XOR<deposit_sessionsUpdateManyMutationInput, deposit_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which deposit_sessions to update
     */
    where?: deposit_sessionsWhereInput
    /**
     * Limit how many deposit_sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * deposit_sessions upsert
   */
  export type deposit_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the deposit_sessions to update in case it exists.
     */
    where: deposit_sessionsWhereUniqueInput
    /**
     * In case the deposit_sessions found by the `where` argument doesn't exist, create a new deposit_sessions with this data.
     */
    create: XOR<deposit_sessionsCreateInput, deposit_sessionsUncheckedCreateInput>
    /**
     * In case the deposit_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deposit_sessionsUpdateInput, deposit_sessionsUncheckedUpdateInput>
  }

  /**
   * deposit_sessions delete
   */
  export type deposit_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
    /**
     * Filter which deposit_sessions to delete.
     */
    where: deposit_sessionsWhereUniqueInput
  }

  /**
   * deposit_sessions deleteMany
   */
  export type deposit_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deposit_sessions to delete
     */
    where?: deposit_sessionsWhereInput
    /**
     * Limit how many deposit_sessions to delete.
     */
    limit?: number
  }

  /**
   * deposit_sessions without action
   */
  export type deposit_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deposit_sessions
     */
    select?: deposit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deposit_sessions
     */
    omit?: deposit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deposit_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model wallet_ledger
   */

  export type AggregateWallet_ledger = {
    _count: Wallet_ledgerCountAggregateOutputType | null
    _avg: Wallet_ledgerAvgAggregateOutputType | null
    _sum: Wallet_ledgerSumAggregateOutputType | null
    _min: Wallet_ledgerMinAggregateOutputType | null
    _max: Wallet_ledgerMaxAggregateOutputType | null
  }

  export type Wallet_ledgerAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type Wallet_ledgerSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type Wallet_ledgerMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.LedgerType | null
    asset: string | null
    amount: Decimal | null
    created_at: Date | null
  }

  export type Wallet_ledgerMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.LedgerType | null
    asset: string | null
    amount: Decimal | null
    created_at: Date | null
  }

  export type Wallet_ledgerCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    asset: number
    amount: number
    meta: number
    created_at: number
    _all: number
  }


  export type Wallet_ledgerAvgAggregateInputType = {
    amount?: true
  }

  export type Wallet_ledgerSumAggregateInputType = {
    amount?: true
  }

  export type Wallet_ledgerMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    asset?: true
    amount?: true
    created_at?: true
  }

  export type Wallet_ledgerMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    asset?: true
    amount?: true
    created_at?: true
  }

  export type Wallet_ledgerCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    asset?: true
    amount?: true
    meta?: true
    created_at?: true
    _all?: true
  }

  export type Wallet_ledgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_ledger to aggregate.
     */
    where?: wallet_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_ledgers to fetch.
     */
    orderBy?: wallet_ledgerOrderByWithRelationInput | wallet_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_ledgers
    **/
    _count?: true | Wallet_ledgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_ledgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_ledgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_ledgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_ledgerMaxAggregateInputType
  }

  export type GetWallet_ledgerAggregateType<T extends Wallet_ledgerAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_ledger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_ledger[P]>
      : GetScalarType<T[P], AggregateWallet_ledger[P]>
  }




  export type wallet_ledgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_ledgerWhereInput
    orderBy?: wallet_ledgerOrderByWithAggregationInput | wallet_ledgerOrderByWithAggregationInput[]
    by: Wallet_ledgerScalarFieldEnum[] | Wallet_ledgerScalarFieldEnum
    having?: wallet_ledgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_ledgerCountAggregateInputType | true
    _avg?: Wallet_ledgerAvgAggregateInputType
    _sum?: Wallet_ledgerSumAggregateInputType
    _min?: Wallet_ledgerMinAggregateInputType
    _max?: Wallet_ledgerMaxAggregateInputType
  }

  export type Wallet_ledgerGroupByOutputType = {
    id: string
    user_id: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal
    meta: JsonValue | null
    created_at: Date
    _count: Wallet_ledgerCountAggregateOutputType | null
    _avg: Wallet_ledgerAvgAggregateOutputType | null
    _sum: Wallet_ledgerSumAggregateOutputType | null
    _min: Wallet_ledgerMinAggregateOutputType | null
    _max: Wallet_ledgerMaxAggregateOutputType | null
  }

  type GetWallet_ledgerGroupByPayload<T extends wallet_ledgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_ledgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_ledgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_ledgerGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_ledgerGroupByOutputType[P]>
        }
      >
    >


  export type wallet_ledgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    meta?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet_ledger"]>

  export type wallet_ledgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    meta?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet_ledger"]>

  export type wallet_ledgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    meta?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet_ledger"]>

  export type wallet_ledgerSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    meta?: boolean
    created_at?: boolean
  }

  export type wallet_ledgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "asset" | "amount" | "meta" | "created_at", ExtArgs["result"]["wallet_ledger"]>
  export type wallet_ledgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type wallet_ledgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type wallet_ledgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $wallet_ledgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_ledger"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      type: $Enums.LedgerType
      asset: string
      amount: Prisma.Decimal
      meta: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["wallet_ledger"]>
    composites: {}
  }

  type wallet_ledgerGetPayload<S extends boolean | null | undefined | wallet_ledgerDefaultArgs> = $Result.GetResult<Prisma.$wallet_ledgerPayload, S>

  type wallet_ledgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wallet_ledgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wallet_ledgerCountAggregateInputType | true
    }

  export interface wallet_ledgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_ledger'], meta: { name: 'wallet_ledger' } }
    /**
     * Find zero or one Wallet_ledger that matches the filter.
     * @param {wallet_ledgerFindUniqueArgs} args - Arguments to find a Wallet_ledger
     * @example
     * // Get one Wallet_ledger
     * const wallet_ledger = await prisma.wallet_ledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_ledgerFindUniqueArgs>(args: SelectSubset<T, wallet_ledgerFindUniqueArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet_ledger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wallet_ledgerFindUniqueOrThrowArgs} args - Arguments to find a Wallet_ledger
     * @example
     * // Get one Wallet_ledger
     * const wallet_ledger = await prisma.wallet_ledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_ledgerFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_ledgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_ledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_ledgerFindFirstArgs} args - Arguments to find a Wallet_ledger
     * @example
     * // Get one Wallet_ledger
     * const wallet_ledger = await prisma.wallet_ledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_ledgerFindFirstArgs>(args?: SelectSubset<T, wallet_ledgerFindFirstArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_ledger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_ledgerFindFirstOrThrowArgs} args - Arguments to find a Wallet_ledger
     * @example
     * // Get one Wallet_ledger
     * const wallet_ledger = await prisma.wallet_ledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_ledgerFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_ledgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallet_ledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_ledgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_ledgers
     * const wallet_ledgers = await prisma.wallet_ledger.findMany()
     * 
     * // Get first 10 Wallet_ledgers
     * const wallet_ledgers = await prisma.wallet_ledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_ledgerWithIdOnly = await prisma.wallet_ledger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_ledgerFindManyArgs>(args?: SelectSubset<T, wallet_ledgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet_ledger.
     * @param {wallet_ledgerCreateArgs} args - Arguments to create a Wallet_ledger.
     * @example
     * // Create one Wallet_ledger
     * const Wallet_ledger = await prisma.wallet_ledger.create({
     *   data: {
     *     // ... data to create a Wallet_ledger
     *   }
     * })
     * 
     */
    create<T extends wallet_ledgerCreateArgs>(args: SelectSubset<T, wallet_ledgerCreateArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallet_ledgers.
     * @param {wallet_ledgerCreateManyArgs} args - Arguments to create many Wallet_ledgers.
     * @example
     * // Create many Wallet_ledgers
     * const wallet_ledger = await prisma.wallet_ledger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_ledgerCreateManyArgs>(args?: SelectSubset<T, wallet_ledgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallet_ledgers and returns the data saved in the database.
     * @param {wallet_ledgerCreateManyAndReturnArgs} args - Arguments to create many Wallet_ledgers.
     * @example
     * // Create many Wallet_ledgers
     * const wallet_ledger = await prisma.wallet_ledger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallet_ledgers and only return the `id`
     * const wallet_ledgerWithIdOnly = await prisma.wallet_ledger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wallet_ledgerCreateManyAndReturnArgs>(args?: SelectSubset<T, wallet_ledgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet_ledger.
     * @param {wallet_ledgerDeleteArgs} args - Arguments to delete one Wallet_ledger.
     * @example
     * // Delete one Wallet_ledger
     * const Wallet_ledger = await prisma.wallet_ledger.delete({
     *   where: {
     *     // ... filter to delete one Wallet_ledger
     *   }
     * })
     * 
     */
    delete<T extends wallet_ledgerDeleteArgs>(args: SelectSubset<T, wallet_ledgerDeleteArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet_ledger.
     * @param {wallet_ledgerUpdateArgs} args - Arguments to update one Wallet_ledger.
     * @example
     * // Update one Wallet_ledger
     * const wallet_ledger = await prisma.wallet_ledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_ledgerUpdateArgs>(args: SelectSubset<T, wallet_ledgerUpdateArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallet_ledgers.
     * @param {wallet_ledgerDeleteManyArgs} args - Arguments to filter Wallet_ledgers to delete.
     * @example
     * // Delete a few Wallet_ledgers
     * const { count } = await prisma.wallet_ledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_ledgerDeleteManyArgs>(args?: SelectSubset<T, wallet_ledgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_ledgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_ledgers
     * const wallet_ledger = await prisma.wallet_ledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_ledgerUpdateManyArgs>(args: SelectSubset<T, wallet_ledgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_ledgers and returns the data updated in the database.
     * @param {wallet_ledgerUpdateManyAndReturnArgs} args - Arguments to update many Wallet_ledgers.
     * @example
     * // Update many Wallet_ledgers
     * const wallet_ledger = await prisma.wallet_ledger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallet_ledgers and only return the `id`
     * const wallet_ledgerWithIdOnly = await prisma.wallet_ledger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends wallet_ledgerUpdateManyAndReturnArgs>(args: SelectSubset<T, wallet_ledgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet_ledger.
     * @param {wallet_ledgerUpsertArgs} args - Arguments to update or create a Wallet_ledger.
     * @example
     * // Update or create a Wallet_ledger
     * const wallet_ledger = await prisma.wallet_ledger.upsert({
     *   create: {
     *     // ... data to create a Wallet_ledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_ledger we want to update
     *   }
     * })
     */
    upsert<T extends wallet_ledgerUpsertArgs>(args: SelectSubset<T, wallet_ledgerUpsertArgs<ExtArgs>>): Prisma__wallet_ledgerClient<$Result.GetResult<Prisma.$wallet_ledgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallet_ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_ledgerCountArgs} args - Arguments to filter Wallet_ledgers to count.
     * @example
     * // Count the number of Wallet_ledgers
     * const count = await prisma.wallet_ledger.count({
     *   where: {
     *     // ... the filter for the Wallet_ledgers we want to count
     *   }
     * })
    **/
    count<T extends wallet_ledgerCountArgs>(
      args?: Subset<T, wallet_ledgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_ledgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_ledgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_ledgerAggregateArgs>(args: Subset<T, Wallet_ledgerAggregateArgs>): Prisma.PrismaPromise<GetWallet_ledgerAggregateType<T>>

    /**
     * Group by Wallet_ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_ledgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_ledgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_ledgerGroupByArgs['orderBy'] }
        : { orderBy?: wallet_ledgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_ledgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_ledgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_ledger model
   */
  readonly fields: wallet_ledgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_ledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_ledgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_ledger model
   */
  interface wallet_ledgerFieldRefs {
    readonly id: FieldRef<"wallet_ledger", 'String'>
    readonly user_id: FieldRef<"wallet_ledger", 'String'>
    readonly type: FieldRef<"wallet_ledger", 'LedgerType'>
    readonly asset: FieldRef<"wallet_ledger", 'String'>
    readonly amount: FieldRef<"wallet_ledger", 'Decimal'>
    readonly meta: FieldRef<"wallet_ledger", 'Json'>
    readonly created_at: FieldRef<"wallet_ledger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet_ledger findUnique
   */
  export type wallet_ledgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which wallet_ledger to fetch.
     */
    where: wallet_ledgerWhereUniqueInput
  }

  /**
   * wallet_ledger findUniqueOrThrow
   */
  export type wallet_ledgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which wallet_ledger to fetch.
     */
    where: wallet_ledgerWhereUniqueInput
  }

  /**
   * wallet_ledger findFirst
   */
  export type wallet_ledgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which wallet_ledger to fetch.
     */
    where?: wallet_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_ledgers to fetch.
     */
    orderBy?: wallet_ledgerOrderByWithRelationInput | wallet_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_ledgers.
     */
    cursor?: wallet_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_ledgers.
     */
    distinct?: Wallet_ledgerScalarFieldEnum | Wallet_ledgerScalarFieldEnum[]
  }

  /**
   * wallet_ledger findFirstOrThrow
   */
  export type wallet_ledgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which wallet_ledger to fetch.
     */
    where?: wallet_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_ledgers to fetch.
     */
    orderBy?: wallet_ledgerOrderByWithRelationInput | wallet_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_ledgers.
     */
    cursor?: wallet_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_ledgers.
     */
    distinct?: Wallet_ledgerScalarFieldEnum | Wallet_ledgerScalarFieldEnum[]
  }

  /**
   * wallet_ledger findMany
   */
  export type wallet_ledgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which wallet_ledgers to fetch.
     */
    where?: wallet_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_ledgers to fetch.
     */
    orderBy?: wallet_ledgerOrderByWithRelationInput | wallet_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_ledgers.
     */
    cursor?: wallet_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_ledgers.
     */
    skip?: number
    distinct?: Wallet_ledgerScalarFieldEnum | Wallet_ledgerScalarFieldEnum[]
  }

  /**
   * wallet_ledger create
   */
  export type wallet_ledgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet_ledger.
     */
    data: XOR<wallet_ledgerCreateInput, wallet_ledgerUncheckedCreateInput>
  }

  /**
   * wallet_ledger createMany
   */
  export type wallet_ledgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_ledgers.
     */
    data: wallet_ledgerCreateManyInput | wallet_ledgerCreateManyInput[]
  }

  /**
   * wallet_ledger createManyAndReturn
   */
  export type wallet_ledgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * The data used to create many wallet_ledgers.
     */
    data: wallet_ledgerCreateManyInput | wallet_ledgerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wallet_ledger update
   */
  export type wallet_ledgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet_ledger.
     */
    data: XOR<wallet_ledgerUpdateInput, wallet_ledgerUncheckedUpdateInput>
    /**
     * Choose, which wallet_ledger to update.
     */
    where: wallet_ledgerWhereUniqueInput
  }

  /**
   * wallet_ledger updateMany
   */
  export type wallet_ledgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_ledgers.
     */
    data: XOR<wallet_ledgerUpdateManyMutationInput, wallet_ledgerUncheckedUpdateManyInput>
    /**
     * Filter which wallet_ledgers to update
     */
    where?: wallet_ledgerWhereInput
    /**
     * Limit how many wallet_ledgers to update.
     */
    limit?: number
  }

  /**
   * wallet_ledger updateManyAndReturn
   */
  export type wallet_ledgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * The data used to update wallet_ledgers.
     */
    data: XOR<wallet_ledgerUpdateManyMutationInput, wallet_ledgerUncheckedUpdateManyInput>
    /**
     * Filter which wallet_ledgers to update
     */
    where?: wallet_ledgerWhereInput
    /**
     * Limit how many wallet_ledgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * wallet_ledger upsert
   */
  export type wallet_ledgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet_ledger to update in case it exists.
     */
    where: wallet_ledgerWhereUniqueInput
    /**
     * In case the wallet_ledger found by the `where` argument doesn't exist, create a new wallet_ledger with this data.
     */
    create: XOR<wallet_ledgerCreateInput, wallet_ledgerUncheckedCreateInput>
    /**
     * In case the wallet_ledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_ledgerUpdateInput, wallet_ledgerUncheckedUpdateInput>
  }

  /**
   * wallet_ledger delete
   */
  export type wallet_ledgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
    /**
     * Filter which wallet_ledger to delete.
     */
    where: wallet_ledgerWhereUniqueInput
  }

  /**
   * wallet_ledger deleteMany
   */
  export type wallet_ledgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_ledgers to delete
     */
    where?: wallet_ledgerWhereInput
    /**
     * Limit how many wallet_ledgers to delete.
     */
    limit?: number
  }

  /**
   * wallet_ledger without action
   */
  export type wallet_ledgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_ledger
     */
    select?: wallet_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_ledger
     */
    omit?: wallet_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_ledgerInclude<ExtArgs> | null
  }


  /**
   * Model payment_method_templates
   */

  export type AggregatePayment_method_templates = {
    _count: Payment_method_templatesCountAggregateOutputType | null
    _min: Payment_method_templatesMinAggregateOutputType | null
    _max: Payment_method_templatesMaxAggregateOutputType | null
  }

  export type Payment_method_templatesMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.PaymentMethodType | null
    currency: string | null
    country: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_method_templatesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.PaymentMethodType | null
    currency: string | null
    country: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_method_templatesCountAggregateOutputType = {
    id: number
    title: number
    type: number
    fields: number
    currency: number
    country: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Payment_method_templatesMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    currency?: true
    country?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_method_templatesMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    currency?: true
    country?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_method_templatesCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    fields?: true
    currency?: true
    country?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Payment_method_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_method_templates to aggregate.
     */
    where?: payment_method_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_method_templates to fetch.
     */
    orderBy?: payment_method_templatesOrderByWithRelationInput | payment_method_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_method_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_method_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_method_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_method_templates
    **/
    _count?: true | Payment_method_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_method_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_method_templatesMaxAggregateInputType
  }

  export type GetPayment_method_templatesAggregateType<T extends Payment_method_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_method_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_method_templates[P]>
      : GetScalarType<T[P], AggregatePayment_method_templates[P]>
  }




  export type payment_method_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_method_templatesWhereInput
    orderBy?: payment_method_templatesOrderByWithAggregationInput | payment_method_templatesOrderByWithAggregationInput[]
    by: Payment_method_templatesScalarFieldEnum[] | Payment_method_templatesScalarFieldEnum
    having?: payment_method_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_method_templatesCountAggregateInputType | true
    _min?: Payment_method_templatesMinAggregateInputType
    _max?: Payment_method_templatesMaxAggregateInputType
  }

  export type Payment_method_templatesGroupByOutputType = {
    id: string
    title: string
    type: $Enums.PaymentMethodType
    fields: JsonValue
    currency: string
    country: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Payment_method_templatesCountAggregateOutputType | null
    _min: Payment_method_templatesMinAggregateOutputType | null
    _max: Payment_method_templatesMaxAggregateOutputType | null
  }

  type GetPayment_method_templatesGroupByPayload<T extends payment_method_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_method_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_method_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_method_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_method_templatesGroupByOutputType[P]>
        }
      >
    >


  export type payment_method_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    fields?: boolean
    currency?: boolean
    country?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_method_templates"]>

  export type payment_method_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    fields?: boolean
    currency?: boolean
    country?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_method_templates"]>

  export type payment_method_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    fields?: boolean
    currency?: boolean
    country?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_method_templates"]>

  export type payment_method_templatesSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    fields?: boolean
    currency?: boolean
    country?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type payment_method_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "fields" | "currency" | "country" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["payment_method_templates"]>

  export type $payment_method_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_method_templates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      type: $Enums.PaymentMethodType
      fields: Prisma.JsonValue
      currency: string
      country: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payment_method_templates"]>
    composites: {}
  }

  type payment_method_templatesGetPayload<S extends boolean | null | undefined | payment_method_templatesDefaultArgs> = $Result.GetResult<Prisma.$payment_method_templatesPayload, S>

  type payment_method_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_method_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_method_templatesCountAggregateInputType | true
    }

  export interface payment_method_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_method_templates'], meta: { name: 'payment_method_templates' } }
    /**
     * Find zero or one Payment_method_templates that matches the filter.
     * @param {payment_method_templatesFindUniqueArgs} args - Arguments to find a Payment_method_templates
     * @example
     * // Get one Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_method_templatesFindUniqueArgs>(args: SelectSubset<T, payment_method_templatesFindUniqueArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_method_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_method_templatesFindUniqueOrThrowArgs} args - Arguments to find a Payment_method_templates
     * @example
     * // Get one Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_method_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_method_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_method_templatesFindFirstArgs} args - Arguments to find a Payment_method_templates
     * @example
     * // Get one Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_method_templatesFindFirstArgs>(args?: SelectSubset<T, payment_method_templatesFindFirstArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_method_templatesFindFirstOrThrowArgs} args - Arguments to find a Payment_method_templates
     * @example
     * // Get one Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_method_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_method_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_method_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_method_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.findMany()
     * 
     * // Get first 10 Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_method_templatesWithIdOnly = await prisma.payment_method_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_method_templatesFindManyArgs>(args?: SelectSubset<T, payment_method_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_method_templates.
     * @param {payment_method_templatesCreateArgs} args - Arguments to create a Payment_method_templates.
     * @example
     * // Create one Payment_method_templates
     * const Payment_method_templates = await prisma.payment_method_templates.create({
     *   data: {
     *     // ... data to create a Payment_method_templates
     *   }
     * })
     * 
     */
    create<T extends payment_method_templatesCreateArgs>(args: SelectSubset<T, payment_method_templatesCreateArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_method_templates.
     * @param {payment_method_templatesCreateManyArgs} args - Arguments to create many Payment_method_templates.
     * @example
     * // Create many Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_method_templatesCreateManyArgs>(args?: SelectSubset<T, payment_method_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_method_templates and returns the data saved in the database.
     * @param {payment_method_templatesCreateManyAndReturnArgs} args - Arguments to create many Payment_method_templates.
     * @example
     * // Create many Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_method_templates and only return the `id`
     * const payment_method_templatesWithIdOnly = await prisma.payment_method_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_method_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_method_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_method_templates.
     * @param {payment_method_templatesDeleteArgs} args - Arguments to delete one Payment_method_templates.
     * @example
     * // Delete one Payment_method_templates
     * const Payment_method_templates = await prisma.payment_method_templates.delete({
     *   where: {
     *     // ... filter to delete one Payment_method_templates
     *   }
     * })
     * 
     */
    delete<T extends payment_method_templatesDeleteArgs>(args: SelectSubset<T, payment_method_templatesDeleteArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_method_templates.
     * @param {payment_method_templatesUpdateArgs} args - Arguments to update one Payment_method_templates.
     * @example
     * // Update one Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_method_templatesUpdateArgs>(args: SelectSubset<T, payment_method_templatesUpdateArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_method_templates.
     * @param {payment_method_templatesDeleteManyArgs} args - Arguments to filter Payment_method_templates to delete.
     * @example
     * // Delete a few Payment_method_templates
     * const { count } = await prisma.payment_method_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_method_templatesDeleteManyArgs>(args?: SelectSubset<T, payment_method_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_method_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_method_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_method_templatesUpdateManyArgs>(args: SelectSubset<T, payment_method_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_method_templates and returns the data updated in the database.
     * @param {payment_method_templatesUpdateManyAndReturnArgs} args - Arguments to update many Payment_method_templates.
     * @example
     * // Update many Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_method_templates and only return the `id`
     * const payment_method_templatesWithIdOnly = await prisma.payment_method_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_method_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_method_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_method_templates.
     * @param {payment_method_templatesUpsertArgs} args - Arguments to update or create a Payment_method_templates.
     * @example
     * // Update or create a Payment_method_templates
     * const payment_method_templates = await prisma.payment_method_templates.upsert({
     *   create: {
     *     // ... data to create a Payment_method_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_method_templates we want to update
     *   }
     * })
     */
    upsert<T extends payment_method_templatesUpsertArgs>(args: SelectSubset<T, payment_method_templatesUpsertArgs<ExtArgs>>): Prisma__payment_method_templatesClient<$Result.GetResult<Prisma.$payment_method_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_method_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_method_templatesCountArgs} args - Arguments to filter Payment_method_templates to count.
     * @example
     * // Count the number of Payment_method_templates
     * const count = await prisma.payment_method_templates.count({
     *   where: {
     *     // ... the filter for the Payment_method_templates we want to count
     *   }
     * })
    **/
    count<T extends payment_method_templatesCountArgs>(
      args?: Subset<T, payment_method_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_method_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_method_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_method_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_method_templatesAggregateArgs>(args: Subset<T, Payment_method_templatesAggregateArgs>): Prisma.PrismaPromise<GetPayment_method_templatesAggregateType<T>>

    /**
     * Group by Payment_method_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_method_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_method_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_method_templatesGroupByArgs['orderBy'] }
        : { orderBy?: payment_method_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_method_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_method_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_method_templates model
   */
  readonly fields: payment_method_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_method_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_method_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_method_templates model
   */
  interface payment_method_templatesFieldRefs {
    readonly id: FieldRef<"payment_method_templates", 'String'>
    readonly title: FieldRef<"payment_method_templates", 'String'>
    readonly type: FieldRef<"payment_method_templates", 'PaymentMethodType'>
    readonly fields: FieldRef<"payment_method_templates", 'Json'>
    readonly currency: FieldRef<"payment_method_templates", 'String'>
    readonly country: FieldRef<"payment_method_templates", 'String'>
    readonly is_active: FieldRef<"payment_method_templates", 'Boolean'>
    readonly created_at: FieldRef<"payment_method_templates", 'DateTime'>
    readonly updated_at: FieldRef<"payment_method_templates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_method_templates findUnique
   */
  export type payment_method_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * Filter, which payment_method_templates to fetch.
     */
    where: payment_method_templatesWhereUniqueInput
  }

  /**
   * payment_method_templates findUniqueOrThrow
   */
  export type payment_method_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * Filter, which payment_method_templates to fetch.
     */
    where: payment_method_templatesWhereUniqueInput
  }

  /**
   * payment_method_templates findFirst
   */
  export type payment_method_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * Filter, which payment_method_templates to fetch.
     */
    where?: payment_method_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_method_templates to fetch.
     */
    orderBy?: payment_method_templatesOrderByWithRelationInput | payment_method_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_method_templates.
     */
    cursor?: payment_method_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_method_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_method_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_method_templates.
     */
    distinct?: Payment_method_templatesScalarFieldEnum | Payment_method_templatesScalarFieldEnum[]
  }

  /**
   * payment_method_templates findFirstOrThrow
   */
  export type payment_method_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * Filter, which payment_method_templates to fetch.
     */
    where?: payment_method_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_method_templates to fetch.
     */
    orderBy?: payment_method_templatesOrderByWithRelationInput | payment_method_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_method_templates.
     */
    cursor?: payment_method_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_method_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_method_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_method_templates.
     */
    distinct?: Payment_method_templatesScalarFieldEnum | Payment_method_templatesScalarFieldEnum[]
  }

  /**
   * payment_method_templates findMany
   */
  export type payment_method_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * Filter, which payment_method_templates to fetch.
     */
    where?: payment_method_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_method_templates to fetch.
     */
    orderBy?: payment_method_templatesOrderByWithRelationInput | payment_method_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_method_templates.
     */
    cursor?: payment_method_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_method_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_method_templates.
     */
    skip?: number
    distinct?: Payment_method_templatesScalarFieldEnum | Payment_method_templatesScalarFieldEnum[]
  }

  /**
   * payment_method_templates create
   */
  export type payment_method_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * The data needed to create a payment_method_templates.
     */
    data: XOR<payment_method_templatesCreateInput, payment_method_templatesUncheckedCreateInput>
  }

  /**
   * payment_method_templates createMany
   */
  export type payment_method_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_method_templates.
     */
    data: payment_method_templatesCreateManyInput | payment_method_templatesCreateManyInput[]
  }

  /**
   * payment_method_templates createManyAndReturn
   */
  export type payment_method_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many payment_method_templates.
     */
    data: payment_method_templatesCreateManyInput | payment_method_templatesCreateManyInput[]
  }

  /**
   * payment_method_templates update
   */
  export type payment_method_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * The data needed to update a payment_method_templates.
     */
    data: XOR<payment_method_templatesUpdateInput, payment_method_templatesUncheckedUpdateInput>
    /**
     * Choose, which payment_method_templates to update.
     */
    where: payment_method_templatesWhereUniqueInput
  }

  /**
   * payment_method_templates updateMany
   */
  export type payment_method_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_method_templates.
     */
    data: XOR<payment_method_templatesUpdateManyMutationInput, payment_method_templatesUncheckedUpdateManyInput>
    /**
     * Filter which payment_method_templates to update
     */
    where?: payment_method_templatesWhereInput
    /**
     * Limit how many payment_method_templates to update.
     */
    limit?: number
  }

  /**
   * payment_method_templates updateManyAndReturn
   */
  export type payment_method_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * The data used to update payment_method_templates.
     */
    data: XOR<payment_method_templatesUpdateManyMutationInput, payment_method_templatesUncheckedUpdateManyInput>
    /**
     * Filter which payment_method_templates to update
     */
    where?: payment_method_templatesWhereInput
    /**
     * Limit how many payment_method_templates to update.
     */
    limit?: number
  }

  /**
   * payment_method_templates upsert
   */
  export type payment_method_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * The filter to search for the payment_method_templates to update in case it exists.
     */
    where: payment_method_templatesWhereUniqueInput
    /**
     * In case the payment_method_templates found by the `where` argument doesn't exist, create a new payment_method_templates with this data.
     */
    create: XOR<payment_method_templatesCreateInput, payment_method_templatesUncheckedCreateInput>
    /**
     * In case the payment_method_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_method_templatesUpdateInput, payment_method_templatesUncheckedUpdateInput>
  }

  /**
   * payment_method_templates delete
   */
  export type payment_method_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
    /**
     * Filter which payment_method_templates to delete.
     */
    where: payment_method_templatesWhereUniqueInput
  }

  /**
   * payment_method_templates deleteMany
   */
  export type payment_method_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_method_templates to delete
     */
    where?: payment_method_templatesWhereInput
    /**
     * Limit how many payment_method_templates to delete.
     */
    limit?: number
  }

  /**
   * payment_method_templates without action
   */
  export type payment_method_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method_templates
     */
    select?: payment_method_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method_templates
     */
    omit?: payment_method_templatesOmit<ExtArgs> | null
  }


  /**
   * Model p2p_offers
   */

  export type AggregateP2p_offers = {
    _count: P2p_offersCountAggregateOutputType | null
    _avg: P2p_offersAvgAggregateOutputType | null
    _sum: P2p_offersSumAggregateOutputType | null
    _min: P2p_offersMinAggregateOutputType | null
    _max: P2p_offersMaxAggregateOutputType | null
  }

  export type P2p_offersAvgAggregateOutputType = {
    fixed_price: Decimal | null
    margin_percent: Decimal | null
    min_amount_asset: Decimal | null
    max_amount_asset: Decimal | null
    min_limit_fiat: Decimal | null
    max_limit_fiat: Decimal | null
    total_trades: number | null
    completion_rate: number | null
  }

  export type P2p_offersSumAggregateOutputType = {
    fixed_price: Decimal | null
    margin_percent: Decimal | null
    min_amount_asset: Decimal | null
    max_amount_asset: Decimal | null
    min_limit_fiat: Decimal | null
    max_limit_fiat: Decimal | null
    total_trades: number | null
    completion_rate: number | null
  }

  export type P2p_offersMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    side: $Enums.P2POrderSide | null
    asset_symbol: string | null
    crypto_asset_id: string | null
    fiat_currency: string | null
    price_type: string | null
    fixed_price: Decimal | null
    margin_percent: Decimal | null
    min_amount_asset: Decimal | null
    max_amount_asset: Decimal | null
    min_limit_fiat: Decimal | null
    max_limit_fiat: Decimal | null
    terms: string | null
    auto_reply: string | null
    status: $Enums.P2POfferStatus | null
    total_trades: number | null
    completion_rate: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P2p_offersMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    side: $Enums.P2POrderSide | null
    asset_symbol: string | null
    crypto_asset_id: string | null
    fiat_currency: string | null
    price_type: string | null
    fixed_price: Decimal | null
    margin_percent: Decimal | null
    min_amount_asset: Decimal | null
    max_amount_asset: Decimal | null
    min_limit_fiat: Decimal | null
    max_limit_fiat: Decimal | null
    terms: string | null
    auto_reply: string | null
    status: $Enums.P2POfferStatus | null
    total_trades: number | null
    completion_rate: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P2p_offersCountAggregateOutputType = {
    id: number
    user_id: number
    side: number
    asset_symbol: number
    crypto_asset_id: number
    fiat_currency: number
    price_type: number
    fixed_price: number
    margin_percent: number
    min_amount_asset: number
    max_amount_asset: number
    min_limit_fiat: number
    max_limit_fiat: number
    terms: number
    auto_reply: number
    status: number
    total_trades: number
    completion_rate: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P2p_offersAvgAggregateInputType = {
    fixed_price?: true
    margin_percent?: true
    min_amount_asset?: true
    max_amount_asset?: true
    min_limit_fiat?: true
    max_limit_fiat?: true
    total_trades?: true
    completion_rate?: true
  }

  export type P2p_offersSumAggregateInputType = {
    fixed_price?: true
    margin_percent?: true
    min_amount_asset?: true
    max_amount_asset?: true
    min_limit_fiat?: true
    max_limit_fiat?: true
    total_trades?: true
    completion_rate?: true
  }

  export type P2p_offersMinAggregateInputType = {
    id?: true
    user_id?: true
    side?: true
    asset_symbol?: true
    crypto_asset_id?: true
    fiat_currency?: true
    price_type?: true
    fixed_price?: true
    margin_percent?: true
    min_amount_asset?: true
    max_amount_asset?: true
    min_limit_fiat?: true
    max_limit_fiat?: true
    terms?: true
    auto_reply?: true
    status?: true
    total_trades?: true
    completion_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type P2p_offersMaxAggregateInputType = {
    id?: true
    user_id?: true
    side?: true
    asset_symbol?: true
    crypto_asset_id?: true
    fiat_currency?: true
    price_type?: true
    fixed_price?: true
    margin_percent?: true
    min_amount_asset?: true
    max_amount_asset?: true
    min_limit_fiat?: true
    max_limit_fiat?: true
    terms?: true
    auto_reply?: true
    status?: true
    total_trades?: true
    completion_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type P2p_offersCountAggregateInputType = {
    id?: true
    user_id?: true
    side?: true
    asset_symbol?: true
    crypto_asset_id?: true
    fiat_currency?: true
    price_type?: true
    fixed_price?: true
    margin_percent?: true
    min_amount_asset?: true
    max_amount_asset?: true
    min_limit_fiat?: true
    max_limit_fiat?: true
    terms?: true
    auto_reply?: true
    status?: true
    total_trades?: true
    completion_rate?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P2p_offersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_offers to aggregate.
     */
    where?: p2p_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offers to fetch.
     */
    orderBy?: p2p_offersOrderByWithRelationInput | p2p_offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2p_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2p_offers
    **/
    _count?: true | P2p_offersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P2p_offersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P2p_offersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2p_offersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2p_offersMaxAggregateInputType
  }

  export type GetP2p_offersAggregateType<T extends P2p_offersAggregateArgs> = {
        [P in keyof T & keyof AggregateP2p_offers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2p_offers[P]>
      : GetScalarType<T[P], AggregateP2p_offers[P]>
  }




  export type p2p_offersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_offersWhereInput
    orderBy?: p2p_offersOrderByWithAggregationInput | p2p_offersOrderByWithAggregationInput[]
    by: P2p_offersScalarFieldEnum[] | P2p_offersScalarFieldEnum
    having?: p2p_offersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2p_offersCountAggregateInputType | true
    _avg?: P2p_offersAvgAggregateInputType
    _sum?: P2p_offersSumAggregateInputType
    _min?: P2p_offersMinAggregateInputType
    _max?: P2p_offersMaxAggregateInputType
  }

  export type P2p_offersGroupByOutputType = {
    id: string
    user_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id: string | null
    fiat_currency: string
    price_type: string
    fixed_price: Decimal | null
    margin_percent: Decimal | null
    min_amount_asset: Decimal
    max_amount_asset: Decimal
    min_limit_fiat: Decimal
    max_limit_fiat: Decimal
    terms: string | null
    auto_reply: string | null
    status: $Enums.P2POfferStatus
    total_trades: number
    completion_rate: number
    created_at: Date
    updated_at: Date
    _count: P2p_offersCountAggregateOutputType | null
    _avg: P2p_offersAvgAggregateOutputType | null
    _sum: P2p_offersSumAggregateOutputType | null
    _min: P2p_offersMinAggregateOutputType | null
    _max: P2p_offersMaxAggregateOutputType | null
  }

  type GetP2p_offersGroupByPayload<T extends p2p_offersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2p_offersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2p_offersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2p_offersGroupByOutputType[P]>
            : GetScalarType<T[P], P2p_offersGroupByOutputType[P]>
        }
      >
    >


  export type p2p_offersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    crypto_asset_id?: boolean
    fiat_currency?: boolean
    price_type?: boolean
    fixed_price?: boolean
    margin_percent?: boolean
    min_amount_asset?: boolean
    max_amount_asset?: boolean
    min_limit_fiat?: boolean
    max_limit_fiat?: boolean
    terms?: boolean
    auto_reply?: boolean
    status?: boolean
    total_trades?: boolean
    completion_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    payment_methods?: boolean | p2p_offers$payment_methodsArgs<ExtArgs>
    orders?: boolean | p2p_offers$ordersArgs<ExtArgs>
    _count?: boolean | P2p_offersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_offers"]>

  export type p2p_offersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    crypto_asset_id?: boolean
    fiat_currency?: boolean
    price_type?: boolean
    fixed_price?: boolean
    margin_percent?: boolean
    min_amount_asset?: boolean
    max_amount_asset?: boolean
    min_limit_fiat?: boolean
    max_limit_fiat?: boolean
    terms?: boolean
    auto_reply?: boolean
    status?: boolean
    total_trades?: boolean
    completion_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_offers"]>

  export type p2p_offersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    crypto_asset_id?: boolean
    fiat_currency?: boolean
    price_type?: boolean
    fixed_price?: boolean
    margin_percent?: boolean
    min_amount_asset?: boolean
    max_amount_asset?: boolean
    min_limit_fiat?: boolean
    max_limit_fiat?: boolean
    terms?: boolean
    auto_reply?: boolean
    status?: boolean
    total_trades?: boolean
    completion_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_offers"]>

  export type p2p_offersSelectScalar = {
    id?: boolean
    user_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    crypto_asset_id?: boolean
    fiat_currency?: boolean
    price_type?: boolean
    fixed_price?: boolean
    margin_percent?: boolean
    min_amount_asset?: boolean
    max_amount_asset?: boolean
    min_limit_fiat?: boolean
    max_limit_fiat?: boolean
    terms?: boolean
    auto_reply?: boolean
    status?: boolean
    total_trades?: boolean
    completion_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type p2p_offersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "side" | "asset_symbol" | "crypto_asset_id" | "fiat_currency" | "price_type" | "fixed_price" | "margin_percent" | "min_amount_asset" | "max_amount_asset" | "min_limit_fiat" | "max_limit_fiat" | "terms" | "auto_reply" | "status" | "total_trades" | "completion_rate" | "created_at" | "updated_at", ExtArgs["result"]["p2p_offers"]>
  export type p2p_offersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    payment_methods?: boolean | p2p_offers$payment_methodsArgs<ExtArgs>
    orders?: boolean | p2p_offers$ordersArgs<ExtArgs>
    _count?: boolean | P2p_offersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type p2p_offersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_offersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $p2p_offersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2p_offers"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      payment_methods: Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>[]
      orders: Prisma.$p2p_ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      side: $Enums.P2POrderSide
      asset_symbol: string
      crypto_asset_id: string | null
      fiat_currency: string
      price_type: string
      fixed_price: Prisma.Decimal | null
      margin_percent: Prisma.Decimal | null
      min_amount_asset: Prisma.Decimal
      max_amount_asset: Prisma.Decimal
      min_limit_fiat: Prisma.Decimal
      max_limit_fiat: Prisma.Decimal
      terms: string | null
      auto_reply: string | null
      status: $Enums.P2POfferStatus
      total_trades: number
      completion_rate: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["p2p_offers"]>
    composites: {}
  }

  type p2p_offersGetPayload<S extends boolean | null | undefined | p2p_offersDefaultArgs> = $Result.GetResult<Prisma.$p2p_offersPayload, S>

  type p2p_offersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2p_offersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2p_offersCountAggregateInputType | true
    }

  export interface p2p_offersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2p_offers'], meta: { name: 'p2p_offers' } }
    /**
     * Find zero or one P2p_offers that matches the filter.
     * @param {p2p_offersFindUniqueArgs} args - Arguments to find a P2p_offers
     * @example
     * // Get one P2p_offers
     * const p2p_offers = await prisma.p2p_offers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2p_offersFindUniqueArgs>(args: SelectSubset<T, p2p_offersFindUniqueArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2p_offers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2p_offersFindUniqueOrThrowArgs} args - Arguments to find a P2p_offers
     * @example
     * // Get one P2p_offers
     * const p2p_offers = await prisma.p2p_offers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2p_offersFindUniqueOrThrowArgs>(args: SelectSubset<T, p2p_offersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offersFindFirstArgs} args - Arguments to find a P2p_offers
     * @example
     * // Get one P2p_offers
     * const p2p_offers = await prisma.p2p_offers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2p_offersFindFirstArgs>(args?: SelectSubset<T, p2p_offersFindFirstArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_offers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offersFindFirstOrThrowArgs} args - Arguments to find a P2p_offers
     * @example
     * // Get one P2p_offers
     * const p2p_offers = await prisma.p2p_offers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2p_offersFindFirstOrThrowArgs>(args?: SelectSubset<T, p2p_offersFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2p_offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2p_offers
     * const p2p_offers = await prisma.p2p_offers.findMany()
     * 
     * // Get first 10 P2p_offers
     * const p2p_offers = await prisma.p2p_offers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2p_offersWithIdOnly = await prisma.p2p_offers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2p_offersFindManyArgs>(args?: SelectSubset<T, p2p_offersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2p_offers.
     * @param {p2p_offersCreateArgs} args - Arguments to create a P2p_offers.
     * @example
     * // Create one P2p_offers
     * const P2p_offers = await prisma.p2p_offers.create({
     *   data: {
     *     // ... data to create a P2p_offers
     *   }
     * })
     * 
     */
    create<T extends p2p_offersCreateArgs>(args: SelectSubset<T, p2p_offersCreateArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2p_offers.
     * @param {p2p_offersCreateManyArgs} args - Arguments to create many P2p_offers.
     * @example
     * // Create many P2p_offers
     * const p2p_offers = await prisma.p2p_offers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2p_offersCreateManyArgs>(args?: SelectSubset<T, p2p_offersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2p_offers and returns the data saved in the database.
     * @param {p2p_offersCreateManyAndReturnArgs} args - Arguments to create many P2p_offers.
     * @example
     * // Create many P2p_offers
     * const p2p_offers = await prisma.p2p_offers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2p_offers and only return the `id`
     * const p2p_offersWithIdOnly = await prisma.p2p_offers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2p_offersCreateManyAndReturnArgs>(args?: SelectSubset<T, p2p_offersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2p_offers.
     * @param {p2p_offersDeleteArgs} args - Arguments to delete one P2p_offers.
     * @example
     * // Delete one P2p_offers
     * const P2p_offers = await prisma.p2p_offers.delete({
     *   where: {
     *     // ... filter to delete one P2p_offers
     *   }
     * })
     * 
     */
    delete<T extends p2p_offersDeleteArgs>(args: SelectSubset<T, p2p_offersDeleteArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2p_offers.
     * @param {p2p_offersUpdateArgs} args - Arguments to update one P2p_offers.
     * @example
     * // Update one P2p_offers
     * const p2p_offers = await prisma.p2p_offers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2p_offersUpdateArgs>(args: SelectSubset<T, p2p_offersUpdateArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2p_offers.
     * @param {p2p_offersDeleteManyArgs} args - Arguments to filter P2p_offers to delete.
     * @example
     * // Delete a few P2p_offers
     * const { count } = await prisma.p2p_offers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2p_offersDeleteManyArgs>(args?: SelectSubset<T, p2p_offersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2p_offers
     * const p2p_offers = await prisma.p2p_offers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2p_offersUpdateManyArgs>(args: SelectSubset<T, p2p_offersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_offers and returns the data updated in the database.
     * @param {p2p_offersUpdateManyAndReturnArgs} args - Arguments to update many P2p_offers.
     * @example
     * // Update many P2p_offers
     * const p2p_offers = await prisma.p2p_offers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2p_offers and only return the `id`
     * const p2p_offersWithIdOnly = await prisma.p2p_offers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2p_offersUpdateManyAndReturnArgs>(args: SelectSubset<T, p2p_offersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2p_offers.
     * @param {p2p_offersUpsertArgs} args - Arguments to update or create a P2p_offers.
     * @example
     * // Update or create a P2p_offers
     * const p2p_offers = await prisma.p2p_offers.upsert({
     *   create: {
     *     // ... data to create a P2p_offers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2p_offers we want to update
     *   }
     * })
     */
    upsert<T extends p2p_offersUpsertArgs>(args: SelectSubset<T, p2p_offersUpsertArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2p_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offersCountArgs} args - Arguments to filter P2p_offers to count.
     * @example
     * // Count the number of P2p_offers
     * const count = await prisma.p2p_offers.count({
     *   where: {
     *     // ... the filter for the P2p_offers we want to count
     *   }
     * })
    **/
    count<T extends p2p_offersCountArgs>(
      args?: Subset<T, p2p_offersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2p_offersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2p_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2p_offersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2p_offersAggregateArgs>(args: Subset<T, P2p_offersAggregateArgs>): Prisma.PrismaPromise<GetP2p_offersAggregateType<T>>

    /**
     * Group by P2p_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2p_offersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2p_offersGroupByArgs['orderBy'] }
        : { orderBy?: p2p_offersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2p_offersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2p_offersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2p_offers model
   */
  readonly fields: p2p_offersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2p_offers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2p_offersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment_methods<T extends p2p_offers$payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, p2p_offers$payment_methodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends p2p_offers$ordersArgs<ExtArgs> = {}>(args?: Subset<T, p2p_offers$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2p_offers model
   */
  interface p2p_offersFieldRefs {
    readonly id: FieldRef<"p2p_offers", 'String'>
    readonly user_id: FieldRef<"p2p_offers", 'String'>
    readonly side: FieldRef<"p2p_offers", 'P2POrderSide'>
    readonly asset_symbol: FieldRef<"p2p_offers", 'String'>
    readonly crypto_asset_id: FieldRef<"p2p_offers", 'String'>
    readonly fiat_currency: FieldRef<"p2p_offers", 'String'>
    readonly price_type: FieldRef<"p2p_offers", 'String'>
    readonly fixed_price: FieldRef<"p2p_offers", 'Decimal'>
    readonly margin_percent: FieldRef<"p2p_offers", 'Decimal'>
    readonly min_amount_asset: FieldRef<"p2p_offers", 'Decimal'>
    readonly max_amount_asset: FieldRef<"p2p_offers", 'Decimal'>
    readonly min_limit_fiat: FieldRef<"p2p_offers", 'Decimal'>
    readonly max_limit_fiat: FieldRef<"p2p_offers", 'Decimal'>
    readonly terms: FieldRef<"p2p_offers", 'String'>
    readonly auto_reply: FieldRef<"p2p_offers", 'String'>
    readonly status: FieldRef<"p2p_offers", 'P2POfferStatus'>
    readonly total_trades: FieldRef<"p2p_offers", 'Int'>
    readonly completion_rate: FieldRef<"p2p_offers", 'Int'>
    readonly created_at: FieldRef<"p2p_offers", 'DateTime'>
    readonly updated_at: FieldRef<"p2p_offers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * p2p_offers findUnique
   */
  export type p2p_offersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offers to fetch.
     */
    where: p2p_offersWhereUniqueInput
  }

  /**
   * p2p_offers findUniqueOrThrow
   */
  export type p2p_offersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offers to fetch.
     */
    where: p2p_offersWhereUniqueInput
  }

  /**
   * p2p_offers findFirst
   */
  export type p2p_offersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offers to fetch.
     */
    where?: p2p_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offers to fetch.
     */
    orderBy?: p2p_offersOrderByWithRelationInput | p2p_offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_offers.
     */
    cursor?: p2p_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_offers.
     */
    distinct?: P2p_offersScalarFieldEnum | P2p_offersScalarFieldEnum[]
  }

  /**
   * p2p_offers findFirstOrThrow
   */
  export type p2p_offersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offers to fetch.
     */
    where?: p2p_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offers to fetch.
     */
    orderBy?: p2p_offersOrderByWithRelationInput | p2p_offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_offers.
     */
    cursor?: p2p_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_offers.
     */
    distinct?: P2p_offersScalarFieldEnum | P2p_offersScalarFieldEnum[]
  }

  /**
   * p2p_offers findMany
   */
  export type p2p_offersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offers to fetch.
     */
    where?: p2p_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offers to fetch.
     */
    orderBy?: p2p_offersOrderByWithRelationInput | p2p_offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2p_offers.
     */
    cursor?: p2p_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offers.
     */
    skip?: number
    distinct?: P2p_offersScalarFieldEnum | P2p_offersScalarFieldEnum[]
  }

  /**
   * p2p_offers create
   */
  export type p2p_offersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * The data needed to create a p2p_offers.
     */
    data: XOR<p2p_offersCreateInput, p2p_offersUncheckedCreateInput>
  }

  /**
   * p2p_offers createMany
   */
  export type p2p_offersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2p_offers.
     */
    data: p2p_offersCreateManyInput | p2p_offersCreateManyInput[]
  }

  /**
   * p2p_offers createManyAndReturn
   */
  export type p2p_offersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * The data used to create many p2p_offers.
     */
    data: p2p_offersCreateManyInput | p2p_offersCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_offers update
   */
  export type p2p_offersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * The data needed to update a p2p_offers.
     */
    data: XOR<p2p_offersUpdateInput, p2p_offersUncheckedUpdateInput>
    /**
     * Choose, which p2p_offers to update.
     */
    where: p2p_offersWhereUniqueInput
  }

  /**
   * p2p_offers updateMany
   */
  export type p2p_offersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2p_offers.
     */
    data: XOR<p2p_offersUpdateManyMutationInput, p2p_offersUncheckedUpdateManyInput>
    /**
     * Filter which p2p_offers to update
     */
    where?: p2p_offersWhereInput
    /**
     * Limit how many p2p_offers to update.
     */
    limit?: number
  }

  /**
   * p2p_offers updateManyAndReturn
   */
  export type p2p_offersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * The data used to update p2p_offers.
     */
    data: XOR<p2p_offersUpdateManyMutationInput, p2p_offersUncheckedUpdateManyInput>
    /**
     * Filter which p2p_offers to update
     */
    where?: p2p_offersWhereInput
    /**
     * Limit how many p2p_offers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_offers upsert
   */
  export type p2p_offersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * The filter to search for the p2p_offers to update in case it exists.
     */
    where: p2p_offersWhereUniqueInput
    /**
     * In case the p2p_offers found by the `where` argument doesn't exist, create a new p2p_offers with this data.
     */
    create: XOR<p2p_offersCreateInput, p2p_offersUncheckedCreateInput>
    /**
     * In case the p2p_offers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2p_offersUpdateInput, p2p_offersUncheckedUpdateInput>
  }

  /**
   * p2p_offers delete
   */
  export type p2p_offersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
    /**
     * Filter which p2p_offers to delete.
     */
    where: p2p_offersWhereUniqueInput
  }

  /**
   * p2p_offers deleteMany
   */
  export type p2p_offersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_offers to delete
     */
    where?: p2p_offersWhereInput
    /**
     * Limit how many p2p_offers to delete.
     */
    limit?: number
  }

  /**
   * p2p_offers.payment_methods
   */
  export type p2p_offers$payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    where?: p2p_offer_payment_methodsWhereInput
    orderBy?: p2p_offer_payment_methodsOrderByWithRelationInput | p2p_offer_payment_methodsOrderByWithRelationInput[]
    cursor?: p2p_offer_payment_methodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_offer_payment_methodsScalarFieldEnum | P2p_offer_payment_methodsScalarFieldEnum[]
  }

  /**
   * p2p_offers.orders
   */
  export type p2p_offers$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    where?: p2p_ordersWhereInput
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    cursor?: p2p_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_ordersScalarFieldEnum | P2p_ordersScalarFieldEnum[]
  }

  /**
   * p2p_offers without action
   */
  export type p2p_offersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offers
     */
    select?: p2p_offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offers
     */
    omit?: p2p_offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offersInclude<ExtArgs> | null
  }


  /**
   * Model user_payment_methods
   */

  export type AggregateUser_payment_methods = {
    _count: User_payment_methodsCountAggregateOutputType | null
    _min: User_payment_methodsMinAggregateOutputType | null
    _max: User_payment_methodsMaxAggregateOutputType | null
  }

  export type User_payment_methodsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.PaymentMethodType | null
    label: string | null
    is_verified: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_payment_methodsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.PaymentMethodType | null
    label: string | null
    is_verified: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_payment_methodsCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    label: number
    details: number
    is_verified: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_payment_methodsMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    label?: true
    is_verified?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type User_payment_methodsMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    label?: true
    is_verified?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type User_payment_methodsCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    label?: true
    details?: true
    is_verified?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_payment_methods to aggregate.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_payment_methods
    **/
    _count?: true | User_payment_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_payment_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_payment_methodsMaxAggregateInputType
  }

  export type GetUser_payment_methodsAggregateType<T extends User_payment_methodsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_payment_methods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_payment_methods[P]>
      : GetScalarType<T[P], AggregateUser_payment_methods[P]>
  }




  export type user_payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_payment_methodsWhereInput
    orderBy?: user_payment_methodsOrderByWithAggregationInput | user_payment_methodsOrderByWithAggregationInput[]
    by: User_payment_methodsScalarFieldEnum[] | User_payment_methodsScalarFieldEnum
    having?: user_payment_methodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_payment_methodsCountAggregateInputType | true
    _min?: User_payment_methodsMinAggregateInputType
    _max?: User_payment_methodsMaxAggregateInputType
  }

  export type User_payment_methodsGroupByOutputType = {
    id: string
    user_id: string
    type: $Enums.PaymentMethodType
    label: string | null
    details: JsonValue | null
    is_verified: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: User_payment_methodsCountAggregateOutputType | null
    _min: User_payment_methodsMinAggregateOutputType | null
    _max: User_payment_methodsMaxAggregateOutputType | null
  }

  type GetUser_payment_methodsGroupByPayload<T extends user_payment_methodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_payment_methodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_payment_methodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_payment_methodsGroupByOutputType[P]>
            : GetScalarType<T[P], User_payment_methodsGroupByOutputType[P]>
        }
      >
    >


  export type user_payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    label?: boolean
    details?: boolean
    is_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    offers?: boolean | user_payment_methods$offersArgs<ExtArgs>
    _count?: boolean | User_payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    label?: boolean
    details?: boolean
    is_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    label?: boolean
    details?: boolean
    is_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    label?: boolean
    details?: boolean
    is_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type user_payment_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "label" | "details" | "is_verified" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["user_payment_methods"]>
  export type user_payment_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    offers?: boolean | user_payment_methods$offersArgs<ExtArgs>
    _count?: boolean | User_payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type user_payment_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_payment_methodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_payment_methods"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      offers: Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      type: $Enums.PaymentMethodType
      label: string | null
      details: Prisma.JsonValue | null
      is_verified: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user_payment_methods"]>
    composites: {}
  }

  type user_payment_methodsGetPayload<S extends boolean | null | undefined | user_payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$user_payment_methodsPayload, S>

  type user_payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_payment_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_payment_methodsCountAggregateInputType | true
    }

  export interface user_payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_payment_methods'], meta: { name: 'user_payment_methods' } }
    /**
     * Find zero or one User_payment_methods that matches the filter.
     * @param {user_payment_methodsFindUniqueArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_payment_methodsFindUniqueArgs>(args: SelectSubset<T, user_payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_payment_methods that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindFirstArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_payment_methodsFindFirstArgs>(args?: SelectSubset<T, user_payment_methodsFindFirstArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_payment_methods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindFirstOrThrowArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findMany()
     * 
     * // Get first 10 User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_payment_methodsFindManyArgs>(args?: SelectSubset<T, user_payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_payment_methods.
     * @param {user_payment_methodsCreateArgs} args - Arguments to create a User_payment_methods.
     * @example
     * // Create one User_payment_methods
     * const User_payment_methods = await prisma.user_payment_methods.create({
     *   data: {
     *     // ... data to create a User_payment_methods
     *   }
     * })
     * 
     */
    create<T extends user_payment_methodsCreateArgs>(args: SelectSubset<T, user_payment_methodsCreateArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_payment_methods.
     * @param {user_payment_methodsCreateManyArgs} args - Arguments to create many User_payment_methods.
     * @example
     * // Create many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_payment_methodsCreateManyArgs>(args?: SelectSubset<T, user_payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_payment_methods and returns the data saved in the database.
     * @param {user_payment_methodsCreateManyAndReturnArgs} args - Arguments to create many User_payment_methods.
     * @example
     * // Create many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_payment_methods and only return the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_payment_methods.
     * @param {user_payment_methodsDeleteArgs} args - Arguments to delete one User_payment_methods.
     * @example
     * // Delete one User_payment_methods
     * const User_payment_methods = await prisma.user_payment_methods.delete({
     *   where: {
     *     // ... filter to delete one User_payment_methods
     *   }
     * })
     * 
     */
    delete<T extends user_payment_methodsDeleteArgs>(args: SelectSubset<T, user_payment_methodsDeleteArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_payment_methods.
     * @param {user_payment_methodsUpdateArgs} args - Arguments to update one User_payment_methods.
     * @example
     * // Update one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_payment_methodsUpdateArgs>(args: SelectSubset<T, user_payment_methodsUpdateArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_payment_methods.
     * @param {user_payment_methodsDeleteManyArgs} args - Arguments to filter User_payment_methods to delete.
     * @example
     * // Delete a few User_payment_methods
     * const { count } = await prisma.user_payment_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_payment_methodsDeleteManyArgs>(args?: SelectSubset<T, user_payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_payment_methodsUpdateManyArgs>(args: SelectSubset<T, user_payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_payment_methods and returns the data updated in the database.
     * @param {user_payment_methodsUpdateManyAndReturnArgs} args - Arguments to update many User_payment_methods.
     * @example
     * // Update many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_payment_methods and only return the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_payment_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_payment_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_payment_methods.
     * @param {user_payment_methodsUpsertArgs} args - Arguments to update or create a User_payment_methods.
     * @example
     * // Update or create a User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.upsert({
     *   create: {
     *     // ... data to create a User_payment_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_payment_methods we want to update
     *   }
     * })
     */
    upsert<T extends user_payment_methodsUpsertArgs>(args: SelectSubset<T, user_payment_methodsUpsertArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsCountArgs} args - Arguments to filter User_payment_methods to count.
     * @example
     * // Count the number of User_payment_methods
     * const count = await prisma.user_payment_methods.count({
     *   where: {
     *     // ... the filter for the User_payment_methods we want to count
     *   }
     * })
    **/
    count<T extends user_payment_methodsCountArgs>(
      args?: Subset<T, user_payment_methodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_payment_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_payment_methodsAggregateArgs>(args: Subset<T, User_payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetUser_payment_methodsAggregateType<T>>

    /**
     * Group by User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_payment_methodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_payment_methodsGroupByArgs['orderBy'] }
        : { orderBy?: user_payment_methodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_payment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_payment_methods model
   */
  readonly fields: user_payment_methodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_payment_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offers<T extends user_payment_methods$offersArgs<ExtArgs> = {}>(args?: Subset<T, user_payment_methods$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_payment_methods model
   */
  interface user_payment_methodsFieldRefs {
    readonly id: FieldRef<"user_payment_methods", 'String'>
    readonly user_id: FieldRef<"user_payment_methods", 'String'>
    readonly type: FieldRef<"user_payment_methods", 'PaymentMethodType'>
    readonly label: FieldRef<"user_payment_methods", 'String'>
    readonly details: FieldRef<"user_payment_methods", 'Json'>
    readonly is_verified: FieldRef<"user_payment_methods", 'Boolean'>
    readonly is_active: FieldRef<"user_payment_methods", 'Boolean'>
    readonly created_at: FieldRef<"user_payment_methods", 'DateTime'>
    readonly updated_at: FieldRef<"user_payment_methods", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_payment_methods findUnique
   */
  export type user_payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods findUniqueOrThrow
   */
  export type user_payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods findFirst
   */
  export type user_payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_payment_methods.
     */
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods findFirstOrThrow
   */
  export type user_payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_payment_methods.
     */
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods findMany
   */
  export type user_payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods create
   */
  export type user_payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_payment_methods.
     */
    data: XOR<user_payment_methodsCreateInput, user_payment_methodsUncheckedCreateInput>
  }

  /**
   * user_payment_methods createMany
   */
  export type user_payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_payment_methods.
     */
    data: user_payment_methodsCreateManyInput | user_payment_methodsCreateManyInput[]
  }

  /**
   * user_payment_methods createManyAndReturn
   */
  export type user_payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to create many user_payment_methods.
     */
    data: user_payment_methodsCreateManyInput | user_payment_methodsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_payment_methods update
   */
  export type user_payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateInput, user_payment_methodsUncheckedUpdateInput>
    /**
     * Choose, which user_payment_methods to update.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods updateMany
   */
  export type user_payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which user_payment_methods to update
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to update.
     */
    limit?: number
  }

  /**
   * user_payment_methods updateManyAndReturn
   */
  export type user_payment_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to update user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which user_payment_methods to update
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_payment_methods upsert
   */
  export type user_payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_payment_methods to update in case it exists.
     */
    where: user_payment_methodsWhereUniqueInput
    /**
     * In case the user_payment_methods found by the `where` argument doesn't exist, create a new user_payment_methods with this data.
     */
    create: XOR<user_payment_methodsCreateInput, user_payment_methodsUncheckedCreateInput>
    /**
     * In case the user_payment_methods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_payment_methodsUpdateInput, user_payment_methodsUncheckedUpdateInput>
  }

  /**
   * user_payment_methods delete
   */
  export type user_payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter which user_payment_methods to delete.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods deleteMany
   */
  export type user_payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_payment_methods to delete
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to delete.
     */
    limit?: number
  }

  /**
   * user_payment_methods.offers
   */
  export type user_payment_methods$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    where?: p2p_offer_payment_methodsWhereInput
    orderBy?: p2p_offer_payment_methodsOrderByWithRelationInput | p2p_offer_payment_methodsOrderByWithRelationInput[]
    cursor?: p2p_offer_payment_methodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_offer_payment_methodsScalarFieldEnum | P2p_offer_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods without action
   */
  export type user_payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
  }


  /**
   * Model p2p_offer_payment_methods
   */

  export type AggregateP2p_offer_payment_methods = {
    _count: P2p_offer_payment_methodsCountAggregateOutputType | null
    _min: P2p_offer_payment_methodsMinAggregateOutputType | null
    _max: P2p_offer_payment_methodsMaxAggregateOutputType | null
  }

  export type P2p_offer_payment_methodsMinAggregateOutputType = {
    id: string | null
    offer_id: string | null
    payment_method_id: string | null
  }

  export type P2p_offer_payment_methodsMaxAggregateOutputType = {
    id: string | null
    offer_id: string | null
    payment_method_id: string | null
  }

  export type P2p_offer_payment_methodsCountAggregateOutputType = {
    id: number
    offer_id: number
    payment_method_id: number
    _all: number
  }


  export type P2p_offer_payment_methodsMinAggregateInputType = {
    id?: true
    offer_id?: true
    payment_method_id?: true
  }

  export type P2p_offer_payment_methodsMaxAggregateInputType = {
    id?: true
    offer_id?: true
    payment_method_id?: true
  }

  export type P2p_offer_payment_methodsCountAggregateInputType = {
    id?: true
    offer_id?: true
    payment_method_id?: true
    _all?: true
  }

  export type P2p_offer_payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_offer_payment_methods to aggregate.
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offer_payment_methods to fetch.
     */
    orderBy?: p2p_offer_payment_methodsOrderByWithRelationInput | p2p_offer_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2p_offer_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offer_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offer_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2p_offer_payment_methods
    **/
    _count?: true | P2p_offer_payment_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2p_offer_payment_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2p_offer_payment_methodsMaxAggregateInputType
  }

  export type GetP2p_offer_payment_methodsAggregateType<T extends P2p_offer_payment_methodsAggregateArgs> = {
        [P in keyof T & keyof AggregateP2p_offer_payment_methods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2p_offer_payment_methods[P]>
      : GetScalarType<T[P], AggregateP2p_offer_payment_methods[P]>
  }




  export type p2p_offer_payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_offer_payment_methodsWhereInput
    orderBy?: p2p_offer_payment_methodsOrderByWithAggregationInput | p2p_offer_payment_methodsOrderByWithAggregationInput[]
    by: P2p_offer_payment_methodsScalarFieldEnum[] | P2p_offer_payment_methodsScalarFieldEnum
    having?: p2p_offer_payment_methodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2p_offer_payment_methodsCountAggregateInputType | true
    _min?: P2p_offer_payment_methodsMinAggregateInputType
    _max?: P2p_offer_payment_methodsMaxAggregateInputType
  }

  export type P2p_offer_payment_methodsGroupByOutputType = {
    id: string
    offer_id: string
    payment_method_id: string
    _count: P2p_offer_payment_methodsCountAggregateOutputType | null
    _min: P2p_offer_payment_methodsMinAggregateOutputType | null
    _max: P2p_offer_payment_methodsMaxAggregateOutputType | null
  }

  type GetP2p_offer_payment_methodsGroupByPayload<T extends p2p_offer_payment_methodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2p_offer_payment_methodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2p_offer_payment_methodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2p_offer_payment_methodsGroupByOutputType[P]>
            : GetScalarType<T[P], P2p_offer_payment_methodsGroupByOutputType[P]>
        }
      >
    >


  export type p2p_offer_payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    payment_method_id?: boolean
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    payment_method?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_offer_payment_methods"]>

  export type p2p_offer_payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    payment_method_id?: boolean
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    payment_method?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_offer_payment_methods"]>

  export type p2p_offer_payment_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    payment_method_id?: boolean
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    payment_method?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_offer_payment_methods"]>

  export type p2p_offer_payment_methodsSelectScalar = {
    id?: boolean
    offer_id?: boolean
    payment_method_id?: boolean
  }

  export type p2p_offer_payment_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offer_id" | "payment_method_id", ExtArgs["result"]["p2p_offer_payment_methods"]>
  export type p2p_offer_payment_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    payment_method?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }
  export type p2p_offer_payment_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    payment_method?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }
  export type p2p_offer_payment_methodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    payment_method?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }

  export type $p2p_offer_payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2p_offer_payment_methods"
    objects: {
      offer: Prisma.$p2p_offersPayload<ExtArgs>
      payment_method: Prisma.$user_payment_methodsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offer_id: string
      payment_method_id: string
    }, ExtArgs["result"]["p2p_offer_payment_methods"]>
    composites: {}
  }

  type p2p_offer_payment_methodsGetPayload<S extends boolean | null | undefined | p2p_offer_payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload, S>

  type p2p_offer_payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2p_offer_payment_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2p_offer_payment_methodsCountAggregateInputType | true
    }

  export interface p2p_offer_payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2p_offer_payment_methods'], meta: { name: 'p2p_offer_payment_methods' } }
    /**
     * Find zero or one P2p_offer_payment_methods that matches the filter.
     * @param {p2p_offer_payment_methodsFindUniqueArgs} args - Arguments to find a P2p_offer_payment_methods
     * @example
     * // Get one P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2p_offer_payment_methodsFindUniqueArgs>(args: SelectSubset<T, p2p_offer_payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2p_offer_payment_methods that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2p_offer_payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a P2p_offer_payment_methods
     * @example
     * // Get one P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2p_offer_payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, p2p_offer_payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_offer_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offer_payment_methodsFindFirstArgs} args - Arguments to find a P2p_offer_payment_methods
     * @example
     * // Get one P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2p_offer_payment_methodsFindFirstArgs>(args?: SelectSubset<T, p2p_offer_payment_methodsFindFirstArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_offer_payment_methods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offer_payment_methodsFindFirstOrThrowArgs} args - Arguments to find a P2p_offer_payment_methods
     * @example
     * // Get one P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2p_offer_payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, p2p_offer_payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2p_offer_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offer_payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findMany()
     * 
     * // Get first 10 P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2p_offer_payment_methodsWithIdOnly = await prisma.p2p_offer_payment_methods.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2p_offer_payment_methodsFindManyArgs>(args?: SelectSubset<T, p2p_offer_payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2p_offer_payment_methods.
     * @param {p2p_offer_payment_methodsCreateArgs} args - Arguments to create a P2p_offer_payment_methods.
     * @example
     * // Create one P2p_offer_payment_methods
     * const P2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.create({
     *   data: {
     *     // ... data to create a P2p_offer_payment_methods
     *   }
     * })
     * 
     */
    create<T extends p2p_offer_payment_methodsCreateArgs>(args: SelectSubset<T, p2p_offer_payment_methodsCreateArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2p_offer_payment_methods.
     * @param {p2p_offer_payment_methodsCreateManyArgs} args - Arguments to create many P2p_offer_payment_methods.
     * @example
     * // Create many P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2p_offer_payment_methodsCreateManyArgs>(args?: SelectSubset<T, p2p_offer_payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2p_offer_payment_methods and returns the data saved in the database.
     * @param {p2p_offer_payment_methodsCreateManyAndReturnArgs} args - Arguments to create many P2p_offer_payment_methods.
     * @example
     * // Create many P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2p_offer_payment_methods and only return the `id`
     * const p2p_offer_payment_methodsWithIdOnly = await prisma.p2p_offer_payment_methods.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2p_offer_payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, p2p_offer_payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2p_offer_payment_methods.
     * @param {p2p_offer_payment_methodsDeleteArgs} args - Arguments to delete one P2p_offer_payment_methods.
     * @example
     * // Delete one P2p_offer_payment_methods
     * const P2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.delete({
     *   where: {
     *     // ... filter to delete one P2p_offer_payment_methods
     *   }
     * })
     * 
     */
    delete<T extends p2p_offer_payment_methodsDeleteArgs>(args: SelectSubset<T, p2p_offer_payment_methodsDeleteArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2p_offer_payment_methods.
     * @param {p2p_offer_payment_methodsUpdateArgs} args - Arguments to update one P2p_offer_payment_methods.
     * @example
     * // Update one P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2p_offer_payment_methodsUpdateArgs>(args: SelectSubset<T, p2p_offer_payment_methodsUpdateArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2p_offer_payment_methods.
     * @param {p2p_offer_payment_methodsDeleteManyArgs} args - Arguments to filter P2p_offer_payment_methods to delete.
     * @example
     * // Delete a few P2p_offer_payment_methods
     * const { count } = await prisma.p2p_offer_payment_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2p_offer_payment_methodsDeleteManyArgs>(args?: SelectSubset<T, p2p_offer_payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_offer_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offer_payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2p_offer_payment_methodsUpdateManyArgs>(args: SelectSubset<T, p2p_offer_payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_offer_payment_methods and returns the data updated in the database.
     * @param {p2p_offer_payment_methodsUpdateManyAndReturnArgs} args - Arguments to update many P2p_offer_payment_methods.
     * @example
     * // Update many P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2p_offer_payment_methods and only return the `id`
     * const p2p_offer_payment_methodsWithIdOnly = await prisma.p2p_offer_payment_methods.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2p_offer_payment_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, p2p_offer_payment_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2p_offer_payment_methods.
     * @param {p2p_offer_payment_methodsUpsertArgs} args - Arguments to update or create a P2p_offer_payment_methods.
     * @example
     * // Update or create a P2p_offer_payment_methods
     * const p2p_offer_payment_methods = await prisma.p2p_offer_payment_methods.upsert({
     *   create: {
     *     // ... data to create a P2p_offer_payment_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2p_offer_payment_methods we want to update
     *   }
     * })
     */
    upsert<T extends p2p_offer_payment_methodsUpsertArgs>(args: SelectSubset<T, p2p_offer_payment_methodsUpsertArgs<ExtArgs>>): Prisma__p2p_offer_payment_methodsClient<$Result.GetResult<Prisma.$p2p_offer_payment_methodsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2p_offer_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offer_payment_methodsCountArgs} args - Arguments to filter P2p_offer_payment_methods to count.
     * @example
     * // Count the number of P2p_offer_payment_methods
     * const count = await prisma.p2p_offer_payment_methods.count({
     *   where: {
     *     // ... the filter for the P2p_offer_payment_methods we want to count
     *   }
     * })
    **/
    count<T extends p2p_offer_payment_methodsCountArgs>(
      args?: Subset<T, p2p_offer_payment_methodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2p_offer_payment_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2p_offer_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2p_offer_payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2p_offer_payment_methodsAggregateArgs>(args: Subset<T, P2p_offer_payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetP2p_offer_payment_methodsAggregateType<T>>

    /**
     * Group by P2p_offer_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_offer_payment_methodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2p_offer_payment_methodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2p_offer_payment_methodsGroupByArgs['orderBy'] }
        : { orderBy?: p2p_offer_payment_methodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2p_offer_payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2p_offer_payment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2p_offer_payment_methods model
   */
  readonly fields: p2p_offer_payment_methodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2p_offer_payment_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2p_offer_payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer<T extends p2p_offersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, p2p_offersDefaultArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment_method<T extends user_payment_methodsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_payment_methodsDefaultArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2p_offer_payment_methods model
   */
  interface p2p_offer_payment_methodsFieldRefs {
    readonly id: FieldRef<"p2p_offer_payment_methods", 'String'>
    readonly offer_id: FieldRef<"p2p_offer_payment_methods", 'String'>
    readonly payment_method_id: FieldRef<"p2p_offer_payment_methods", 'String'>
  }
    

  // Custom InputTypes
  /**
   * p2p_offer_payment_methods findUnique
   */
  export type p2p_offer_payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offer_payment_methods to fetch.
     */
    where: p2p_offer_payment_methodsWhereUniqueInput
  }

  /**
   * p2p_offer_payment_methods findUniqueOrThrow
   */
  export type p2p_offer_payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offer_payment_methods to fetch.
     */
    where: p2p_offer_payment_methodsWhereUniqueInput
  }

  /**
   * p2p_offer_payment_methods findFirst
   */
  export type p2p_offer_payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offer_payment_methods to fetch.
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offer_payment_methods to fetch.
     */
    orderBy?: p2p_offer_payment_methodsOrderByWithRelationInput | p2p_offer_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_offer_payment_methods.
     */
    cursor?: p2p_offer_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offer_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offer_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_offer_payment_methods.
     */
    distinct?: P2p_offer_payment_methodsScalarFieldEnum | P2p_offer_payment_methodsScalarFieldEnum[]
  }

  /**
   * p2p_offer_payment_methods findFirstOrThrow
   */
  export type p2p_offer_payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offer_payment_methods to fetch.
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offer_payment_methods to fetch.
     */
    orderBy?: p2p_offer_payment_methodsOrderByWithRelationInput | p2p_offer_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_offer_payment_methods.
     */
    cursor?: p2p_offer_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offer_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offer_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_offer_payment_methods.
     */
    distinct?: P2p_offer_payment_methodsScalarFieldEnum | P2p_offer_payment_methodsScalarFieldEnum[]
  }

  /**
   * p2p_offer_payment_methods findMany
   */
  export type p2p_offer_payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_offer_payment_methods to fetch.
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_offer_payment_methods to fetch.
     */
    orderBy?: p2p_offer_payment_methodsOrderByWithRelationInput | p2p_offer_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2p_offer_payment_methods.
     */
    cursor?: p2p_offer_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_offer_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_offer_payment_methods.
     */
    skip?: number
    distinct?: P2p_offer_payment_methodsScalarFieldEnum | P2p_offer_payment_methodsScalarFieldEnum[]
  }

  /**
   * p2p_offer_payment_methods create
   */
  export type p2p_offer_payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to create a p2p_offer_payment_methods.
     */
    data: XOR<p2p_offer_payment_methodsCreateInput, p2p_offer_payment_methodsUncheckedCreateInput>
  }

  /**
   * p2p_offer_payment_methods createMany
   */
  export type p2p_offer_payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2p_offer_payment_methods.
     */
    data: p2p_offer_payment_methodsCreateManyInput | p2p_offer_payment_methodsCreateManyInput[]
  }

  /**
   * p2p_offer_payment_methods createManyAndReturn
   */
  export type p2p_offer_payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to create many p2p_offer_payment_methods.
     */
    data: p2p_offer_payment_methodsCreateManyInput | p2p_offer_payment_methodsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_offer_payment_methods update
   */
  export type p2p_offer_payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to update a p2p_offer_payment_methods.
     */
    data: XOR<p2p_offer_payment_methodsUpdateInput, p2p_offer_payment_methodsUncheckedUpdateInput>
    /**
     * Choose, which p2p_offer_payment_methods to update.
     */
    where: p2p_offer_payment_methodsWhereUniqueInput
  }

  /**
   * p2p_offer_payment_methods updateMany
   */
  export type p2p_offer_payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2p_offer_payment_methods.
     */
    data: XOR<p2p_offer_payment_methodsUpdateManyMutationInput, p2p_offer_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which p2p_offer_payment_methods to update
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * Limit how many p2p_offer_payment_methods to update.
     */
    limit?: number
  }

  /**
   * p2p_offer_payment_methods updateManyAndReturn
   */
  export type p2p_offer_payment_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to update p2p_offer_payment_methods.
     */
    data: XOR<p2p_offer_payment_methodsUpdateManyMutationInput, p2p_offer_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which p2p_offer_payment_methods to update
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * Limit how many p2p_offer_payment_methods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_offer_payment_methods upsert
   */
  export type p2p_offer_payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * The filter to search for the p2p_offer_payment_methods to update in case it exists.
     */
    where: p2p_offer_payment_methodsWhereUniqueInput
    /**
     * In case the p2p_offer_payment_methods found by the `where` argument doesn't exist, create a new p2p_offer_payment_methods with this data.
     */
    create: XOR<p2p_offer_payment_methodsCreateInput, p2p_offer_payment_methodsUncheckedCreateInput>
    /**
     * In case the p2p_offer_payment_methods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2p_offer_payment_methodsUpdateInput, p2p_offer_payment_methodsUncheckedUpdateInput>
  }

  /**
   * p2p_offer_payment_methods delete
   */
  export type p2p_offer_payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter which p2p_offer_payment_methods to delete.
     */
    where: p2p_offer_payment_methodsWhereUniqueInput
  }

  /**
   * p2p_offer_payment_methods deleteMany
   */
  export type p2p_offer_payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_offer_payment_methods to delete
     */
    where?: p2p_offer_payment_methodsWhereInput
    /**
     * Limit how many p2p_offer_payment_methods to delete.
     */
    limit?: number
  }

  /**
   * p2p_offer_payment_methods without action
   */
  export type p2p_offer_payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_offer_payment_methods
     */
    select?: p2p_offer_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_offer_payment_methods
     */
    omit?: p2p_offer_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_offer_payment_methodsInclude<ExtArgs> | null
  }


  /**
   * Model p2p_orders
   */

  export type AggregateP2p_orders = {
    _count: P2p_ordersCountAggregateOutputType | null
    _avg: P2p_ordersAvgAggregateOutputType | null
    _sum: P2p_ordersSumAggregateOutputType | null
    _min: P2p_ordersMinAggregateOutputType | null
    _max: P2p_ordersMaxAggregateOutputType | null
  }

  export type P2p_ordersAvgAggregateOutputType = {
    price: Decimal | null
    amount_asset: Decimal | null
    amount_fiat: Decimal | null
  }

  export type P2p_ordersSumAggregateOutputType = {
    price: Decimal | null
    amount_asset: Decimal | null
    amount_fiat: Decimal | null
  }

  export type P2p_ordersMinAggregateOutputType = {
    id: string | null
    offer_id: string | null
    maker_id: string | null
    taker_id: string | null
    side: $Enums.P2POrderSide | null
    asset_symbol: string | null
    fiat_currency: string | null
    price: Decimal | null
    amount_asset: Decimal | null
    amount_fiat: Decimal | null
    status: $Enums.P2PTradeStatus | null
    escrow_held: boolean | null
    escrow_ledger_id: string | null
    reference_code: string | null
    expires_at: Date | null
    paid_at: Date | null
    released_at: Date | null
    canceled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P2p_ordersMaxAggregateOutputType = {
    id: string | null
    offer_id: string | null
    maker_id: string | null
    taker_id: string | null
    side: $Enums.P2POrderSide | null
    asset_symbol: string | null
    fiat_currency: string | null
    price: Decimal | null
    amount_asset: Decimal | null
    amount_fiat: Decimal | null
    status: $Enums.P2PTradeStatus | null
    escrow_held: boolean | null
    escrow_ledger_id: string | null
    reference_code: string | null
    expires_at: Date | null
    paid_at: Date | null
    released_at: Date | null
    canceled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P2p_ordersCountAggregateOutputType = {
    id: number
    offer_id: number
    maker_id: number
    taker_id: number
    side: number
    asset_symbol: number
    fiat_currency: number
    price: number
    amount_asset: number
    amount_fiat: number
    status: number
    escrow_held: number
    escrow_ledger_id: number
    reference_code: number
    meta: number
    expires_at: number
    paid_at: number
    released_at: number
    canceled_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P2p_ordersAvgAggregateInputType = {
    price?: true
    amount_asset?: true
    amount_fiat?: true
  }

  export type P2p_ordersSumAggregateInputType = {
    price?: true
    amount_asset?: true
    amount_fiat?: true
  }

  export type P2p_ordersMinAggregateInputType = {
    id?: true
    offer_id?: true
    maker_id?: true
    taker_id?: true
    side?: true
    asset_symbol?: true
    fiat_currency?: true
    price?: true
    amount_asset?: true
    amount_fiat?: true
    status?: true
    escrow_held?: true
    escrow_ledger_id?: true
    reference_code?: true
    expires_at?: true
    paid_at?: true
    released_at?: true
    canceled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type P2p_ordersMaxAggregateInputType = {
    id?: true
    offer_id?: true
    maker_id?: true
    taker_id?: true
    side?: true
    asset_symbol?: true
    fiat_currency?: true
    price?: true
    amount_asset?: true
    amount_fiat?: true
    status?: true
    escrow_held?: true
    escrow_ledger_id?: true
    reference_code?: true
    expires_at?: true
    paid_at?: true
    released_at?: true
    canceled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type P2p_ordersCountAggregateInputType = {
    id?: true
    offer_id?: true
    maker_id?: true
    taker_id?: true
    side?: true
    asset_symbol?: true
    fiat_currency?: true
    price?: true
    amount_asset?: true
    amount_fiat?: true
    status?: true
    escrow_held?: true
    escrow_ledger_id?: true
    reference_code?: true
    meta?: true
    expires_at?: true
    paid_at?: true
    released_at?: true
    canceled_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P2p_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_orders to aggregate.
     */
    where?: p2p_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_orders to fetch.
     */
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2p_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2p_orders
    **/
    _count?: true | P2p_ordersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P2p_ordersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P2p_ordersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2p_ordersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2p_ordersMaxAggregateInputType
  }

  export type GetP2p_ordersAggregateType<T extends P2p_ordersAggregateArgs> = {
        [P in keyof T & keyof AggregateP2p_orders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2p_orders[P]>
      : GetScalarType<T[P], AggregateP2p_orders[P]>
  }




  export type p2p_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ordersWhereInput
    orderBy?: p2p_ordersOrderByWithAggregationInput | p2p_ordersOrderByWithAggregationInput[]
    by: P2p_ordersScalarFieldEnum[] | P2p_ordersScalarFieldEnum
    having?: p2p_ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2p_ordersCountAggregateInputType | true
    _avg?: P2p_ordersAvgAggregateInputType
    _sum?: P2p_ordersSumAggregateInputType
    _min?: P2p_ordersMinAggregateInputType
    _max?: P2p_ordersMaxAggregateInputType
  }

  export type P2p_ordersGroupByOutputType = {
    id: string
    offer_id: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal
    amount_asset: Decimal
    amount_fiat: Decimal
    status: $Enums.P2PTradeStatus
    escrow_held: boolean
    escrow_ledger_id: string | null
    reference_code: string | null
    meta: JsonValue | null
    expires_at: Date | null
    paid_at: Date | null
    released_at: Date | null
    canceled_at: Date | null
    created_at: Date
    updated_at: Date
    _count: P2p_ordersCountAggregateOutputType | null
    _avg: P2p_ordersAvgAggregateOutputType | null
    _sum: P2p_ordersSumAggregateOutputType | null
    _min: P2p_ordersMinAggregateOutputType | null
    _max: P2p_ordersMaxAggregateOutputType | null
  }

  type GetP2p_ordersGroupByPayload<T extends p2p_ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2p_ordersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2p_ordersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2p_ordersGroupByOutputType[P]>
            : GetScalarType<T[P], P2p_ordersGroupByOutputType[P]>
        }
      >
    >


  export type p2p_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    maker_id?: boolean
    taker_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    fiat_currency?: boolean
    price?: boolean
    amount_asset?: boolean
    amount_fiat?: boolean
    status?: boolean
    escrow_held?: boolean
    escrow_ledger_id?: boolean
    reference_code?: boolean
    meta?: boolean
    expires_at?: boolean
    paid_at?: boolean
    released_at?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    maker?: boolean | usersDefaultArgs<ExtArgs>
    taker?: boolean | usersDefaultArgs<ExtArgs>
    messages?: boolean | p2p_orders$messagesArgs<ExtArgs>
    disputes?: boolean | p2p_orders$disputesArgs<ExtArgs>
    ratings?: boolean | p2p_orders$ratingsArgs<ExtArgs>
    _count?: boolean | P2p_ordersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_orders"]>

  export type p2p_ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    maker_id?: boolean
    taker_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    fiat_currency?: boolean
    price?: boolean
    amount_asset?: boolean
    amount_fiat?: boolean
    status?: boolean
    escrow_held?: boolean
    escrow_ledger_id?: boolean
    reference_code?: boolean
    meta?: boolean
    expires_at?: boolean
    paid_at?: boolean
    released_at?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    maker?: boolean | usersDefaultArgs<ExtArgs>
    taker?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_orders"]>

  export type p2p_ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    maker_id?: boolean
    taker_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    fiat_currency?: boolean
    price?: boolean
    amount_asset?: boolean
    amount_fiat?: boolean
    status?: boolean
    escrow_held?: boolean
    escrow_ledger_id?: boolean
    reference_code?: boolean
    meta?: boolean
    expires_at?: boolean
    paid_at?: boolean
    released_at?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    maker?: boolean | usersDefaultArgs<ExtArgs>
    taker?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_orders"]>

  export type p2p_ordersSelectScalar = {
    id?: boolean
    offer_id?: boolean
    maker_id?: boolean
    taker_id?: boolean
    side?: boolean
    asset_symbol?: boolean
    fiat_currency?: boolean
    price?: boolean
    amount_asset?: boolean
    amount_fiat?: boolean
    status?: boolean
    escrow_held?: boolean
    escrow_ledger_id?: boolean
    reference_code?: boolean
    meta?: boolean
    expires_at?: boolean
    paid_at?: boolean
    released_at?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type p2p_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offer_id" | "maker_id" | "taker_id" | "side" | "asset_symbol" | "fiat_currency" | "price" | "amount_asset" | "amount_fiat" | "status" | "escrow_held" | "escrow_ledger_id" | "reference_code" | "meta" | "expires_at" | "paid_at" | "released_at" | "canceled_at" | "created_at" | "updated_at", ExtArgs["result"]["p2p_orders"]>
  export type p2p_ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    maker?: boolean | usersDefaultArgs<ExtArgs>
    taker?: boolean | usersDefaultArgs<ExtArgs>
    messages?: boolean | p2p_orders$messagesArgs<ExtArgs>
    disputes?: boolean | p2p_orders$disputesArgs<ExtArgs>
    ratings?: boolean | p2p_orders$ratingsArgs<ExtArgs>
    _count?: boolean | P2p_ordersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type p2p_ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    maker?: boolean | usersDefaultArgs<ExtArgs>
    taker?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | p2p_offersDefaultArgs<ExtArgs>
    maker?: boolean | usersDefaultArgs<ExtArgs>
    taker?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $p2p_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2p_orders"
    objects: {
      offer: Prisma.$p2p_offersPayload<ExtArgs>
      maker: Prisma.$usersPayload<ExtArgs>
      taker: Prisma.$usersPayload<ExtArgs>
      messages: Prisma.$p2p_messagesPayload<ExtArgs>[]
      disputes: Prisma.$p2p_disputesPayload<ExtArgs>[]
      ratings: Prisma.$p2p_ratingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offer_id: string
      maker_id: string
      taker_id: string
      side: $Enums.P2POrderSide
      asset_symbol: string
      fiat_currency: string
      price: Prisma.Decimal
      amount_asset: Prisma.Decimal
      amount_fiat: Prisma.Decimal
      status: $Enums.P2PTradeStatus
      escrow_held: boolean
      escrow_ledger_id: string | null
      reference_code: string | null
      meta: Prisma.JsonValue | null
      expires_at: Date | null
      paid_at: Date | null
      released_at: Date | null
      canceled_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["p2p_orders"]>
    composites: {}
  }

  type p2p_ordersGetPayload<S extends boolean | null | undefined | p2p_ordersDefaultArgs> = $Result.GetResult<Prisma.$p2p_ordersPayload, S>

  type p2p_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2p_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2p_ordersCountAggregateInputType | true
    }

  export interface p2p_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2p_orders'], meta: { name: 'p2p_orders' } }
    /**
     * Find zero or one P2p_orders that matches the filter.
     * @param {p2p_ordersFindUniqueArgs} args - Arguments to find a P2p_orders
     * @example
     * // Get one P2p_orders
     * const p2p_orders = await prisma.p2p_orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2p_ordersFindUniqueArgs>(args: SelectSubset<T, p2p_ordersFindUniqueArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2p_orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2p_ordersFindUniqueOrThrowArgs} args - Arguments to find a P2p_orders
     * @example
     * // Get one P2p_orders
     * const p2p_orders = await prisma.p2p_orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2p_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, p2p_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ordersFindFirstArgs} args - Arguments to find a P2p_orders
     * @example
     * // Get one P2p_orders
     * const p2p_orders = await prisma.p2p_orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2p_ordersFindFirstArgs>(args?: SelectSubset<T, p2p_ordersFindFirstArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ordersFindFirstOrThrowArgs} args - Arguments to find a P2p_orders
     * @example
     * // Get one P2p_orders
     * const p2p_orders = await prisma.p2p_orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2p_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, p2p_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2p_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2p_orders
     * const p2p_orders = await prisma.p2p_orders.findMany()
     * 
     * // Get first 10 P2p_orders
     * const p2p_orders = await prisma.p2p_orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2p_ordersWithIdOnly = await prisma.p2p_orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2p_ordersFindManyArgs>(args?: SelectSubset<T, p2p_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2p_orders.
     * @param {p2p_ordersCreateArgs} args - Arguments to create a P2p_orders.
     * @example
     * // Create one P2p_orders
     * const P2p_orders = await prisma.p2p_orders.create({
     *   data: {
     *     // ... data to create a P2p_orders
     *   }
     * })
     * 
     */
    create<T extends p2p_ordersCreateArgs>(args: SelectSubset<T, p2p_ordersCreateArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2p_orders.
     * @param {p2p_ordersCreateManyArgs} args - Arguments to create many P2p_orders.
     * @example
     * // Create many P2p_orders
     * const p2p_orders = await prisma.p2p_orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2p_ordersCreateManyArgs>(args?: SelectSubset<T, p2p_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2p_orders and returns the data saved in the database.
     * @param {p2p_ordersCreateManyAndReturnArgs} args - Arguments to create many P2p_orders.
     * @example
     * // Create many P2p_orders
     * const p2p_orders = await prisma.p2p_orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2p_orders and only return the `id`
     * const p2p_ordersWithIdOnly = await prisma.p2p_orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2p_ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, p2p_ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2p_orders.
     * @param {p2p_ordersDeleteArgs} args - Arguments to delete one P2p_orders.
     * @example
     * // Delete one P2p_orders
     * const P2p_orders = await prisma.p2p_orders.delete({
     *   where: {
     *     // ... filter to delete one P2p_orders
     *   }
     * })
     * 
     */
    delete<T extends p2p_ordersDeleteArgs>(args: SelectSubset<T, p2p_ordersDeleteArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2p_orders.
     * @param {p2p_ordersUpdateArgs} args - Arguments to update one P2p_orders.
     * @example
     * // Update one P2p_orders
     * const p2p_orders = await prisma.p2p_orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2p_ordersUpdateArgs>(args: SelectSubset<T, p2p_ordersUpdateArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2p_orders.
     * @param {p2p_ordersDeleteManyArgs} args - Arguments to filter P2p_orders to delete.
     * @example
     * // Delete a few P2p_orders
     * const { count } = await prisma.p2p_orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2p_ordersDeleteManyArgs>(args?: SelectSubset<T, p2p_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2p_orders
     * const p2p_orders = await prisma.p2p_orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2p_ordersUpdateManyArgs>(args: SelectSubset<T, p2p_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_orders and returns the data updated in the database.
     * @param {p2p_ordersUpdateManyAndReturnArgs} args - Arguments to update many P2p_orders.
     * @example
     * // Update many P2p_orders
     * const p2p_orders = await prisma.p2p_orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2p_orders and only return the `id`
     * const p2p_ordersWithIdOnly = await prisma.p2p_orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2p_ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, p2p_ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2p_orders.
     * @param {p2p_ordersUpsertArgs} args - Arguments to update or create a P2p_orders.
     * @example
     * // Update or create a P2p_orders
     * const p2p_orders = await prisma.p2p_orders.upsert({
     *   create: {
     *     // ... data to create a P2p_orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2p_orders we want to update
     *   }
     * })
     */
    upsert<T extends p2p_ordersUpsertArgs>(args: SelectSubset<T, p2p_ordersUpsertArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2p_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ordersCountArgs} args - Arguments to filter P2p_orders to count.
     * @example
     * // Count the number of P2p_orders
     * const count = await prisma.p2p_orders.count({
     *   where: {
     *     // ... the filter for the P2p_orders we want to count
     *   }
     * })
    **/
    count<T extends p2p_ordersCountArgs>(
      args?: Subset<T, p2p_ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2p_ordersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2p_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2p_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2p_ordersAggregateArgs>(args: Subset<T, P2p_ordersAggregateArgs>): Prisma.PrismaPromise<GetP2p_ordersAggregateType<T>>

    /**
     * Group by P2p_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2p_ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2p_ordersGroupByArgs['orderBy'] }
        : { orderBy?: p2p_ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2p_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2p_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2p_orders model
   */
  readonly fields: p2p_ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2p_orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2p_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer<T extends p2p_offersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, p2p_offersDefaultArgs<ExtArgs>>): Prisma__p2p_offersClient<$Result.GetResult<Prisma.$p2p_offersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maker<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taker<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends p2p_orders$messagesArgs<ExtArgs> = {}>(args?: Subset<T, p2p_orders$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputes<T extends p2p_orders$disputesArgs<ExtArgs> = {}>(args?: Subset<T, p2p_orders$disputesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends p2p_orders$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, p2p_orders$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2p_orders model
   */
  interface p2p_ordersFieldRefs {
    readonly id: FieldRef<"p2p_orders", 'String'>
    readonly offer_id: FieldRef<"p2p_orders", 'String'>
    readonly maker_id: FieldRef<"p2p_orders", 'String'>
    readonly taker_id: FieldRef<"p2p_orders", 'String'>
    readonly side: FieldRef<"p2p_orders", 'P2POrderSide'>
    readonly asset_symbol: FieldRef<"p2p_orders", 'String'>
    readonly fiat_currency: FieldRef<"p2p_orders", 'String'>
    readonly price: FieldRef<"p2p_orders", 'Decimal'>
    readonly amount_asset: FieldRef<"p2p_orders", 'Decimal'>
    readonly amount_fiat: FieldRef<"p2p_orders", 'Decimal'>
    readonly status: FieldRef<"p2p_orders", 'P2PTradeStatus'>
    readonly escrow_held: FieldRef<"p2p_orders", 'Boolean'>
    readonly escrow_ledger_id: FieldRef<"p2p_orders", 'String'>
    readonly reference_code: FieldRef<"p2p_orders", 'String'>
    readonly meta: FieldRef<"p2p_orders", 'Json'>
    readonly expires_at: FieldRef<"p2p_orders", 'DateTime'>
    readonly paid_at: FieldRef<"p2p_orders", 'DateTime'>
    readonly released_at: FieldRef<"p2p_orders", 'DateTime'>
    readonly canceled_at: FieldRef<"p2p_orders", 'DateTime'>
    readonly created_at: FieldRef<"p2p_orders", 'DateTime'>
    readonly updated_at: FieldRef<"p2p_orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * p2p_orders findUnique
   */
  export type p2p_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_orders to fetch.
     */
    where: p2p_ordersWhereUniqueInput
  }

  /**
   * p2p_orders findUniqueOrThrow
   */
  export type p2p_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_orders to fetch.
     */
    where: p2p_ordersWhereUniqueInput
  }

  /**
   * p2p_orders findFirst
   */
  export type p2p_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_orders to fetch.
     */
    where?: p2p_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_orders to fetch.
     */
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_orders.
     */
    cursor?: p2p_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_orders.
     */
    distinct?: P2p_ordersScalarFieldEnum | P2p_ordersScalarFieldEnum[]
  }

  /**
   * p2p_orders findFirstOrThrow
   */
  export type p2p_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_orders to fetch.
     */
    where?: p2p_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_orders to fetch.
     */
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_orders.
     */
    cursor?: p2p_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_orders.
     */
    distinct?: P2p_ordersScalarFieldEnum | P2p_ordersScalarFieldEnum[]
  }

  /**
   * p2p_orders findMany
   */
  export type p2p_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * Filter, which p2p_orders to fetch.
     */
    where?: p2p_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_orders to fetch.
     */
    orderBy?: p2p_ordersOrderByWithRelationInput | p2p_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2p_orders.
     */
    cursor?: p2p_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_orders.
     */
    skip?: number
    distinct?: P2p_ordersScalarFieldEnum | P2p_ordersScalarFieldEnum[]
  }

  /**
   * p2p_orders create
   */
  export type p2p_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a p2p_orders.
     */
    data: XOR<p2p_ordersCreateInput, p2p_ordersUncheckedCreateInput>
  }

  /**
   * p2p_orders createMany
   */
  export type p2p_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2p_orders.
     */
    data: p2p_ordersCreateManyInput | p2p_ordersCreateManyInput[]
  }

  /**
   * p2p_orders createManyAndReturn
   */
  export type p2p_ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * The data used to create many p2p_orders.
     */
    data: p2p_ordersCreateManyInput | p2p_ordersCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_orders update
   */
  export type p2p_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a p2p_orders.
     */
    data: XOR<p2p_ordersUpdateInput, p2p_ordersUncheckedUpdateInput>
    /**
     * Choose, which p2p_orders to update.
     */
    where: p2p_ordersWhereUniqueInput
  }

  /**
   * p2p_orders updateMany
   */
  export type p2p_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2p_orders.
     */
    data: XOR<p2p_ordersUpdateManyMutationInput, p2p_ordersUncheckedUpdateManyInput>
    /**
     * Filter which p2p_orders to update
     */
    where?: p2p_ordersWhereInput
    /**
     * Limit how many p2p_orders to update.
     */
    limit?: number
  }

  /**
   * p2p_orders updateManyAndReturn
   */
  export type p2p_ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * The data used to update p2p_orders.
     */
    data: XOR<p2p_ordersUpdateManyMutationInput, p2p_ordersUncheckedUpdateManyInput>
    /**
     * Filter which p2p_orders to update
     */
    where?: p2p_ordersWhereInput
    /**
     * Limit how many p2p_orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_orders upsert
   */
  export type p2p_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the p2p_orders to update in case it exists.
     */
    where: p2p_ordersWhereUniqueInput
    /**
     * In case the p2p_orders found by the `where` argument doesn't exist, create a new p2p_orders with this data.
     */
    create: XOR<p2p_ordersCreateInput, p2p_ordersUncheckedCreateInput>
    /**
     * In case the p2p_orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2p_ordersUpdateInput, p2p_ordersUncheckedUpdateInput>
  }

  /**
   * p2p_orders delete
   */
  export type p2p_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
    /**
     * Filter which p2p_orders to delete.
     */
    where: p2p_ordersWhereUniqueInput
  }

  /**
   * p2p_orders deleteMany
   */
  export type p2p_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_orders to delete
     */
    where?: p2p_ordersWhereInput
    /**
     * Limit how many p2p_orders to delete.
     */
    limit?: number
  }

  /**
   * p2p_orders.messages
   */
  export type p2p_orders$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    where?: p2p_messagesWhereInput
    orderBy?: p2p_messagesOrderByWithRelationInput | p2p_messagesOrderByWithRelationInput[]
    cursor?: p2p_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_messagesScalarFieldEnum | P2p_messagesScalarFieldEnum[]
  }

  /**
   * p2p_orders.disputes
   */
  export type p2p_orders$disputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    where?: p2p_disputesWhereInput
    orderBy?: p2p_disputesOrderByWithRelationInput | p2p_disputesOrderByWithRelationInput[]
    cursor?: p2p_disputesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_disputesScalarFieldEnum | P2p_disputesScalarFieldEnum[]
  }

  /**
   * p2p_orders.ratings
   */
  export type p2p_orders$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    where?: p2p_ratingsWhereInput
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    cursor?: p2p_ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2p_ratingsScalarFieldEnum | P2p_ratingsScalarFieldEnum[]
  }

  /**
   * p2p_orders without action
   */
  export type p2p_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_orders
     */
    select?: p2p_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_orders
     */
    omit?: p2p_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ordersInclude<ExtArgs> | null
  }


  /**
   * Model p2p_messages
   */

  export type AggregateP2p_messages = {
    _count: P2p_messagesCountAggregateOutputType | null
    _min: P2p_messagesMinAggregateOutputType | null
    _max: P2p_messagesMaxAggregateOutputType | null
  }

  export type P2p_messagesMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    sender_id: string | null
    message: string | null
    created_at: Date | null
  }

  export type P2p_messagesMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    sender_id: string | null
    message: string | null
    created_at: Date | null
  }

  export type P2p_messagesCountAggregateOutputType = {
    id: number
    order_id: number
    sender_id: number
    message: number
    attachments: number
    created_at: number
    _all: number
  }


  export type P2p_messagesMinAggregateInputType = {
    id?: true
    order_id?: true
    sender_id?: true
    message?: true
    created_at?: true
  }

  export type P2p_messagesMaxAggregateInputType = {
    id?: true
    order_id?: true
    sender_id?: true
    message?: true
    created_at?: true
  }

  export type P2p_messagesCountAggregateInputType = {
    id?: true
    order_id?: true
    sender_id?: true
    message?: true
    attachments?: true
    created_at?: true
    _all?: true
  }

  export type P2p_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_messages to aggregate.
     */
    where?: p2p_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_messages to fetch.
     */
    orderBy?: p2p_messagesOrderByWithRelationInput | p2p_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2p_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2p_messages
    **/
    _count?: true | P2p_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2p_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2p_messagesMaxAggregateInputType
  }

  export type GetP2p_messagesAggregateType<T extends P2p_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateP2p_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2p_messages[P]>
      : GetScalarType<T[P], AggregateP2p_messages[P]>
  }




  export type p2p_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_messagesWhereInput
    orderBy?: p2p_messagesOrderByWithAggregationInput | p2p_messagesOrderByWithAggregationInput[]
    by: P2p_messagesScalarFieldEnum[] | P2p_messagesScalarFieldEnum
    having?: p2p_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2p_messagesCountAggregateInputType | true
    _min?: P2p_messagesMinAggregateInputType
    _max?: P2p_messagesMaxAggregateInputType
  }

  export type P2p_messagesGroupByOutputType = {
    id: string
    order_id: string
    sender_id: string
    message: string
    attachments: JsonValue | null
    created_at: Date
    _count: P2p_messagesCountAggregateOutputType | null
    _min: P2p_messagesMinAggregateOutputType | null
    _max: P2p_messagesMaxAggregateOutputType | null
  }

  type GetP2p_messagesGroupByPayload<T extends p2p_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2p_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2p_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2p_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], P2p_messagesGroupByOutputType[P]>
        }
      >
    >


  export type p2p_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    sender_id?: boolean
    message?: boolean
    attachments?: boolean
    created_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    sender?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_messages"]>

  export type p2p_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    sender_id?: boolean
    message?: boolean
    attachments?: boolean
    created_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    sender?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_messages"]>

  export type p2p_messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    sender_id?: boolean
    message?: boolean
    attachments?: boolean
    created_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    sender?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_messages"]>

  export type p2p_messagesSelectScalar = {
    id?: boolean
    order_id?: boolean
    sender_id?: boolean
    message?: boolean
    attachments?: boolean
    created_at?: boolean
  }

  export type p2p_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_id" | "sender_id" | "message" | "attachments" | "created_at", ExtArgs["result"]["p2p_messages"]>
  export type p2p_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    sender?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    sender?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    sender?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $p2p_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2p_messages"
    objects: {
      order: Prisma.$p2p_ordersPayload<ExtArgs>
      sender: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      sender_id: string
      message: string
      attachments: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["p2p_messages"]>
    composites: {}
  }

  type p2p_messagesGetPayload<S extends boolean | null | undefined | p2p_messagesDefaultArgs> = $Result.GetResult<Prisma.$p2p_messagesPayload, S>

  type p2p_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2p_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2p_messagesCountAggregateInputType | true
    }

  export interface p2p_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2p_messages'], meta: { name: 'p2p_messages' } }
    /**
     * Find zero or one P2p_messages that matches the filter.
     * @param {p2p_messagesFindUniqueArgs} args - Arguments to find a P2p_messages
     * @example
     * // Get one P2p_messages
     * const p2p_messages = await prisma.p2p_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2p_messagesFindUniqueArgs>(args: SelectSubset<T, p2p_messagesFindUniqueArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2p_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2p_messagesFindUniqueOrThrowArgs} args - Arguments to find a P2p_messages
     * @example
     * // Get one P2p_messages
     * const p2p_messages = await prisma.p2p_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2p_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, p2p_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_messagesFindFirstArgs} args - Arguments to find a P2p_messages
     * @example
     * // Get one P2p_messages
     * const p2p_messages = await prisma.p2p_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2p_messagesFindFirstArgs>(args?: SelectSubset<T, p2p_messagesFindFirstArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_messagesFindFirstOrThrowArgs} args - Arguments to find a P2p_messages
     * @example
     * // Get one P2p_messages
     * const p2p_messages = await prisma.p2p_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2p_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, p2p_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2p_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2p_messages
     * const p2p_messages = await prisma.p2p_messages.findMany()
     * 
     * // Get first 10 P2p_messages
     * const p2p_messages = await prisma.p2p_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2p_messagesWithIdOnly = await prisma.p2p_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2p_messagesFindManyArgs>(args?: SelectSubset<T, p2p_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2p_messages.
     * @param {p2p_messagesCreateArgs} args - Arguments to create a P2p_messages.
     * @example
     * // Create one P2p_messages
     * const P2p_messages = await prisma.p2p_messages.create({
     *   data: {
     *     // ... data to create a P2p_messages
     *   }
     * })
     * 
     */
    create<T extends p2p_messagesCreateArgs>(args: SelectSubset<T, p2p_messagesCreateArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2p_messages.
     * @param {p2p_messagesCreateManyArgs} args - Arguments to create many P2p_messages.
     * @example
     * // Create many P2p_messages
     * const p2p_messages = await prisma.p2p_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2p_messagesCreateManyArgs>(args?: SelectSubset<T, p2p_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2p_messages and returns the data saved in the database.
     * @param {p2p_messagesCreateManyAndReturnArgs} args - Arguments to create many P2p_messages.
     * @example
     * // Create many P2p_messages
     * const p2p_messages = await prisma.p2p_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2p_messages and only return the `id`
     * const p2p_messagesWithIdOnly = await prisma.p2p_messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2p_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, p2p_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2p_messages.
     * @param {p2p_messagesDeleteArgs} args - Arguments to delete one P2p_messages.
     * @example
     * // Delete one P2p_messages
     * const P2p_messages = await prisma.p2p_messages.delete({
     *   where: {
     *     // ... filter to delete one P2p_messages
     *   }
     * })
     * 
     */
    delete<T extends p2p_messagesDeleteArgs>(args: SelectSubset<T, p2p_messagesDeleteArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2p_messages.
     * @param {p2p_messagesUpdateArgs} args - Arguments to update one P2p_messages.
     * @example
     * // Update one P2p_messages
     * const p2p_messages = await prisma.p2p_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2p_messagesUpdateArgs>(args: SelectSubset<T, p2p_messagesUpdateArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2p_messages.
     * @param {p2p_messagesDeleteManyArgs} args - Arguments to filter P2p_messages to delete.
     * @example
     * // Delete a few P2p_messages
     * const { count } = await prisma.p2p_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2p_messagesDeleteManyArgs>(args?: SelectSubset<T, p2p_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2p_messages
     * const p2p_messages = await prisma.p2p_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2p_messagesUpdateManyArgs>(args: SelectSubset<T, p2p_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_messages and returns the data updated in the database.
     * @param {p2p_messagesUpdateManyAndReturnArgs} args - Arguments to update many P2p_messages.
     * @example
     * // Update many P2p_messages
     * const p2p_messages = await prisma.p2p_messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2p_messages and only return the `id`
     * const p2p_messagesWithIdOnly = await prisma.p2p_messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2p_messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, p2p_messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2p_messages.
     * @param {p2p_messagesUpsertArgs} args - Arguments to update or create a P2p_messages.
     * @example
     * // Update or create a P2p_messages
     * const p2p_messages = await prisma.p2p_messages.upsert({
     *   create: {
     *     // ... data to create a P2p_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2p_messages we want to update
     *   }
     * })
     */
    upsert<T extends p2p_messagesUpsertArgs>(args: SelectSubset<T, p2p_messagesUpsertArgs<ExtArgs>>): Prisma__p2p_messagesClient<$Result.GetResult<Prisma.$p2p_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2p_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_messagesCountArgs} args - Arguments to filter P2p_messages to count.
     * @example
     * // Count the number of P2p_messages
     * const count = await prisma.p2p_messages.count({
     *   where: {
     *     // ... the filter for the P2p_messages we want to count
     *   }
     * })
    **/
    count<T extends p2p_messagesCountArgs>(
      args?: Subset<T, p2p_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2p_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2p_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2p_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2p_messagesAggregateArgs>(args: Subset<T, P2p_messagesAggregateArgs>): Prisma.PrismaPromise<GetP2p_messagesAggregateType<T>>

    /**
     * Group by P2p_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2p_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2p_messagesGroupByArgs['orderBy'] }
        : { orderBy?: p2p_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2p_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2p_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2p_messages model
   */
  readonly fields: p2p_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2p_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2p_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends p2p_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, p2p_ordersDefaultArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2p_messages model
   */
  interface p2p_messagesFieldRefs {
    readonly id: FieldRef<"p2p_messages", 'String'>
    readonly order_id: FieldRef<"p2p_messages", 'String'>
    readonly sender_id: FieldRef<"p2p_messages", 'String'>
    readonly message: FieldRef<"p2p_messages", 'String'>
    readonly attachments: FieldRef<"p2p_messages", 'Json'>
    readonly created_at: FieldRef<"p2p_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * p2p_messages findUnique
   */
  export type p2p_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_messages to fetch.
     */
    where: p2p_messagesWhereUniqueInput
  }

  /**
   * p2p_messages findUniqueOrThrow
   */
  export type p2p_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_messages to fetch.
     */
    where: p2p_messagesWhereUniqueInput
  }

  /**
   * p2p_messages findFirst
   */
  export type p2p_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_messages to fetch.
     */
    where?: p2p_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_messages to fetch.
     */
    orderBy?: p2p_messagesOrderByWithRelationInput | p2p_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_messages.
     */
    cursor?: p2p_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_messages.
     */
    distinct?: P2p_messagesScalarFieldEnum | P2p_messagesScalarFieldEnum[]
  }

  /**
   * p2p_messages findFirstOrThrow
   */
  export type p2p_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_messages to fetch.
     */
    where?: p2p_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_messages to fetch.
     */
    orderBy?: p2p_messagesOrderByWithRelationInput | p2p_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_messages.
     */
    cursor?: p2p_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_messages.
     */
    distinct?: P2p_messagesScalarFieldEnum | P2p_messagesScalarFieldEnum[]
  }

  /**
   * p2p_messages findMany
   */
  export type p2p_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_messages to fetch.
     */
    where?: p2p_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_messages to fetch.
     */
    orderBy?: p2p_messagesOrderByWithRelationInput | p2p_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2p_messages.
     */
    cursor?: p2p_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_messages.
     */
    skip?: number
    distinct?: P2p_messagesScalarFieldEnum | P2p_messagesScalarFieldEnum[]
  }

  /**
   * p2p_messages create
   */
  export type p2p_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a p2p_messages.
     */
    data: XOR<p2p_messagesCreateInput, p2p_messagesUncheckedCreateInput>
  }

  /**
   * p2p_messages createMany
   */
  export type p2p_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2p_messages.
     */
    data: p2p_messagesCreateManyInput | p2p_messagesCreateManyInput[]
  }

  /**
   * p2p_messages createManyAndReturn
   */
  export type p2p_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * The data used to create many p2p_messages.
     */
    data: p2p_messagesCreateManyInput | p2p_messagesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_messages update
   */
  export type p2p_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a p2p_messages.
     */
    data: XOR<p2p_messagesUpdateInput, p2p_messagesUncheckedUpdateInput>
    /**
     * Choose, which p2p_messages to update.
     */
    where: p2p_messagesWhereUniqueInput
  }

  /**
   * p2p_messages updateMany
   */
  export type p2p_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2p_messages.
     */
    data: XOR<p2p_messagesUpdateManyMutationInput, p2p_messagesUncheckedUpdateManyInput>
    /**
     * Filter which p2p_messages to update
     */
    where?: p2p_messagesWhereInput
    /**
     * Limit how many p2p_messages to update.
     */
    limit?: number
  }

  /**
   * p2p_messages updateManyAndReturn
   */
  export type p2p_messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * The data used to update p2p_messages.
     */
    data: XOR<p2p_messagesUpdateManyMutationInput, p2p_messagesUncheckedUpdateManyInput>
    /**
     * Filter which p2p_messages to update
     */
    where?: p2p_messagesWhereInput
    /**
     * Limit how many p2p_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_messages upsert
   */
  export type p2p_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the p2p_messages to update in case it exists.
     */
    where: p2p_messagesWhereUniqueInput
    /**
     * In case the p2p_messages found by the `where` argument doesn't exist, create a new p2p_messages with this data.
     */
    create: XOR<p2p_messagesCreateInput, p2p_messagesUncheckedCreateInput>
    /**
     * In case the p2p_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2p_messagesUpdateInput, p2p_messagesUncheckedUpdateInput>
  }

  /**
   * p2p_messages delete
   */
  export type p2p_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
    /**
     * Filter which p2p_messages to delete.
     */
    where: p2p_messagesWhereUniqueInput
  }

  /**
   * p2p_messages deleteMany
   */
  export type p2p_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_messages to delete
     */
    where?: p2p_messagesWhereInput
    /**
     * Limit how many p2p_messages to delete.
     */
    limit?: number
  }

  /**
   * p2p_messages without action
   */
  export type p2p_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_messages
     */
    select?: p2p_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_messages
     */
    omit?: p2p_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_messagesInclude<ExtArgs> | null
  }


  /**
   * Model p2p_disputes
   */

  export type AggregateP2p_disputes = {
    _count: P2p_disputesCountAggregateOutputType | null
    _min: P2p_disputesMinAggregateOutputType | null
    _max: P2p_disputesMaxAggregateOutputType | null
  }

  export type P2p_disputesMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    raised_by_user_id: string | null
    reason: string | null
    description: string | null
    status: $Enums.P2PDisputeStatus | null
    resolved_by_admin_id: string | null
    resolution_note: string | null
    resolved_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P2p_disputesMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    raised_by_user_id: string | null
    reason: string | null
    description: string | null
    status: $Enums.P2PDisputeStatus | null
    resolved_by_admin_id: string | null
    resolution_note: string | null
    resolved_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P2p_disputesCountAggregateOutputType = {
    id: number
    order_id: number
    raised_by_user_id: number
    reason: number
    description: number
    status: number
    resolved_by_admin_id: number
    resolution_note: number
    resolved_at: number
    attachments: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P2p_disputesMinAggregateInputType = {
    id?: true
    order_id?: true
    raised_by_user_id?: true
    reason?: true
    description?: true
    status?: true
    resolved_by_admin_id?: true
    resolution_note?: true
    resolved_at?: true
    created_at?: true
    updated_at?: true
  }

  export type P2p_disputesMaxAggregateInputType = {
    id?: true
    order_id?: true
    raised_by_user_id?: true
    reason?: true
    description?: true
    status?: true
    resolved_by_admin_id?: true
    resolution_note?: true
    resolved_at?: true
    created_at?: true
    updated_at?: true
  }

  export type P2p_disputesCountAggregateInputType = {
    id?: true
    order_id?: true
    raised_by_user_id?: true
    reason?: true
    description?: true
    status?: true
    resolved_by_admin_id?: true
    resolution_note?: true
    resolved_at?: true
    attachments?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P2p_disputesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_disputes to aggregate.
     */
    where?: p2p_disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_disputes to fetch.
     */
    orderBy?: p2p_disputesOrderByWithRelationInput | p2p_disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2p_disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2p_disputes
    **/
    _count?: true | P2p_disputesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2p_disputesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2p_disputesMaxAggregateInputType
  }

  export type GetP2p_disputesAggregateType<T extends P2p_disputesAggregateArgs> = {
        [P in keyof T & keyof AggregateP2p_disputes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2p_disputes[P]>
      : GetScalarType<T[P], AggregateP2p_disputes[P]>
  }




  export type p2p_disputesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_disputesWhereInput
    orderBy?: p2p_disputesOrderByWithAggregationInput | p2p_disputesOrderByWithAggregationInput[]
    by: P2p_disputesScalarFieldEnum[] | P2p_disputesScalarFieldEnum
    having?: p2p_disputesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2p_disputesCountAggregateInputType | true
    _min?: P2p_disputesMinAggregateInputType
    _max?: P2p_disputesMaxAggregateInputType
  }

  export type P2p_disputesGroupByOutputType = {
    id: string
    order_id: string
    raised_by_user_id: string
    reason: string | null
    description: string | null
    status: $Enums.P2PDisputeStatus
    resolved_by_admin_id: string | null
    resolution_note: string | null
    resolved_at: Date | null
    attachments: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: P2p_disputesCountAggregateOutputType | null
    _min: P2p_disputesMinAggregateOutputType | null
    _max: P2p_disputesMaxAggregateOutputType | null
  }

  type GetP2p_disputesGroupByPayload<T extends p2p_disputesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2p_disputesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2p_disputesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2p_disputesGroupByOutputType[P]>
            : GetScalarType<T[P], P2p_disputesGroupByOutputType[P]>
        }
      >
    >


  export type p2p_disputesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    raised_by_user_id?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    resolved_by_admin_id?: boolean
    resolution_note?: boolean
    resolved_at?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    raised_by?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_disputes"]>

  export type p2p_disputesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    raised_by_user_id?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    resolved_by_admin_id?: boolean
    resolution_note?: boolean
    resolved_at?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    raised_by?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_disputes"]>

  export type p2p_disputesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    raised_by_user_id?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    resolved_by_admin_id?: boolean
    resolution_note?: boolean
    resolved_at?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    raised_by?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_disputes"]>

  export type p2p_disputesSelectScalar = {
    id?: boolean
    order_id?: boolean
    raised_by_user_id?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    resolved_by_admin_id?: boolean
    resolution_note?: boolean
    resolved_at?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type p2p_disputesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_id" | "raised_by_user_id" | "reason" | "description" | "status" | "resolved_by_admin_id" | "resolution_note" | "resolved_at" | "attachments" | "created_at" | "updated_at", ExtArgs["result"]["p2p_disputes"]>
  export type p2p_disputesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    raised_by?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_disputesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    raised_by?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_disputesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    raised_by?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $p2p_disputesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2p_disputes"
    objects: {
      order: Prisma.$p2p_ordersPayload<ExtArgs>
      raised_by: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      raised_by_user_id: string
      reason: string | null
      description: string | null
      status: $Enums.P2PDisputeStatus
      resolved_by_admin_id: string | null
      resolution_note: string | null
      resolved_at: Date | null
      attachments: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["p2p_disputes"]>
    composites: {}
  }

  type p2p_disputesGetPayload<S extends boolean | null | undefined | p2p_disputesDefaultArgs> = $Result.GetResult<Prisma.$p2p_disputesPayload, S>

  type p2p_disputesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2p_disputesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2p_disputesCountAggregateInputType | true
    }

  export interface p2p_disputesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2p_disputes'], meta: { name: 'p2p_disputes' } }
    /**
     * Find zero or one P2p_disputes that matches the filter.
     * @param {p2p_disputesFindUniqueArgs} args - Arguments to find a P2p_disputes
     * @example
     * // Get one P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2p_disputesFindUniqueArgs>(args: SelectSubset<T, p2p_disputesFindUniqueArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2p_disputes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2p_disputesFindUniqueOrThrowArgs} args - Arguments to find a P2p_disputes
     * @example
     * // Get one P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2p_disputesFindUniqueOrThrowArgs>(args: SelectSubset<T, p2p_disputesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_disputesFindFirstArgs} args - Arguments to find a P2p_disputes
     * @example
     * // Get one P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2p_disputesFindFirstArgs>(args?: SelectSubset<T, p2p_disputesFindFirstArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_disputes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_disputesFindFirstOrThrowArgs} args - Arguments to find a P2p_disputes
     * @example
     * // Get one P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2p_disputesFindFirstOrThrowArgs>(args?: SelectSubset<T, p2p_disputesFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2p_disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_disputesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.findMany()
     * 
     * // Get first 10 P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2p_disputesWithIdOnly = await prisma.p2p_disputes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2p_disputesFindManyArgs>(args?: SelectSubset<T, p2p_disputesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2p_disputes.
     * @param {p2p_disputesCreateArgs} args - Arguments to create a P2p_disputes.
     * @example
     * // Create one P2p_disputes
     * const P2p_disputes = await prisma.p2p_disputes.create({
     *   data: {
     *     // ... data to create a P2p_disputes
     *   }
     * })
     * 
     */
    create<T extends p2p_disputesCreateArgs>(args: SelectSubset<T, p2p_disputesCreateArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2p_disputes.
     * @param {p2p_disputesCreateManyArgs} args - Arguments to create many P2p_disputes.
     * @example
     * // Create many P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2p_disputesCreateManyArgs>(args?: SelectSubset<T, p2p_disputesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2p_disputes and returns the data saved in the database.
     * @param {p2p_disputesCreateManyAndReturnArgs} args - Arguments to create many P2p_disputes.
     * @example
     * // Create many P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2p_disputes and only return the `id`
     * const p2p_disputesWithIdOnly = await prisma.p2p_disputes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2p_disputesCreateManyAndReturnArgs>(args?: SelectSubset<T, p2p_disputesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2p_disputes.
     * @param {p2p_disputesDeleteArgs} args - Arguments to delete one P2p_disputes.
     * @example
     * // Delete one P2p_disputes
     * const P2p_disputes = await prisma.p2p_disputes.delete({
     *   where: {
     *     // ... filter to delete one P2p_disputes
     *   }
     * })
     * 
     */
    delete<T extends p2p_disputesDeleteArgs>(args: SelectSubset<T, p2p_disputesDeleteArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2p_disputes.
     * @param {p2p_disputesUpdateArgs} args - Arguments to update one P2p_disputes.
     * @example
     * // Update one P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2p_disputesUpdateArgs>(args: SelectSubset<T, p2p_disputesUpdateArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2p_disputes.
     * @param {p2p_disputesDeleteManyArgs} args - Arguments to filter P2p_disputes to delete.
     * @example
     * // Delete a few P2p_disputes
     * const { count } = await prisma.p2p_disputes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2p_disputesDeleteManyArgs>(args?: SelectSubset<T, p2p_disputesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_disputesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2p_disputesUpdateManyArgs>(args: SelectSubset<T, p2p_disputesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_disputes and returns the data updated in the database.
     * @param {p2p_disputesUpdateManyAndReturnArgs} args - Arguments to update many P2p_disputes.
     * @example
     * // Update many P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2p_disputes and only return the `id`
     * const p2p_disputesWithIdOnly = await prisma.p2p_disputes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2p_disputesUpdateManyAndReturnArgs>(args: SelectSubset<T, p2p_disputesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2p_disputes.
     * @param {p2p_disputesUpsertArgs} args - Arguments to update or create a P2p_disputes.
     * @example
     * // Update or create a P2p_disputes
     * const p2p_disputes = await prisma.p2p_disputes.upsert({
     *   create: {
     *     // ... data to create a P2p_disputes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2p_disputes we want to update
     *   }
     * })
     */
    upsert<T extends p2p_disputesUpsertArgs>(args: SelectSubset<T, p2p_disputesUpsertArgs<ExtArgs>>): Prisma__p2p_disputesClient<$Result.GetResult<Prisma.$p2p_disputesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2p_disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_disputesCountArgs} args - Arguments to filter P2p_disputes to count.
     * @example
     * // Count the number of P2p_disputes
     * const count = await prisma.p2p_disputes.count({
     *   where: {
     *     // ... the filter for the P2p_disputes we want to count
     *   }
     * })
    **/
    count<T extends p2p_disputesCountArgs>(
      args?: Subset<T, p2p_disputesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2p_disputesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2p_disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2p_disputesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2p_disputesAggregateArgs>(args: Subset<T, P2p_disputesAggregateArgs>): Prisma.PrismaPromise<GetP2p_disputesAggregateType<T>>

    /**
     * Group by P2p_disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_disputesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2p_disputesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2p_disputesGroupByArgs['orderBy'] }
        : { orderBy?: p2p_disputesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2p_disputesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2p_disputesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2p_disputes model
   */
  readonly fields: p2p_disputesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2p_disputes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2p_disputesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends p2p_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, p2p_ordersDefaultArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raised_by<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2p_disputes model
   */
  interface p2p_disputesFieldRefs {
    readonly id: FieldRef<"p2p_disputes", 'String'>
    readonly order_id: FieldRef<"p2p_disputes", 'String'>
    readonly raised_by_user_id: FieldRef<"p2p_disputes", 'String'>
    readonly reason: FieldRef<"p2p_disputes", 'String'>
    readonly description: FieldRef<"p2p_disputes", 'String'>
    readonly status: FieldRef<"p2p_disputes", 'P2PDisputeStatus'>
    readonly resolved_by_admin_id: FieldRef<"p2p_disputes", 'String'>
    readonly resolution_note: FieldRef<"p2p_disputes", 'String'>
    readonly resolved_at: FieldRef<"p2p_disputes", 'DateTime'>
    readonly attachments: FieldRef<"p2p_disputes", 'Json'>
    readonly created_at: FieldRef<"p2p_disputes", 'DateTime'>
    readonly updated_at: FieldRef<"p2p_disputes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * p2p_disputes findUnique
   */
  export type p2p_disputesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_disputes to fetch.
     */
    where: p2p_disputesWhereUniqueInput
  }

  /**
   * p2p_disputes findUniqueOrThrow
   */
  export type p2p_disputesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_disputes to fetch.
     */
    where: p2p_disputesWhereUniqueInput
  }

  /**
   * p2p_disputes findFirst
   */
  export type p2p_disputesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_disputes to fetch.
     */
    where?: p2p_disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_disputes to fetch.
     */
    orderBy?: p2p_disputesOrderByWithRelationInput | p2p_disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_disputes.
     */
    cursor?: p2p_disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_disputes.
     */
    distinct?: P2p_disputesScalarFieldEnum | P2p_disputesScalarFieldEnum[]
  }

  /**
   * p2p_disputes findFirstOrThrow
   */
  export type p2p_disputesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_disputes to fetch.
     */
    where?: p2p_disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_disputes to fetch.
     */
    orderBy?: p2p_disputesOrderByWithRelationInput | p2p_disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_disputes.
     */
    cursor?: p2p_disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_disputes.
     */
    distinct?: P2p_disputesScalarFieldEnum | P2p_disputesScalarFieldEnum[]
  }

  /**
   * p2p_disputes findMany
   */
  export type p2p_disputesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * Filter, which p2p_disputes to fetch.
     */
    where?: p2p_disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_disputes to fetch.
     */
    orderBy?: p2p_disputesOrderByWithRelationInput | p2p_disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2p_disputes.
     */
    cursor?: p2p_disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_disputes.
     */
    skip?: number
    distinct?: P2p_disputesScalarFieldEnum | P2p_disputesScalarFieldEnum[]
  }

  /**
   * p2p_disputes create
   */
  export type p2p_disputesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * The data needed to create a p2p_disputes.
     */
    data: XOR<p2p_disputesCreateInput, p2p_disputesUncheckedCreateInput>
  }

  /**
   * p2p_disputes createMany
   */
  export type p2p_disputesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2p_disputes.
     */
    data: p2p_disputesCreateManyInput | p2p_disputesCreateManyInput[]
  }

  /**
   * p2p_disputes createManyAndReturn
   */
  export type p2p_disputesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * The data used to create many p2p_disputes.
     */
    data: p2p_disputesCreateManyInput | p2p_disputesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_disputes update
   */
  export type p2p_disputesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * The data needed to update a p2p_disputes.
     */
    data: XOR<p2p_disputesUpdateInput, p2p_disputesUncheckedUpdateInput>
    /**
     * Choose, which p2p_disputes to update.
     */
    where: p2p_disputesWhereUniqueInput
  }

  /**
   * p2p_disputes updateMany
   */
  export type p2p_disputesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2p_disputes.
     */
    data: XOR<p2p_disputesUpdateManyMutationInput, p2p_disputesUncheckedUpdateManyInput>
    /**
     * Filter which p2p_disputes to update
     */
    where?: p2p_disputesWhereInput
    /**
     * Limit how many p2p_disputes to update.
     */
    limit?: number
  }

  /**
   * p2p_disputes updateManyAndReturn
   */
  export type p2p_disputesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * The data used to update p2p_disputes.
     */
    data: XOR<p2p_disputesUpdateManyMutationInput, p2p_disputesUncheckedUpdateManyInput>
    /**
     * Filter which p2p_disputes to update
     */
    where?: p2p_disputesWhereInput
    /**
     * Limit how many p2p_disputes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_disputes upsert
   */
  export type p2p_disputesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * The filter to search for the p2p_disputes to update in case it exists.
     */
    where: p2p_disputesWhereUniqueInput
    /**
     * In case the p2p_disputes found by the `where` argument doesn't exist, create a new p2p_disputes with this data.
     */
    create: XOR<p2p_disputesCreateInput, p2p_disputesUncheckedCreateInput>
    /**
     * In case the p2p_disputes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2p_disputesUpdateInput, p2p_disputesUncheckedUpdateInput>
  }

  /**
   * p2p_disputes delete
   */
  export type p2p_disputesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
    /**
     * Filter which p2p_disputes to delete.
     */
    where: p2p_disputesWhereUniqueInput
  }

  /**
   * p2p_disputes deleteMany
   */
  export type p2p_disputesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_disputes to delete
     */
    where?: p2p_disputesWhereInput
    /**
     * Limit how many p2p_disputes to delete.
     */
    limit?: number
  }

  /**
   * p2p_disputes without action
   */
  export type p2p_disputesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_disputes
     */
    select?: p2p_disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_disputes
     */
    omit?: p2p_disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_disputesInclude<ExtArgs> | null
  }


  /**
   * Model p2p_ratings
   */

  export type AggregateP2p_ratings = {
    _count: P2p_ratingsCountAggregateOutputType | null
    _avg: P2p_ratingsAvgAggregateOutputType | null
    _sum: P2p_ratingsSumAggregateOutputType | null
    _min: P2p_ratingsMinAggregateOutputType | null
    _max: P2p_ratingsMaxAggregateOutputType | null
  }

  export type P2p_ratingsAvgAggregateOutputType = {
    stars: number | null
  }

  export type P2p_ratingsSumAggregateOutputType = {
    stars: number | null
  }

  export type P2p_ratingsMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    from_user_id: string | null
    to_user_id: string | null
    stars: number | null
    comment: string | null
    created_at: Date | null
  }

  export type P2p_ratingsMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    from_user_id: string | null
    to_user_id: string | null
    stars: number | null
    comment: string | null
    created_at: Date | null
  }

  export type P2p_ratingsCountAggregateOutputType = {
    id: number
    order_id: number
    from_user_id: number
    to_user_id: number
    stars: number
    comment: number
    created_at: number
    _all: number
  }


  export type P2p_ratingsAvgAggregateInputType = {
    stars?: true
  }

  export type P2p_ratingsSumAggregateInputType = {
    stars?: true
  }

  export type P2p_ratingsMinAggregateInputType = {
    id?: true
    order_id?: true
    from_user_id?: true
    to_user_id?: true
    stars?: true
    comment?: true
    created_at?: true
  }

  export type P2p_ratingsMaxAggregateInputType = {
    id?: true
    order_id?: true
    from_user_id?: true
    to_user_id?: true
    stars?: true
    comment?: true
    created_at?: true
  }

  export type P2p_ratingsCountAggregateInputType = {
    id?: true
    order_id?: true
    from_user_id?: true
    to_user_id?: true
    stars?: true
    comment?: true
    created_at?: true
    _all?: true
  }

  export type P2p_ratingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_ratings to aggregate.
     */
    where?: p2p_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_ratings to fetch.
     */
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2p_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2p_ratings
    **/
    _count?: true | P2p_ratingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P2p_ratingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P2p_ratingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2p_ratingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2p_ratingsMaxAggregateInputType
  }

  export type GetP2p_ratingsAggregateType<T extends P2p_ratingsAggregateArgs> = {
        [P in keyof T & keyof AggregateP2p_ratings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2p_ratings[P]>
      : GetScalarType<T[P], AggregateP2p_ratings[P]>
  }




  export type p2p_ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2p_ratingsWhereInput
    orderBy?: p2p_ratingsOrderByWithAggregationInput | p2p_ratingsOrderByWithAggregationInput[]
    by: P2p_ratingsScalarFieldEnum[] | P2p_ratingsScalarFieldEnum
    having?: p2p_ratingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2p_ratingsCountAggregateInputType | true
    _avg?: P2p_ratingsAvgAggregateInputType
    _sum?: P2p_ratingsSumAggregateInputType
    _min?: P2p_ratingsMinAggregateInputType
    _max?: P2p_ratingsMaxAggregateInputType
  }

  export type P2p_ratingsGroupByOutputType = {
    id: string
    order_id: string
    from_user_id: string
    to_user_id: string
    stars: number
    comment: string | null
    created_at: Date
    _count: P2p_ratingsCountAggregateOutputType | null
    _avg: P2p_ratingsAvgAggregateOutputType | null
    _sum: P2p_ratingsSumAggregateOutputType | null
    _min: P2p_ratingsMinAggregateOutputType | null
    _max: P2p_ratingsMaxAggregateOutputType | null
  }

  type GetP2p_ratingsGroupByPayload<T extends p2p_ratingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2p_ratingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2p_ratingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2p_ratingsGroupByOutputType[P]>
            : GetScalarType<T[P], P2p_ratingsGroupByOutputType[P]>
        }
      >
    >


  export type p2p_ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    stars?: boolean
    comment?: boolean
    created_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    from_user?: boolean | usersDefaultArgs<ExtArgs>
    to_user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_ratings"]>

  export type p2p_ratingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    stars?: boolean
    comment?: boolean
    created_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    from_user?: boolean | usersDefaultArgs<ExtArgs>
    to_user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_ratings"]>

  export type p2p_ratingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    stars?: boolean
    comment?: boolean
    created_at?: boolean
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    from_user?: boolean | usersDefaultArgs<ExtArgs>
    to_user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["p2p_ratings"]>

  export type p2p_ratingsSelectScalar = {
    id?: boolean
    order_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    stars?: boolean
    comment?: boolean
    created_at?: boolean
  }

  export type p2p_ratingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_id" | "from_user_id" | "to_user_id" | "stars" | "comment" | "created_at", ExtArgs["result"]["p2p_ratings"]>
  export type p2p_ratingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    from_user?: boolean | usersDefaultArgs<ExtArgs>
    to_user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_ratingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    from_user?: boolean | usersDefaultArgs<ExtArgs>
    to_user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type p2p_ratingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | p2p_ordersDefaultArgs<ExtArgs>
    from_user?: boolean | usersDefaultArgs<ExtArgs>
    to_user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $p2p_ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2p_ratings"
    objects: {
      order: Prisma.$p2p_ordersPayload<ExtArgs>
      from_user: Prisma.$usersPayload<ExtArgs>
      to_user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      from_user_id: string
      to_user_id: string
      stars: number
      comment: string | null
      created_at: Date
    }, ExtArgs["result"]["p2p_ratings"]>
    composites: {}
  }

  type p2p_ratingsGetPayload<S extends boolean | null | undefined | p2p_ratingsDefaultArgs> = $Result.GetResult<Prisma.$p2p_ratingsPayload, S>

  type p2p_ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2p_ratingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2p_ratingsCountAggregateInputType | true
    }

  export interface p2p_ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2p_ratings'], meta: { name: 'p2p_ratings' } }
    /**
     * Find zero or one P2p_ratings that matches the filter.
     * @param {p2p_ratingsFindUniqueArgs} args - Arguments to find a P2p_ratings
     * @example
     * // Get one P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2p_ratingsFindUniqueArgs>(args: SelectSubset<T, p2p_ratingsFindUniqueArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2p_ratings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2p_ratingsFindUniqueOrThrowArgs} args - Arguments to find a P2p_ratings
     * @example
     * // Get one P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2p_ratingsFindUniqueOrThrowArgs>(args: SelectSubset<T, p2p_ratingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ratingsFindFirstArgs} args - Arguments to find a P2p_ratings
     * @example
     * // Get one P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2p_ratingsFindFirstArgs>(args?: SelectSubset<T, p2p_ratingsFindFirstArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2p_ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ratingsFindFirstOrThrowArgs} args - Arguments to find a P2p_ratings
     * @example
     * // Get one P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2p_ratingsFindFirstOrThrowArgs>(args?: SelectSubset<T, p2p_ratingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2p_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ratingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.findMany()
     * 
     * // Get first 10 P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2p_ratingsWithIdOnly = await prisma.p2p_ratings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2p_ratingsFindManyArgs>(args?: SelectSubset<T, p2p_ratingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2p_ratings.
     * @param {p2p_ratingsCreateArgs} args - Arguments to create a P2p_ratings.
     * @example
     * // Create one P2p_ratings
     * const P2p_ratings = await prisma.p2p_ratings.create({
     *   data: {
     *     // ... data to create a P2p_ratings
     *   }
     * })
     * 
     */
    create<T extends p2p_ratingsCreateArgs>(args: SelectSubset<T, p2p_ratingsCreateArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2p_ratings.
     * @param {p2p_ratingsCreateManyArgs} args - Arguments to create many P2p_ratings.
     * @example
     * // Create many P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2p_ratingsCreateManyArgs>(args?: SelectSubset<T, p2p_ratingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2p_ratings and returns the data saved in the database.
     * @param {p2p_ratingsCreateManyAndReturnArgs} args - Arguments to create many P2p_ratings.
     * @example
     * // Create many P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2p_ratings and only return the `id`
     * const p2p_ratingsWithIdOnly = await prisma.p2p_ratings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2p_ratingsCreateManyAndReturnArgs>(args?: SelectSubset<T, p2p_ratingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2p_ratings.
     * @param {p2p_ratingsDeleteArgs} args - Arguments to delete one P2p_ratings.
     * @example
     * // Delete one P2p_ratings
     * const P2p_ratings = await prisma.p2p_ratings.delete({
     *   where: {
     *     // ... filter to delete one P2p_ratings
     *   }
     * })
     * 
     */
    delete<T extends p2p_ratingsDeleteArgs>(args: SelectSubset<T, p2p_ratingsDeleteArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2p_ratings.
     * @param {p2p_ratingsUpdateArgs} args - Arguments to update one P2p_ratings.
     * @example
     * // Update one P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2p_ratingsUpdateArgs>(args: SelectSubset<T, p2p_ratingsUpdateArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2p_ratings.
     * @param {p2p_ratingsDeleteManyArgs} args - Arguments to filter P2p_ratings to delete.
     * @example
     * // Delete a few P2p_ratings
     * const { count } = await prisma.p2p_ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2p_ratingsDeleteManyArgs>(args?: SelectSubset<T, p2p_ratingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ratingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2p_ratingsUpdateManyArgs>(args: SelectSubset<T, p2p_ratingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2p_ratings and returns the data updated in the database.
     * @param {p2p_ratingsUpdateManyAndReturnArgs} args - Arguments to update many P2p_ratings.
     * @example
     * // Update many P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2p_ratings and only return the `id`
     * const p2p_ratingsWithIdOnly = await prisma.p2p_ratings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2p_ratingsUpdateManyAndReturnArgs>(args: SelectSubset<T, p2p_ratingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2p_ratings.
     * @param {p2p_ratingsUpsertArgs} args - Arguments to update or create a P2p_ratings.
     * @example
     * // Update or create a P2p_ratings
     * const p2p_ratings = await prisma.p2p_ratings.upsert({
     *   create: {
     *     // ... data to create a P2p_ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2p_ratings we want to update
     *   }
     * })
     */
    upsert<T extends p2p_ratingsUpsertArgs>(args: SelectSubset<T, p2p_ratingsUpsertArgs<ExtArgs>>): Prisma__p2p_ratingsClient<$Result.GetResult<Prisma.$p2p_ratingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2p_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ratingsCountArgs} args - Arguments to filter P2p_ratings to count.
     * @example
     * // Count the number of P2p_ratings
     * const count = await prisma.p2p_ratings.count({
     *   where: {
     *     // ... the filter for the P2p_ratings we want to count
     *   }
     * })
    **/
    count<T extends p2p_ratingsCountArgs>(
      args?: Subset<T, p2p_ratingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2p_ratingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2p_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2p_ratingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2p_ratingsAggregateArgs>(args: Subset<T, P2p_ratingsAggregateArgs>): Prisma.PrismaPromise<GetP2p_ratingsAggregateType<T>>

    /**
     * Group by P2p_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2p_ratingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2p_ratingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2p_ratingsGroupByArgs['orderBy'] }
        : { orderBy?: p2p_ratingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2p_ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2p_ratingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2p_ratings model
   */
  readonly fields: p2p_ratingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2p_ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2p_ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends p2p_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, p2p_ordersDefaultArgs<ExtArgs>>): Prisma__p2p_ordersClient<$Result.GetResult<Prisma.$p2p_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    from_user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    to_user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2p_ratings model
   */
  interface p2p_ratingsFieldRefs {
    readonly id: FieldRef<"p2p_ratings", 'String'>
    readonly order_id: FieldRef<"p2p_ratings", 'String'>
    readonly from_user_id: FieldRef<"p2p_ratings", 'String'>
    readonly to_user_id: FieldRef<"p2p_ratings", 'String'>
    readonly stars: FieldRef<"p2p_ratings", 'Int'>
    readonly comment: FieldRef<"p2p_ratings", 'String'>
    readonly created_at: FieldRef<"p2p_ratings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * p2p_ratings findUnique
   */
  export type p2p_ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_ratings to fetch.
     */
    where: p2p_ratingsWhereUniqueInput
  }

  /**
   * p2p_ratings findUniqueOrThrow
   */
  export type p2p_ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_ratings to fetch.
     */
    where: p2p_ratingsWhereUniqueInput
  }

  /**
   * p2p_ratings findFirst
   */
  export type p2p_ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_ratings to fetch.
     */
    where?: p2p_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_ratings to fetch.
     */
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_ratings.
     */
    cursor?: p2p_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_ratings.
     */
    distinct?: P2p_ratingsScalarFieldEnum | P2p_ratingsScalarFieldEnum[]
  }

  /**
   * p2p_ratings findFirstOrThrow
   */
  export type p2p_ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_ratings to fetch.
     */
    where?: p2p_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_ratings to fetch.
     */
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2p_ratings.
     */
    cursor?: p2p_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2p_ratings.
     */
    distinct?: P2p_ratingsScalarFieldEnum | P2p_ratingsScalarFieldEnum[]
  }

  /**
   * p2p_ratings findMany
   */
  export type p2p_ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which p2p_ratings to fetch.
     */
    where?: p2p_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2p_ratings to fetch.
     */
    orderBy?: p2p_ratingsOrderByWithRelationInput | p2p_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2p_ratings.
     */
    cursor?: p2p_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2p_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2p_ratings.
     */
    skip?: number
    distinct?: P2p_ratingsScalarFieldEnum | P2p_ratingsScalarFieldEnum[]
  }

  /**
   * p2p_ratings create
   */
  export type p2p_ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * The data needed to create a p2p_ratings.
     */
    data: XOR<p2p_ratingsCreateInput, p2p_ratingsUncheckedCreateInput>
  }

  /**
   * p2p_ratings createMany
   */
  export type p2p_ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2p_ratings.
     */
    data: p2p_ratingsCreateManyInput | p2p_ratingsCreateManyInput[]
  }

  /**
   * p2p_ratings createManyAndReturn
   */
  export type p2p_ratingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * The data used to create many p2p_ratings.
     */
    data: p2p_ratingsCreateManyInput | p2p_ratingsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_ratings update
   */
  export type p2p_ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * The data needed to update a p2p_ratings.
     */
    data: XOR<p2p_ratingsUpdateInput, p2p_ratingsUncheckedUpdateInput>
    /**
     * Choose, which p2p_ratings to update.
     */
    where: p2p_ratingsWhereUniqueInput
  }

  /**
   * p2p_ratings updateMany
   */
  export type p2p_ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2p_ratings.
     */
    data: XOR<p2p_ratingsUpdateManyMutationInput, p2p_ratingsUncheckedUpdateManyInput>
    /**
     * Filter which p2p_ratings to update
     */
    where?: p2p_ratingsWhereInput
    /**
     * Limit how many p2p_ratings to update.
     */
    limit?: number
  }

  /**
   * p2p_ratings updateManyAndReturn
   */
  export type p2p_ratingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * The data used to update p2p_ratings.
     */
    data: XOR<p2p_ratingsUpdateManyMutationInput, p2p_ratingsUncheckedUpdateManyInput>
    /**
     * Filter which p2p_ratings to update
     */
    where?: p2p_ratingsWhereInput
    /**
     * Limit how many p2p_ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2p_ratings upsert
   */
  export type p2p_ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * The filter to search for the p2p_ratings to update in case it exists.
     */
    where: p2p_ratingsWhereUniqueInput
    /**
     * In case the p2p_ratings found by the `where` argument doesn't exist, create a new p2p_ratings with this data.
     */
    create: XOR<p2p_ratingsCreateInput, p2p_ratingsUncheckedCreateInput>
    /**
     * In case the p2p_ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2p_ratingsUpdateInput, p2p_ratingsUncheckedUpdateInput>
  }

  /**
   * p2p_ratings delete
   */
  export type p2p_ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
    /**
     * Filter which p2p_ratings to delete.
     */
    where: p2p_ratingsWhereUniqueInput
  }

  /**
   * p2p_ratings deleteMany
   */
  export type p2p_ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2p_ratings to delete
     */
    where?: p2p_ratingsWhereInput
    /**
     * Limit how many p2p_ratings to delete.
     */
    limit?: number
  }

  /**
   * p2p_ratings without action
   */
  export type p2p_ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2p_ratings
     */
    select?: p2p_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2p_ratings
     */
    omit?: p2p_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2p_ratingsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Currency_pairsScalarFieldEnum: {
    id: 'id',
    base: 'base',
    quote: 'quote',
    symbol: 'symbol',
    display: 'display',
    provider: 'provider',
    provider_symbol: 'provider_symbol',
    price_decimals: 'price_decimals',
    status: 'status',
    payout: 'payout',
    latest_price: 'latest_price',
    last_updated: 'last_updated',
    isDeleted: 'isDeleted',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Currency_pairsScalarFieldEnum = (typeof Currency_pairsScalarFieldEnum)[keyof typeof Currency_pairsScalarFieldEnum]


  export const Forex_candlesScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    interval: 'interval',
    time: 'time',
    open: 'open',
    high: 'high',
    low: 'low',
    close: 'close',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Forex_candlesScalarFieldEnum = (typeof Forex_candlesScalarFieldEnum)[keyof typeof Forex_candlesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password_hash: 'password_hash',
    phone: 'phone',
    country: 'country',
    date_of_birth: 'date_of_birth',
    address: 'address',
    city: 'city',
    postal_code: 'postal_code',
    balance: 'balance',
    is_verified: 'is_verified',
    is_admin: 'is_admin',
    is_suspended: 'is_suspended',
    avatar_url: 'avatar_url',
    created_at: 'created_at',
    updated_at: 'updated_at',
    demo_balance: 'demo_balance'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const DepositsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    amount: 'amount',
    method: 'method',
    status: 'status',
    created_at: 'created_at'
  };

  export type DepositsScalarFieldEnum = (typeof DepositsScalarFieldEnum)[keyof typeof DepositsScalarFieldEnum]


  export const WithdrawalsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    amount: 'amount',
    method: 'method',
    account_info: 'account_info',
    status: 'status',
    created_at: 'created_at'
  };

  export type WithdrawalsScalarFieldEnum = (typeof WithdrawalsScalarFieldEnum)[keyof typeof WithdrawalsScalarFieldEnum]


  export const TradesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    symbol: 'symbol',
    amount: 'amount',
    direction: 'direction',
    open_time: 'open_time',
    close_time: 'close_time',
    result: 'result',
    status: 'status',
    entry_price: 'entry_price',
    payout: 'payout',
    created_at: 'created_at',
    updated_at: 'updated_at',
    account_type: 'account_type'
  };

  export type TradesScalarFieldEnum = (typeof TradesScalarFieldEnum)[keyof typeof TradesScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    amount: 'amount',
    rank: 'rank',
    updated_at: 'updated_at'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const TournamentsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    prize_pool: 'prize_pool',
    entry_fee: 'entry_fee',
    participants: 'participants',
    duration: 'duration',
    status: 'status',
    created_at: 'created_at'
  };

  export type TournamentsScalarFieldEnum = (typeof TournamentsScalarFieldEnum)[keyof typeof TournamentsScalarFieldEnum]


  export const Support_messagesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    created_at: 'created_at'
  };

  export type Support_messagesScalarFieldEnum = (typeof Support_messagesScalarFieldEnum)[keyof typeof Support_messagesScalarFieldEnum]


  export const Chat_messagesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    sender: 'sender',
    message: 'message',
    time: 'time'
  };

  export type Chat_messagesScalarFieldEnum = (typeof Chat_messagesScalarFieldEnum)[keyof typeof Chat_messagesScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    notifications: 'notifications',
    private: 'private'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Crypto_assetsScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    network: 'network',
    display_name: 'display_name',
    contract: 'contract',
    decimals: 'decimals',
    min_deposit: 'min_deposit',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Crypto_assetsScalarFieldEnum = (typeof Crypto_assetsScalarFieldEnum)[keyof typeof Crypto_assetsScalarFieldEnum]


  export const Deposit_sessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    crypto_asset_id: 'crypto_asset_id',
    address: 'address',
    derivation_path: 'derivation_path',
    memo_tag: 'memo_tag',
    amount_expected: 'amount_expected',
    fiat_locked_usd: 'fiat_locked_usd',
    rate_source: 'rate_source',
    status: 'status',
    tx_hash: 'tx_hash',
    detected_amount: 'detected_amount',
    confirmations: 'confirmations',
    min_confirmations: 'min_confirmations',
    is_late: 'is_late',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Deposit_sessionsScalarFieldEnum = (typeof Deposit_sessionsScalarFieldEnum)[keyof typeof Deposit_sessionsScalarFieldEnum]


  export const Wallet_ledgerScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    asset: 'asset',
    amount: 'amount',
    meta: 'meta',
    created_at: 'created_at'
  };

  export type Wallet_ledgerScalarFieldEnum = (typeof Wallet_ledgerScalarFieldEnum)[keyof typeof Wallet_ledgerScalarFieldEnum]


  export const Payment_method_templatesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    fields: 'fields',
    currency: 'currency',
    country: 'country',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Payment_method_templatesScalarFieldEnum = (typeof Payment_method_templatesScalarFieldEnum)[keyof typeof Payment_method_templatesScalarFieldEnum]


  export const P2p_offersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    side: 'side',
    asset_symbol: 'asset_symbol',
    crypto_asset_id: 'crypto_asset_id',
    fiat_currency: 'fiat_currency',
    price_type: 'price_type',
    fixed_price: 'fixed_price',
    margin_percent: 'margin_percent',
    min_amount_asset: 'min_amount_asset',
    max_amount_asset: 'max_amount_asset',
    min_limit_fiat: 'min_limit_fiat',
    max_limit_fiat: 'max_limit_fiat',
    terms: 'terms',
    auto_reply: 'auto_reply',
    status: 'status',
    total_trades: 'total_trades',
    completion_rate: 'completion_rate',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P2p_offersScalarFieldEnum = (typeof P2p_offersScalarFieldEnum)[keyof typeof P2p_offersScalarFieldEnum]


  export const User_payment_methodsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    label: 'label',
    details: 'details',
    is_verified: 'is_verified',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_payment_methodsScalarFieldEnum = (typeof User_payment_methodsScalarFieldEnum)[keyof typeof User_payment_methodsScalarFieldEnum]


  export const P2p_offer_payment_methodsScalarFieldEnum: {
    id: 'id',
    offer_id: 'offer_id',
    payment_method_id: 'payment_method_id'
  };

  export type P2p_offer_payment_methodsScalarFieldEnum = (typeof P2p_offer_payment_methodsScalarFieldEnum)[keyof typeof P2p_offer_payment_methodsScalarFieldEnum]


  export const P2p_ordersScalarFieldEnum: {
    id: 'id',
    offer_id: 'offer_id',
    maker_id: 'maker_id',
    taker_id: 'taker_id',
    side: 'side',
    asset_symbol: 'asset_symbol',
    fiat_currency: 'fiat_currency',
    price: 'price',
    amount_asset: 'amount_asset',
    amount_fiat: 'amount_fiat',
    status: 'status',
    escrow_held: 'escrow_held',
    escrow_ledger_id: 'escrow_ledger_id',
    reference_code: 'reference_code',
    meta: 'meta',
    expires_at: 'expires_at',
    paid_at: 'paid_at',
    released_at: 'released_at',
    canceled_at: 'canceled_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P2p_ordersScalarFieldEnum = (typeof P2p_ordersScalarFieldEnum)[keyof typeof P2p_ordersScalarFieldEnum]


  export const P2p_messagesScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    sender_id: 'sender_id',
    message: 'message',
    attachments: 'attachments',
    created_at: 'created_at'
  };

  export type P2p_messagesScalarFieldEnum = (typeof P2p_messagesScalarFieldEnum)[keyof typeof P2p_messagesScalarFieldEnum]


  export const P2p_disputesScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    raised_by_user_id: 'raised_by_user_id',
    reason: 'reason',
    description: 'description',
    status: 'status',
    resolved_by_admin_id: 'resolved_by_admin_id',
    resolution_note: 'resolution_note',
    resolved_at: 'resolved_at',
    attachments: 'attachments',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P2p_disputesScalarFieldEnum = (typeof P2p_disputesScalarFieldEnum)[keyof typeof P2p_disputesScalarFieldEnum]


  export const P2p_ratingsScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    from_user_id: 'from_user_id',
    to_user_id: 'to_user_id',
    stars: 'stars',
    comment: 'comment',
    created_at: 'created_at'
  };

  export type P2p_ratingsScalarFieldEnum = (typeof P2p_ratingsScalarFieldEnum)[keyof typeof P2p_ratingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'PairStatus'
   */
  export type EnumPairStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PairStatus'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DepositSessionStatus'
   */
  export type EnumDepositSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositSessionStatus'>
    


  /**
   * Reference to a field of type 'LedgerType'
   */
  export type EnumLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerType'>
    


  /**
   * Reference to a field of type 'PaymentMethodType'
   */
  export type EnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType'>
    


  /**
   * Reference to a field of type 'P2POrderSide'
   */
  export type EnumP2POrderSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'P2POrderSide'>
    


  /**
   * Reference to a field of type 'P2POfferStatus'
   */
  export type EnumP2POfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'P2POfferStatus'>
    


  /**
   * Reference to a field of type 'P2PTradeStatus'
   */
  export type EnumP2PTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'P2PTradeStatus'>
    


  /**
   * Reference to a field of type 'P2PDisputeStatus'
   */
  export type EnumP2PDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'P2PDisputeStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type currency_pairsWhereInput = {
    AND?: currency_pairsWhereInput | currency_pairsWhereInput[]
    OR?: currency_pairsWhereInput[]
    NOT?: currency_pairsWhereInput | currency_pairsWhereInput[]
    id?: StringFilter<"currency_pairs"> | string
    base?: StringFilter<"currency_pairs"> | string
    quote?: StringFilter<"currency_pairs"> | string
    symbol?: StringFilter<"currency_pairs"> | string
    display?: StringNullableFilter<"currency_pairs"> | string | null
    provider?: StringNullableFilter<"currency_pairs"> | string | null
    provider_symbol?: StringNullableFilter<"currency_pairs"> | string | null
    price_decimals?: IntNullableFilter<"currency_pairs"> | number | null
    status?: EnumPairStatusFilter<"currency_pairs"> | $Enums.PairStatus
    payout?: IntNullableFilter<"currency_pairs"> | number | null
    latest_price?: DecimalNullableFilter<"currency_pairs"> | Decimal | DecimalJsLike | number | string | null
    last_updated?: DateTimeNullableFilter<"currency_pairs"> | Date | string | null
    isDeleted?: BoolFilter<"currency_pairs"> | boolean
    created_at?: DateTimeFilter<"currency_pairs"> | Date | string
    updated_at?: DateTimeFilter<"currency_pairs"> | Date | string
  }

  export type currency_pairsOrderByWithRelationInput = {
    id?: SortOrder
    base?: SortOrder
    quote?: SortOrder
    symbol?: SortOrder
    display?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    provider_symbol?: SortOrderInput | SortOrder
    price_decimals?: SortOrderInput | SortOrder
    status?: SortOrder
    payout?: SortOrderInput | SortOrder
    latest_price?: SortOrderInput | SortOrder
    last_updated?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currency_pairsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol?: string
    AND?: currency_pairsWhereInput | currency_pairsWhereInput[]
    OR?: currency_pairsWhereInput[]
    NOT?: currency_pairsWhereInput | currency_pairsWhereInput[]
    base?: StringFilter<"currency_pairs"> | string
    quote?: StringFilter<"currency_pairs"> | string
    display?: StringNullableFilter<"currency_pairs"> | string | null
    provider?: StringNullableFilter<"currency_pairs"> | string | null
    provider_symbol?: StringNullableFilter<"currency_pairs"> | string | null
    price_decimals?: IntNullableFilter<"currency_pairs"> | number | null
    status?: EnumPairStatusFilter<"currency_pairs"> | $Enums.PairStatus
    payout?: IntNullableFilter<"currency_pairs"> | number | null
    latest_price?: DecimalNullableFilter<"currency_pairs"> | Decimal | DecimalJsLike | number | string | null
    last_updated?: DateTimeNullableFilter<"currency_pairs"> | Date | string | null
    isDeleted?: BoolFilter<"currency_pairs"> | boolean
    created_at?: DateTimeFilter<"currency_pairs"> | Date | string
    updated_at?: DateTimeFilter<"currency_pairs"> | Date | string
  }, "id" | "symbol">

  export type currency_pairsOrderByWithAggregationInput = {
    id?: SortOrder
    base?: SortOrder
    quote?: SortOrder
    symbol?: SortOrder
    display?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    provider_symbol?: SortOrderInput | SortOrder
    price_decimals?: SortOrderInput | SortOrder
    status?: SortOrder
    payout?: SortOrderInput | SortOrder
    latest_price?: SortOrderInput | SortOrder
    last_updated?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: currency_pairsCountOrderByAggregateInput
    _avg?: currency_pairsAvgOrderByAggregateInput
    _max?: currency_pairsMaxOrderByAggregateInput
    _min?: currency_pairsMinOrderByAggregateInput
    _sum?: currency_pairsSumOrderByAggregateInput
  }

  export type currency_pairsScalarWhereWithAggregatesInput = {
    AND?: currency_pairsScalarWhereWithAggregatesInput | currency_pairsScalarWhereWithAggregatesInput[]
    OR?: currency_pairsScalarWhereWithAggregatesInput[]
    NOT?: currency_pairsScalarWhereWithAggregatesInput | currency_pairsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"currency_pairs"> | string
    base?: StringWithAggregatesFilter<"currency_pairs"> | string
    quote?: StringWithAggregatesFilter<"currency_pairs"> | string
    symbol?: StringWithAggregatesFilter<"currency_pairs"> | string
    display?: StringNullableWithAggregatesFilter<"currency_pairs"> | string | null
    provider?: StringNullableWithAggregatesFilter<"currency_pairs"> | string | null
    provider_symbol?: StringNullableWithAggregatesFilter<"currency_pairs"> | string | null
    price_decimals?: IntNullableWithAggregatesFilter<"currency_pairs"> | number | null
    status?: EnumPairStatusWithAggregatesFilter<"currency_pairs"> | $Enums.PairStatus
    payout?: IntNullableWithAggregatesFilter<"currency_pairs"> | number | null
    latest_price?: DecimalNullableWithAggregatesFilter<"currency_pairs"> | Decimal | DecimalJsLike | number | string | null
    last_updated?: DateTimeNullableWithAggregatesFilter<"currency_pairs"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"currency_pairs"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"currency_pairs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"currency_pairs"> | Date | string
  }

  export type forex_candlesWhereInput = {
    AND?: forex_candlesWhereInput | forex_candlesWhereInput[]
    OR?: forex_candlesWhereInput[]
    NOT?: forex_candlesWhereInput | forex_candlesWhereInput[]
    id?: StringFilter<"forex_candles"> | string
    symbol?: StringFilter<"forex_candles"> | string
    interval?: StringFilter<"forex_candles"> | string
    time?: DateTimeFilter<"forex_candles"> | Date | string
    open?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    high?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    low?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    close?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"forex_candles"> | Date | string
    updated_at?: DateTimeFilter<"forex_candles"> | Date | string
  }

  export type forex_candlesOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    interval?: SortOrder
    time?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type forex_candlesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol_interval_time?: forex_candlesSymbolIntervalTimeCompoundUniqueInput
    AND?: forex_candlesWhereInput | forex_candlesWhereInput[]
    OR?: forex_candlesWhereInput[]
    NOT?: forex_candlesWhereInput | forex_candlesWhereInput[]
    symbol?: StringFilter<"forex_candles"> | string
    interval?: StringFilter<"forex_candles"> | string
    time?: DateTimeFilter<"forex_candles"> | Date | string
    open?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    high?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    low?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    close?: DecimalFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"forex_candles"> | Date | string
    updated_at?: DateTimeFilter<"forex_candles"> | Date | string
  }, "id" | "symbol_interval_time">

  export type forex_candlesOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    interval?: SortOrder
    time?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: forex_candlesCountOrderByAggregateInput
    _avg?: forex_candlesAvgOrderByAggregateInput
    _max?: forex_candlesMaxOrderByAggregateInput
    _min?: forex_candlesMinOrderByAggregateInput
    _sum?: forex_candlesSumOrderByAggregateInput
  }

  export type forex_candlesScalarWhereWithAggregatesInput = {
    AND?: forex_candlesScalarWhereWithAggregatesInput | forex_candlesScalarWhereWithAggregatesInput[]
    OR?: forex_candlesScalarWhereWithAggregatesInput[]
    NOT?: forex_candlesScalarWhereWithAggregatesInput | forex_candlesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"forex_candles"> | string
    symbol?: StringWithAggregatesFilter<"forex_candles"> | string
    interval?: StringWithAggregatesFilter<"forex_candles"> | string
    time?: DateTimeWithAggregatesFilter<"forex_candles"> | Date | string
    open?: DecimalWithAggregatesFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    high?: DecimalWithAggregatesFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    low?: DecimalWithAggregatesFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    close?: DecimalWithAggregatesFilter<"forex_candles"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"forex_candles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"forex_candles"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    email?: StringFilter<"users"> | string
    password_hash?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    country?: StringNullableFilter<"users"> | string | null
    date_of_birth?: StringNullableFilter<"users"> | string | null
    address?: StringNullableFilter<"users"> | string | null
    city?: StringNullableFilter<"users"> | string | null
    postal_code?: StringNullableFilter<"users"> | string | null
    balance?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFilter<"users"> | boolean
    is_admin?: BoolFilter<"users"> | boolean
    is_suspended?: BoolFilter<"users"> | boolean
    avatar_url?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    demo_balance?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    chat_messages?: Chat_messagesListRelationFilter
    deposits?: DepositsListRelationFilter
    leaderboard?: LeaderboardListRelationFilter
    settings?: SettingsListRelationFilter
    support_messages?: Support_messagesListRelationFilter
    trades?: TradesListRelationFilter
    withdrawals?: WithdrawalsListRelationFilter
    deposit_sessions?: Deposit_sessionsListRelationFilter
    wallet_ledger?: Wallet_ledgerListRelationFilter
    p2p_offers?: P2p_offersListRelationFilter
    user_payment_methods?: User_payment_methodsListRelationFilter
    p2p_maker_orders?: P2p_ordersListRelationFilter
    p2p_taker_orders?: P2p_ordersListRelationFilter
    p2p_messages_sent?: P2p_messagesListRelationFilter
    p2p_disputes_raised?: P2p_disputesListRelationFilter
    p2p_ratings_from?: P2p_ratingsListRelationFilter
    p2p_ratings_to?: P2p_ratingsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    is_admin?: SortOrder
    is_suspended?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    demo_balance?: SortOrderInput | SortOrder
    chat_messages?: chat_messagesOrderByRelationAggregateInput
    deposits?: depositsOrderByRelationAggregateInput
    leaderboard?: leaderboardOrderByRelationAggregateInput
    settings?: settingsOrderByRelationAggregateInput
    support_messages?: support_messagesOrderByRelationAggregateInput
    trades?: tradesOrderByRelationAggregateInput
    withdrawals?: withdrawalsOrderByRelationAggregateInput
    deposit_sessions?: deposit_sessionsOrderByRelationAggregateInput
    wallet_ledger?: wallet_ledgerOrderByRelationAggregateInput
    p2p_offers?: p2p_offersOrderByRelationAggregateInput
    user_payment_methods?: user_payment_methodsOrderByRelationAggregateInput
    p2p_maker_orders?: p2p_ordersOrderByRelationAggregateInput
    p2p_taker_orders?: p2p_ordersOrderByRelationAggregateInput
    p2p_messages_sent?: p2p_messagesOrderByRelationAggregateInput
    p2p_disputes_raised?: p2p_disputesOrderByRelationAggregateInput
    p2p_ratings_from?: p2p_ratingsOrderByRelationAggregateInput
    p2p_ratings_to?: p2p_ratingsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringNullableFilter<"users"> | string | null
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    password_hash?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    country?: StringNullableFilter<"users"> | string | null
    date_of_birth?: StringNullableFilter<"users"> | string | null
    address?: StringNullableFilter<"users"> | string | null
    city?: StringNullableFilter<"users"> | string | null
    postal_code?: StringNullableFilter<"users"> | string | null
    balance?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFilter<"users"> | boolean
    is_admin?: BoolFilter<"users"> | boolean
    is_suspended?: BoolFilter<"users"> | boolean
    avatar_url?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    demo_balance?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    chat_messages?: Chat_messagesListRelationFilter
    deposits?: DepositsListRelationFilter
    leaderboard?: LeaderboardListRelationFilter
    settings?: SettingsListRelationFilter
    support_messages?: Support_messagesListRelationFilter
    trades?: TradesListRelationFilter
    withdrawals?: WithdrawalsListRelationFilter
    deposit_sessions?: Deposit_sessionsListRelationFilter
    wallet_ledger?: Wallet_ledgerListRelationFilter
    p2p_offers?: P2p_offersListRelationFilter
    user_payment_methods?: User_payment_methodsListRelationFilter
    p2p_maker_orders?: P2p_ordersListRelationFilter
    p2p_taker_orders?: P2p_ordersListRelationFilter
    p2p_messages_sent?: P2p_messagesListRelationFilter
    p2p_disputes_raised?: P2p_disputesListRelationFilter
    p2p_ratings_from?: P2p_ratingsListRelationFilter
    p2p_ratings_to?: P2p_ratingsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    is_admin?: SortOrder
    is_suspended?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    demo_balance?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    country?: StringNullableWithAggregatesFilter<"users"> | string | null
    date_of_birth?: StringNullableWithAggregatesFilter<"users"> | string | null
    address?: StringNullableWithAggregatesFilter<"users"> | string | null
    city?: StringNullableWithAggregatesFilter<"users"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"users"> | string | null
    balance?: DecimalNullableWithAggregatesFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolWithAggregatesFilter<"users"> | boolean
    is_admin?: BoolWithAggregatesFilter<"users"> | boolean
    is_suspended?: BoolWithAggregatesFilter<"users"> | boolean
    avatar_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    demo_balance?: DecimalNullableWithAggregatesFilter<"users"> | Decimal | DecimalJsLike | number | string | null
  }

  export type depositsWhereInput = {
    AND?: depositsWhereInput | depositsWhereInput[]
    OR?: depositsWhereInput[]
    NOT?: depositsWhereInput | depositsWhereInput[]
    id?: StringFilter<"deposits"> | string
    user_id?: StringNullableFilter<"deposits"> | string | null
    amount?: DecimalNullableFilter<"deposits"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableFilter<"deposits"> | string | null
    status?: StringNullableFilter<"deposits"> | string | null
    created_at?: DateTimeFilter<"deposits"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type depositsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type depositsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: depositsWhereInput | depositsWhereInput[]
    OR?: depositsWhereInput[]
    NOT?: depositsWhereInput | depositsWhereInput[]
    user_id?: StringNullableFilter<"deposits"> | string | null
    amount?: DecimalNullableFilter<"deposits"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableFilter<"deposits"> | string | null
    status?: StringNullableFilter<"deposits"> | string | null
    created_at?: DateTimeFilter<"deposits"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type depositsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: depositsCountOrderByAggregateInput
    _avg?: depositsAvgOrderByAggregateInput
    _max?: depositsMaxOrderByAggregateInput
    _min?: depositsMinOrderByAggregateInput
    _sum?: depositsSumOrderByAggregateInput
  }

  export type depositsScalarWhereWithAggregatesInput = {
    AND?: depositsScalarWhereWithAggregatesInput | depositsScalarWhereWithAggregatesInput[]
    OR?: depositsScalarWhereWithAggregatesInput[]
    NOT?: depositsScalarWhereWithAggregatesInput | depositsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"deposits"> | string
    user_id?: StringNullableWithAggregatesFilter<"deposits"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"deposits"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableWithAggregatesFilter<"deposits"> | string | null
    status?: StringNullableWithAggregatesFilter<"deposits"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"deposits"> | Date | string
  }

  export type withdrawalsWhereInput = {
    AND?: withdrawalsWhereInput | withdrawalsWhereInput[]
    OR?: withdrawalsWhereInput[]
    NOT?: withdrawalsWhereInput | withdrawalsWhereInput[]
    id?: StringFilter<"withdrawals"> | string
    user_id?: StringNullableFilter<"withdrawals"> | string | null
    amount?: DecimalNullableFilter<"withdrawals"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableFilter<"withdrawals"> | string | null
    account_info?: JsonNullableFilter<"withdrawals">
    status?: StringNullableFilter<"withdrawals"> | string | null
    created_at?: DateTimeFilter<"withdrawals"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type withdrawalsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    account_info?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type withdrawalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: withdrawalsWhereInput | withdrawalsWhereInput[]
    OR?: withdrawalsWhereInput[]
    NOT?: withdrawalsWhereInput | withdrawalsWhereInput[]
    user_id?: StringNullableFilter<"withdrawals"> | string | null
    amount?: DecimalNullableFilter<"withdrawals"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableFilter<"withdrawals"> | string | null
    account_info?: JsonNullableFilter<"withdrawals">
    status?: StringNullableFilter<"withdrawals"> | string | null
    created_at?: DateTimeFilter<"withdrawals"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type withdrawalsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    account_info?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: withdrawalsCountOrderByAggregateInput
    _avg?: withdrawalsAvgOrderByAggregateInput
    _max?: withdrawalsMaxOrderByAggregateInput
    _min?: withdrawalsMinOrderByAggregateInput
    _sum?: withdrawalsSumOrderByAggregateInput
  }

  export type withdrawalsScalarWhereWithAggregatesInput = {
    AND?: withdrawalsScalarWhereWithAggregatesInput | withdrawalsScalarWhereWithAggregatesInput[]
    OR?: withdrawalsScalarWhereWithAggregatesInput[]
    NOT?: withdrawalsScalarWhereWithAggregatesInput | withdrawalsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"withdrawals"> | string
    user_id?: StringNullableWithAggregatesFilter<"withdrawals"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"withdrawals"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableWithAggregatesFilter<"withdrawals"> | string | null
    account_info?: JsonNullableWithAggregatesFilter<"withdrawals">
    status?: StringNullableWithAggregatesFilter<"withdrawals"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"withdrawals"> | Date | string
  }

  export type tradesWhereInput = {
    AND?: tradesWhereInput | tradesWhereInput[]
    OR?: tradesWhereInput[]
    NOT?: tradesWhereInput | tradesWhereInput[]
    id?: StringFilter<"trades"> | string
    user_id?: StringNullableFilter<"trades"> | string | null
    symbol?: StringNullableFilter<"trades"> | string | null
    amount?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    direction?: StringNullableFilter<"trades"> | string | null
    open_time?: DateTimeNullableFilter<"trades"> | Date | string | null
    close_time?: DateTimeNullableFilter<"trades"> | Date | string | null
    result?: StringNullableFilter<"trades"> | string | null
    status?: StringNullableFilter<"trades"> | string | null
    entry_price?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    payout?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"trades"> | Date | string
    updated_at?: DateTimeFilter<"trades"> | Date | string
    account_type?: StringNullableFilter<"trades"> | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type tradesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    direction?: SortOrderInput | SortOrder
    open_time?: SortOrderInput | SortOrder
    close_time?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    entry_price?: SortOrderInput | SortOrder
    payout?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_type?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type tradesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tradesWhereInput | tradesWhereInput[]
    OR?: tradesWhereInput[]
    NOT?: tradesWhereInput | tradesWhereInput[]
    user_id?: StringNullableFilter<"trades"> | string | null
    symbol?: StringNullableFilter<"trades"> | string | null
    amount?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    direction?: StringNullableFilter<"trades"> | string | null
    open_time?: DateTimeNullableFilter<"trades"> | Date | string | null
    close_time?: DateTimeNullableFilter<"trades"> | Date | string | null
    result?: StringNullableFilter<"trades"> | string | null
    status?: StringNullableFilter<"trades"> | string | null
    entry_price?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    payout?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"trades"> | Date | string
    updated_at?: DateTimeFilter<"trades"> | Date | string
    account_type?: StringNullableFilter<"trades"> | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type tradesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    direction?: SortOrderInput | SortOrder
    open_time?: SortOrderInput | SortOrder
    close_time?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    entry_price?: SortOrderInput | SortOrder
    payout?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_type?: SortOrderInput | SortOrder
    _count?: tradesCountOrderByAggregateInput
    _avg?: tradesAvgOrderByAggregateInput
    _max?: tradesMaxOrderByAggregateInput
    _min?: tradesMinOrderByAggregateInput
    _sum?: tradesSumOrderByAggregateInput
  }

  export type tradesScalarWhereWithAggregatesInput = {
    AND?: tradesScalarWhereWithAggregatesInput | tradesScalarWhereWithAggregatesInput[]
    OR?: tradesScalarWhereWithAggregatesInput[]
    NOT?: tradesScalarWhereWithAggregatesInput | tradesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"trades"> | string
    user_id?: StringNullableWithAggregatesFilter<"trades"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"trades"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    direction?: StringNullableWithAggregatesFilter<"trades"> | string | null
    open_time?: DateTimeNullableWithAggregatesFilter<"trades"> | Date | string | null
    close_time?: DateTimeNullableWithAggregatesFilter<"trades"> | Date | string | null
    result?: StringNullableWithAggregatesFilter<"trades"> | string | null
    status?: StringNullableWithAggregatesFilter<"trades"> | string | null
    entry_price?: DecimalNullableWithAggregatesFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    payout?: DecimalNullableWithAggregatesFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeWithAggregatesFilter<"trades"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"trades"> | Date | string
    account_type?: StringNullableWithAggregatesFilter<"trades"> | string | null
  }

  export type leaderboardWhereInput = {
    AND?: leaderboardWhereInput | leaderboardWhereInput[]
    OR?: leaderboardWhereInput[]
    NOT?: leaderboardWhereInput | leaderboardWhereInput[]
    id?: StringFilter<"leaderboard"> | string
    user_id?: StringNullableFilter<"leaderboard"> | string | null
    amount?: DecimalNullableFilter<"leaderboard"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableFilter<"leaderboard"> | number | null
    updated_at?: DateTimeFilter<"leaderboard"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type leaderboardOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type leaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: leaderboardWhereInput | leaderboardWhereInput[]
    OR?: leaderboardWhereInput[]
    NOT?: leaderboardWhereInput | leaderboardWhereInput[]
    user_id?: StringNullableFilter<"leaderboard"> | string | null
    amount?: DecimalNullableFilter<"leaderboard"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableFilter<"leaderboard"> | number | null
    updated_at?: DateTimeFilter<"leaderboard"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type leaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    _count?: leaderboardCountOrderByAggregateInput
    _avg?: leaderboardAvgOrderByAggregateInput
    _max?: leaderboardMaxOrderByAggregateInput
    _min?: leaderboardMinOrderByAggregateInput
    _sum?: leaderboardSumOrderByAggregateInput
  }

  export type leaderboardScalarWhereWithAggregatesInput = {
    AND?: leaderboardScalarWhereWithAggregatesInput | leaderboardScalarWhereWithAggregatesInput[]
    OR?: leaderboardScalarWhereWithAggregatesInput[]
    NOT?: leaderboardScalarWhereWithAggregatesInput | leaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"leaderboard"> | string
    user_id?: StringNullableWithAggregatesFilter<"leaderboard"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"leaderboard"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableWithAggregatesFilter<"leaderboard"> | number | null
    updated_at?: DateTimeWithAggregatesFilter<"leaderboard"> | Date | string
  }

  export type tournamentsWhereInput = {
    AND?: tournamentsWhereInput | tournamentsWhereInput[]
    OR?: tournamentsWhereInput[]
    NOT?: tournamentsWhereInput | tournamentsWhereInput[]
    id?: StringFilter<"tournaments"> | string
    title?: StringNullableFilter<"tournaments"> | string | null
    prize_pool?: DecimalNullableFilter<"tournaments"> | Decimal | DecimalJsLike | number | string | null
    entry_fee?: DecimalNullableFilter<"tournaments"> | Decimal | DecimalJsLike | number | string | null
    participants?: IntNullableFilter<"tournaments"> | number | null
    duration?: StringNullableFilter<"tournaments"> | string | null
    status?: StringNullableFilter<"tournaments"> | string | null
    created_at?: DateTimeFilter<"tournaments"> | Date | string
  }

  export type tournamentsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    prize_pool?: SortOrderInput | SortOrder
    entry_fee?: SortOrderInput | SortOrder
    participants?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
  }

  export type tournamentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tournamentsWhereInput | tournamentsWhereInput[]
    OR?: tournamentsWhereInput[]
    NOT?: tournamentsWhereInput | tournamentsWhereInput[]
    title?: StringNullableFilter<"tournaments"> | string | null
    prize_pool?: DecimalNullableFilter<"tournaments"> | Decimal | DecimalJsLike | number | string | null
    entry_fee?: DecimalNullableFilter<"tournaments"> | Decimal | DecimalJsLike | number | string | null
    participants?: IntNullableFilter<"tournaments"> | number | null
    duration?: StringNullableFilter<"tournaments"> | string | null
    status?: StringNullableFilter<"tournaments"> | string | null
    created_at?: DateTimeFilter<"tournaments"> | Date | string
  }, "id">

  export type tournamentsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    prize_pool?: SortOrderInput | SortOrder
    entry_fee?: SortOrderInput | SortOrder
    participants?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: tournamentsCountOrderByAggregateInput
    _avg?: tournamentsAvgOrderByAggregateInput
    _max?: tournamentsMaxOrderByAggregateInput
    _min?: tournamentsMinOrderByAggregateInput
    _sum?: tournamentsSumOrderByAggregateInput
  }

  export type tournamentsScalarWhereWithAggregatesInput = {
    AND?: tournamentsScalarWhereWithAggregatesInput | tournamentsScalarWhereWithAggregatesInput[]
    OR?: tournamentsScalarWhereWithAggregatesInput[]
    NOT?: tournamentsScalarWhereWithAggregatesInput | tournamentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournaments"> | string
    title?: StringNullableWithAggregatesFilter<"tournaments"> | string | null
    prize_pool?: DecimalNullableWithAggregatesFilter<"tournaments"> | Decimal | DecimalJsLike | number | string | null
    entry_fee?: DecimalNullableWithAggregatesFilter<"tournaments"> | Decimal | DecimalJsLike | number | string | null
    participants?: IntNullableWithAggregatesFilter<"tournaments"> | number | null
    duration?: StringNullableWithAggregatesFilter<"tournaments"> | string | null
    status?: StringNullableWithAggregatesFilter<"tournaments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"tournaments"> | Date | string
  }

  export type support_messagesWhereInput = {
    AND?: support_messagesWhereInput | support_messagesWhereInput[]
    OR?: support_messagesWhereInput[]
    NOT?: support_messagesWhereInput | support_messagesWhereInput[]
    id?: StringFilter<"support_messages"> | string
    user_id?: StringNullableFilter<"support_messages"> | string | null
    name?: StringNullableFilter<"support_messages"> | string | null
    email?: StringNullableFilter<"support_messages"> | string | null
    subject?: StringNullableFilter<"support_messages"> | string | null
    message?: StringNullableFilter<"support_messages"> | string | null
    created_at?: DateTimeFilter<"support_messages"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type support_messagesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type support_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: support_messagesWhereInput | support_messagesWhereInput[]
    OR?: support_messagesWhereInput[]
    NOT?: support_messagesWhereInput | support_messagesWhereInput[]
    user_id?: StringNullableFilter<"support_messages"> | string | null
    name?: StringNullableFilter<"support_messages"> | string | null
    email?: StringNullableFilter<"support_messages"> | string | null
    subject?: StringNullableFilter<"support_messages"> | string | null
    message?: StringNullableFilter<"support_messages"> | string | null
    created_at?: DateTimeFilter<"support_messages"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type support_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: support_messagesCountOrderByAggregateInput
    _max?: support_messagesMaxOrderByAggregateInput
    _min?: support_messagesMinOrderByAggregateInput
  }

  export type support_messagesScalarWhereWithAggregatesInput = {
    AND?: support_messagesScalarWhereWithAggregatesInput | support_messagesScalarWhereWithAggregatesInput[]
    OR?: support_messagesScalarWhereWithAggregatesInput[]
    NOT?: support_messagesScalarWhereWithAggregatesInput | support_messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"support_messages"> | string
    user_id?: StringNullableWithAggregatesFilter<"support_messages"> | string | null
    name?: StringNullableWithAggregatesFilter<"support_messages"> | string | null
    email?: StringNullableWithAggregatesFilter<"support_messages"> | string | null
    subject?: StringNullableWithAggregatesFilter<"support_messages"> | string | null
    message?: StringNullableWithAggregatesFilter<"support_messages"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"support_messages"> | Date | string
  }

  export type chat_messagesWhereInput = {
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    id?: StringFilter<"chat_messages"> | string
    user_id?: StringNullableFilter<"chat_messages"> | string | null
    sender?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringNullableFilter<"chat_messages"> | string | null
    time?: DateTimeFilter<"chat_messages"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type chat_messagesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    sender?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    time?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type chat_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    user_id?: StringNullableFilter<"chat_messages"> | string | null
    sender?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringNullableFilter<"chat_messages"> | string | null
    time?: DateTimeFilter<"chat_messages"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type chat_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    sender?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    time?: SortOrder
    _count?: chat_messagesCountOrderByAggregateInput
    _max?: chat_messagesMaxOrderByAggregateInput
    _min?: chat_messagesMinOrderByAggregateInput
  }

  export type chat_messagesScalarWhereWithAggregatesInput = {
    AND?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    OR?: chat_messagesScalarWhereWithAggregatesInput[]
    NOT?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chat_messages"> | string
    user_id?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    sender?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    message?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    time?: DateTimeWithAggregatesFilter<"chat_messages"> | Date | string
  }

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    id?: StringFilter<"settings"> | string
    user_id?: StringNullableFilter<"settings"> | string | null
    notifications?: BoolNullableFilter<"settings"> | boolean | null
    private?: BoolNullableFilter<"settings"> | boolean | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    notifications?: SortOrderInput | SortOrder
    private?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    user_id?: StringNullableFilter<"settings"> | string | null
    notifications?: BoolNullableFilter<"settings"> | boolean | null
    private?: BoolNullableFilter<"settings"> | boolean | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    notifications?: SortOrderInput | SortOrder
    private?: SortOrderInput | SortOrder
    _count?: settingsCountOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    OR?: settingsScalarWhereWithAggregatesInput[]
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"settings"> | string
    user_id?: StringNullableWithAggregatesFilter<"settings"> | string | null
    notifications?: BoolNullableWithAggregatesFilter<"settings"> | boolean | null
    private?: BoolNullableWithAggregatesFilter<"settings"> | boolean | null
  }

  export type crypto_assetsWhereInput = {
    AND?: crypto_assetsWhereInput | crypto_assetsWhereInput[]
    OR?: crypto_assetsWhereInput[]
    NOT?: crypto_assetsWhereInput | crypto_assetsWhereInput[]
    id?: StringFilter<"crypto_assets"> | string
    symbol?: StringFilter<"crypto_assets"> | string
    network?: StringFilter<"crypto_assets"> | string
    display_name?: StringNullableFilter<"crypto_assets"> | string | null
    contract?: StringNullableFilter<"crypto_assets"> | string | null
    decimals?: IntFilter<"crypto_assets"> | number
    min_deposit?: DecimalFilter<"crypto_assets"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"crypto_assets"> | boolean
    created_at?: DateTimeFilter<"crypto_assets"> | Date | string
    updated_at?: DateTimeFilter<"crypto_assets"> | Date | string
    deposit_sessions?: Deposit_sessionsListRelationFilter
  }

  export type crypto_assetsOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    display_name?: SortOrderInput | SortOrder
    contract?: SortOrderInput | SortOrder
    decimals?: SortOrder
    min_deposit?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deposit_sessions?: deposit_sessionsOrderByRelationAggregateInput
  }

  export type crypto_assetsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol_network?: crypto_assetsSymbolNetworkCompoundUniqueInput
    AND?: crypto_assetsWhereInput | crypto_assetsWhereInput[]
    OR?: crypto_assetsWhereInput[]
    NOT?: crypto_assetsWhereInput | crypto_assetsWhereInput[]
    symbol?: StringFilter<"crypto_assets"> | string
    network?: StringFilter<"crypto_assets"> | string
    display_name?: StringNullableFilter<"crypto_assets"> | string | null
    contract?: StringNullableFilter<"crypto_assets"> | string | null
    decimals?: IntFilter<"crypto_assets"> | number
    min_deposit?: DecimalFilter<"crypto_assets"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"crypto_assets"> | boolean
    created_at?: DateTimeFilter<"crypto_assets"> | Date | string
    updated_at?: DateTimeFilter<"crypto_assets"> | Date | string
    deposit_sessions?: Deposit_sessionsListRelationFilter
  }, "id" | "symbol_network">

  export type crypto_assetsOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    display_name?: SortOrderInput | SortOrder
    contract?: SortOrderInput | SortOrder
    decimals?: SortOrder
    min_deposit?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: crypto_assetsCountOrderByAggregateInput
    _avg?: crypto_assetsAvgOrderByAggregateInput
    _max?: crypto_assetsMaxOrderByAggregateInput
    _min?: crypto_assetsMinOrderByAggregateInput
    _sum?: crypto_assetsSumOrderByAggregateInput
  }

  export type crypto_assetsScalarWhereWithAggregatesInput = {
    AND?: crypto_assetsScalarWhereWithAggregatesInput | crypto_assetsScalarWhereWithAggregatesInput[]
    OR?: crypto_assetsScalarWhereWithAggregatesInput[]
    NOT?: crypto_assetsScalarWhereWithAggregatesInput | crypto_assetsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"crypto_assets"> | string
    symbol?: StringWithAggregatesFilter<"crypto_assets"> | string
    network?: StringWithAggregatesFilter<"crypto_assets"> | string
    display_name?: StringNullableWithAggregatesFilter<"crypto_assets"> | string | null
    contract?: StringNullableWithAggregatesFilter<"crypto_assets"> | string | null
    decimals?: IntWithAggregatesFilter<"crypto_assets"> | number
    min_deposit?: DecimalWithAggregatesFilter<"crypto_assets"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolWithAggregatesFilter<"crypto_assets"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"crypto_assets"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"crypto_assets"> | Date | string
  }

  export type deposit_sessionsWhereInput = {
    AND?: deposit_sessionsWhereInput | deposit_sessionsWhereInput[]
    OR?: deposit_sessionsWhereInput[]
    NOT?: deposit_sessionsWhereInput | deposit_sessionsWhereInput[]
    id?: StringFilter<"deposit_sessions"> | string
    user_id?: StringFilter<"deposit_sessions"> | string
    crypto_asset_id?: StringFilter<"deposit_sessions"> | string
    address?: StringFilter<"deposit_sessions"> | string
    derivation_path?: StringNullableFilter<"deposit_sessions"> | string | null
    memo_tag?: StringNullableFilter<"deposit_sessions"> | string | null
    amount_expected?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    rate_source?: StringNullableFilter<"deposit_sessions"> | string | null
    status?: EnumDepositSessionStatusFilter<"deposit_sessions"> | $Enums.DepositSessionStatus
    tx_hash?: StringNullableFilter<"deposit_sessions"> | string | null
    detected_amount?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    confirmations?: IntNullableFilter<"deposit_sessions"> | number | null
    min_confirmations?: IntFilter<"deposit_sessions"> | number
    is_late?: BoolFilter<"deposit_sessions"> | boolean
    expires_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    created_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    updated_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    crypto_assets?: XOR<Crypto_assetsScalarRelationFilter, crypto_assetsWhereInput>
  }

  export type deposit_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    crypto_asset_id?: SortOrder
    address?: SortOrder
    derivation_path?: SortOrderInput | SortOrder
    memo_tag?: SortOrderInput | SortOrder
    amount_expected?: SortOrderInput | SortOrder
    fiat_locked_usd?: SortOrderInput | SortOrder
    rate_source?: SortOrderInput | SortOrder
    status?: SortOrder
    tx_hash?: SortOrderInput | SortOrder
    detected_amount?: SortOrderInput | SortOrder
    confirmations?: SortOrderInput | SortOrder
    min_confirmations?: SortOrder
    is_late?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    crypto_assets?: crypto_assetsOrderByWithRelationInput
  }

  export type deposit_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tx_hash?: string
    AND?: deposit_sessionsWhereInput | deposit_sessionsWhereInput[]
    OR?: deposit_sessionsWhereInput[]
    NOT?: deposit_sessionsWhereInput | deposit_sessionsWhereInput[]
    user_id?: StringFilter<"deposit_sessions"> | string
    crypto_asset_id?: StringFilter<"deposit_sessions"> | string
    address?: StringFilter<"deposit_sessions"> | string
    derivation_path?: StringNullableFilter<"deposit_sessions"> | string | null
    memo_tag?: StringNullableFilter<"deposit_sessions"> | string | null
    amount_expected?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    rate_source?: StringNullableFilter<"deposit_sessions"> | string | null
    status?: EnumDepositSessionStatusFilter<"deposit_sessions"> | $Enums.DepositSessionStatus
    detected_amount?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    confirmations?: IntNullableFilter<"deposit_sessions"> | number | null
    min_confirmations?: IntFilter<"deposit_sessions"> | number
    is_late?: BoolFilter<"deposit_sessions"> | boolean
    expires_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    created_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    updated_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    crypto_assets?: XOR<Crypto_assetsScalarRelationFilter, crypto_assetsWhereInput>
  }, "id" | "tx_hash">

  export type deposit_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    crypto_asset_id?: SortOrder
    address?: SortOrder
    derivation_path?: SortOrderInput | SortOrder
    memo_tag?: SortOrderInput | SortOrder
    amount_expected?: SortOrderInput | SortOrder
    fiat_locked_usd?: SortOrderInput | SortOrder
    rate_source?: SortOrderInput | SortOrder
    status?: SortOrder
    tx_hash?: SortOrderInput | SortOrder
    detected_amount?: SortOrderInput | SortOrder
    confirmations?: SortOrderInput | SortOrder
    min_confirmations?: SortOrder
    is_late?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: deposit_sessionsCountOrderByAggregateInput
    _avg?: deposit_sessionsAvgOrderByAggregateInput
    _max?: deposit_sessionsMaxOrderByAggregateInput
    _min?: deposit_sessionsMinOrderByAggregateInput
    _sum?: deposit_sessionsSumOrderByAggregateInput
  }

  export type deposit_sessionsScalarWhereWithAggregatesInput = {
    AND?: deposit_sessionsScalarWhereWithAggregatesInput | deposit_sessionsScalarWhereWithAggregatesInput[]
    OR?: deposit_sessionsScalarWhereWithAggregatesInput[]
    NOT?: deposit_sessionsScalarWhereWithAggregatesInput | deposit_sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"deposit_sessions"> | string
    user_id?: StringWithAggregatesFilter<"deposit_sessions"> | string
    crypto_asset_id?: StringWithAggregatesFilter<"deposit_sessions"> | string
    address?: StringWithAggregatesFilter<"deposit_sessions"> | string
    derivation_path?: StringNullableWithAggregatesFilter<"deposit_sessions"> | string | null
    memo_tag?: StringNullableWithAggregatesFilter<"deposit_sessions"> | string | null
    amount_expected?: DecimalNullableWithAggregatesFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: DecimalNullableWithAggregatesFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    rate_source?: StringNullableWithAggregatesFilter<"deposit_sessions"> | string | null
    status?: EnumDepositSessionStatusWithAggregatesFilter<"deposit_sessions"> | $Enums.DepositSessionStatus
    tx_hash?: StringNullableWithAggregatesFilter<"deposit_sessions"> | string | null
    detected_amount?: DecimalNullableWithAggregatesFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    confirmations?: IntNullableWithAggregatesFilter<"deposit_sessions"> | number | null
    min_confirmations?: IntWithAggregatesFilter<"deposit_sessions"> | number
    is_late?: BoolWithAggregatesFilter<"deposit_sessions"> | boolean
    expires_at?: DateTimeWithAggregatesFilter<"deposit_sessions"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"deposit_sessions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"deposit_sessions"> | Date | string
  }

  export type wallet_ledgerWhereInput = {
    AND?: wallet_ledgerWhereInput | wallet_ledgerWhereInput[]
    OR?: wallet_ledgerWhereInput[]
    NOT?: wallet_ledgerWhereInput | wallet_ledgerWhereInput[]
    id?: StringFilter<"wallet_ledger"> | string
    user_id?: StringFilter<"wallet_ledger"> | string
    type?: EnumLedgerTypeFilter<"wallet_ledger"> | $Enums.LedgerType
    asset?: StringFilter<"wallet_ledger"> | string
    amount?: DecimalFilter<"wallet_ledger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableFilter<"wallet_ledger">
    created_at?: DateTimeFilter<"wallet_ledger"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type wallet_ledgerOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    meta?: SortOrderInput | SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type wallet_ledgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: wallet_ledgerWhereInput | wallet_ledgerWhereInput[]
    OR?: wallet_ledgerWhereInput[]
    NOT?: wallet_ledgerWhereInput | wallet_ledgerWhereInput[]
    user_id?: StringFilter<"wallet_ledger"> | string
    type?: EnumLedgerTypeFilter<"wallet_ledger"> | $Enums.LedgerType
    asset?: StringFilter<"wallet_ledger"> | string
    amount?: DecimalFilter<"wallet_ledger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableFilter<"wallet_ledger">
    created_at?: DateTimeFilter<"wallet_ledger"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type wallet_ledgerOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    meta?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: wallet_ledgerCountOrderByAggregateInput
    _avg?: wallet_ledgerAvgOrderByAggregateInput
    _max?: wallet_ledgerMaxOrderByAggregateInput
    _min?: wallet_ledgerMinOrderByAggregateInput
    _sum?: wallet_ledgerSumOrderByAggregateInput
  }

  export type wallet_ledgerScalarWhereWithAggregatesInput = {
    AND?: wallet_ledgerScalarWhereWithAggregatesInput | wallet_ledgerScalarWhereWithAggregatesInput[]
    OR?: wallet_ledgerScalarWhereWithAggregatesInput[]
    NOT?: wallet_ledgerScalarWhereWithAggregatesInput | wallet_ledgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wallet_ledger"> | string
    user_id?: StringWithAggregatesFilter<"wallet_ledger"> | string
    type?: EnumLedgerTypeWithAggregatesFilter<"wallet_ledger"> | $Enums.LedgerType
    asset?: StringWithAggregatesFilter<"wallet_ledger"> | string
    amount?: DecimalWithAggregatesFilter<"wallet_ledger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableWithAggregatesFilter<"wallet_ledger">
    created_at?: DateTimeWithAggregatesFilter<"wallet_ledger"> | Date | string
  }

  export type payment_method_templatesWhereInput = {
    AND?: payment_method_templatesWhereInput | payment_method_templatesWhereInput[]
    OR?: payment_method_templatesWhereInput[]
    NOT?: payment_method_templatesWhereInput | payment_method_templatesWhereInput[]
    id?: StringFilter<"payment_method_templates"> | string
    title?: StringFilter<"payment_method_templates"> | string
    type?: EnumPaymentMethodTypeFilter<"payment_method_templates"> | $Enums.PaymentMethodType
    fields?: JsonFilter<"payment_method_templates">
    currency?: StringFilter<"payment_method_templates"> | string
    country?: StringFilter<"payment_method_templates"> | string
    is_active?: BoolFilter<"payment_method_templates"> | boolean
    created_at?: DateTimeFilter<"payment_method_templates"> | Date | string
    updated_at?: DateTimeFilter<"payment_method_templates"> | Date | string
  }

  export type payment_method_templatesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fields?: SortOrder
    currency?: SortOrder
    country?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_method_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: payment_method_templatesWhereInput | payment_method_templatesWhereInput[]
    OR?: payment_method_templatesWhereInput[]
    NOT?: payment_method_templatesWhereInput | payment_method_templatesWhereInput[]
    title?: StringFilter<"payment_method_templates"> | string
    type?: EnumPaymentMethodTypeFilter<"payment_method_templates"> | $Enums.PaymentMethodType
    fields?: JsonFilter<"payment_method_templates">
    currency?: StringFilter<"payment_method_templates"> | string
    country?: StringFilter<"payment_method_templates"> | string
    is_active?: BoolFilter<"payment_method_templates"> | boolean
    created_at?: DateTimeFilter<"payment_method_templates"> | Date | string
    updated_at?: DateTimeFilter<"payment_method_templates"> | Date | string
  }, "id">

  export type payment_method_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fields?: SortOrder
    currency?: SortOrder
    country?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: payment_method_templatesCountOrderByAggregateInput
    _max?: payment_method_templatesMaxOrderByAggregateInput
    _min?: payment_method_templatesMinOrderByAggregateInput
  }

  export type payment_method_templatesScalarWhereWithAggregatesInput = {
    AND?: payment_method_templatesScalarWhereWithAggregatesInput | payment_method_templatesScalarWhereWithAggregatesInput[]
    OR?: payment_method_templatesScalarWhereWithAggregatesInput[]
    NOT?: payment_method_templatesScalarWhereWithAggregatesInput | payment_method_templatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"payment_method_templates"> | string
    title?: StringWithAggregatesFilter<"payment_method_templates"> | string
    type?: EnumPaymentMethodTypeWithAggregatesFilter<"payment_method_templates"> | $Enums.PaymentMethodType
    fields?: JsonWithAggregatesFilter<"payment_method_templates">
    currency?: StringWithAggregatesFilter<"payment_method_templates"> | string
    country?: StringWithAggregatesFilter<"payment_method_templates"> | string
    is_active?: BoolWithAggregatesFilter<"payment_method_templates"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"payment_method_templates"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"payment_method_templates"> | Date | string
  }

  export type p2p_offersWhereInput = {
    AND?: p2p_offersWhereInput | p2p_offersWhereInput[]
    OR?: p2p_offersWhereInput[]
    NOT?: p2p_offersWhereInput | p2p_offersWhereInput[]
    id?: StringFilter<"p2p_offers"> | string
    user_id?: StringFilter<"p2p_offers"> | string
    side?: EnumP2POrderSideFilter<"p2p_offers"> | $Enums.P2POrderSide
    asset_symbol?: StringFilter<"p2p_offers"> | string
    crypto_asset_id?: StringNullableFilter<"p2p_offers"> | string | null
    fiat_currency?: StringFilter<"p2p_offers"> | string
    price_type?: StringFilter<"p2p_offers"> | string
    fixed_price?: DecimalNullableFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    margin_percent?: DecimalNullableFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    terms?: StringNullableFilter<"p2p_offers"> | string | null
    auto_reply?: StringNullableFilter<"p2p_offers"> | string | null
    status?: EnumP2POfferStatusFilter<"p2p_offers"> | $Enums.P2POfferStatus
    total_trades?: IntFilter<"p2p_offers"> | number
    completion_rate?: IntFilter<"p2p_offers"> | number
    created_at?: DateTimeFilter<"p2p_offers"> | Date | string
    updated_at?: DateTimeFilter<"p2p_offers"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    payment_methods?: P2p_offer_payment_methodsListRelationFilter
    orders?: P2p_ordersListRelationFilter
  }

  export type p2p_offersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    crypto_asset_id?: SortOrderInput | SortOrder
    fiat_currency?: SortOrder
    price_type?: SortOrder
    fixed_price?: SortOrderInput | SortOrder
    margin_percent?: SortOrderInput | SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    terms?: SortOrderInput | SortOrder
    auto_reply?: SortOrderInput | SortOrder
    status?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    payment_methods?: p2p_offer_payment_methodsOrderByRelationAggregateInput
    orders?: p2p_ordersOrderByRelationAggregateInput
  }

  export type p2p_offersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: p2p_offersWhereInput | p2p_offersWhereInput[]
    OR?: p2p_offersWhereInput[]
    NOT?: p2p_offersWhereInput | p2p_offersWhereInput[]
    user_id?: StringFilter<"p2p_offers"> | string
    side?: EnumP2POrderSideFilter<"p2p_offers"> | $Enums.P2POrderSide
    asset_symbol?: StringFilter<"p2p_offers"> | string
    crypto_asset_id?: StringNullableFilter<"p2p_offers"> | string | null
    fiat_currency?: StringFilter<"p2p_offers"> | string
    price_type?: StringFilter<"p2p_offers"> | string
    fixed_price?: DecimalNullableFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    margin_percent?: DecimalNullableFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    terms?: StringNullableFilter<"p2p_offers"> | string | null
    auto_reply?: StringNullableFilter<"p2p_offers"> | string | null
    status?: EnumP2POfferStatusFilter<"p2p_offers"> | $Enums.P2POfferStatus
    total_trades?: IntFilter<"p2p_offers"> | number
    completion_rate?: IntFilter<"p2p_offers"> | number
    created_at?: DateTimeFilter<"p2p_offers"> | Date | string
    updated_at?: DateTimeFilter<"p2p_offers"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    payment_methods?: P2p_offer_payment_methodsListRelationFilter
    orders?: P2p_ordersListRelationFilter
  }, "id">

  export type p2p_offersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    crypto_asset_id?: SortOrderInput | SortOrder
    fiat_currency?: SortOrder
    price_type?: SortOrder
    fixed_price?: SortOrderInput | SortOrder
    margin_percent?: SortOrderInput | SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    terms?: SortOrderInput | SortOrder
    auto_reply?: SortOrderInput | SortOrder
    status?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: p2p_offersCountOrderByAggregateInput
    _avg?: p2p_offersAvgOrderByAggregateInput
    _max?: p2p_offersMaxOrderByAggregateInput
    _min?: p2p_offersMinOrderByAggregateInput
    _sum?: p2p_offersSumOrderByAggregateInput
  }

  export type p2p_offersScalarWhereWithAggregatesInput = {
    AND?: p2p_offersScalarWhereWithAggregatesInput | p2p_offersScalarWhereWithAggregatesInput[]
    OR?: p2p_offersScalarWhereWithAggregatesInput[]
    NOT?: p2p_offersScalarWhereWithAggregatesInput | p2p_offersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"p2p_offers"> | string
    user_id?: StringWithAggregatesFilter<"p2p_offers"> | string
    side?: EnumP2POrderSideWithAggregatesFilter<"p2p_offers"> | $Enums.P2POrderSide
    asset_symbol?: StringWithAggregatesFilter<"p2p_offers"> | string
    crypto_asset_id?: StringNullableWithAggregatesFilter<"p2p_offers"> | string | null
    fiat_currency?: StringWithAggregatesFilter<"p2p_offers"> | string
    price_type?: StringWithAggregatesFilter<"p2p_offers"> | string
    fixed_price?: DecimalNullableWithAggregatesFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    margin_percent?: DecimalNullableWithAggregatesFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalWithAggregatesFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalWithAggregatesFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalWithAggregatesFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalWithAggregatesFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    terms?: StringNullableWithAggregatesFilter<"p2p_offers"> | string | null
    auto_reply?: StringNullableWithAggregatesFilter<"p2p_offers"> | string | null
    status?: EnumP2POfferStatusWithAggregatesFilter<"p2p_offers"> | $Enums.P2POfferStatus
    total_trades?: IntWithAggregatesFilter<"p2p_offers"> | number
    completion_rate?: IntWithAggregatesFilter<"p2p_offers"> | number
    created_at?: DateTimeWithAggregatesFilter<"p2p_offers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"p2p_offers"> | Date | string
  }

  export type user_payment_methodsWhereInput = {
    AND?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    OR?: user_payment_methodsWhereInput[]
    NOT?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    id?: StringFilter<"user_payment_methods"> | string
    user_id?: StringFilter<"user_payment_methods"> | string
    type?: EnumPaymentMethodTypeFilter<"user_payment_methods"> | $Enums.PaymentMethodType
    label?: StringNullableFilter<"user_payment_methods"> | string | null
    details?: JsonNullableFilter<"user_payment_methods">
    is_verified?: BoolFilter<"user_payment_methods"> | boolean
    is_active?: BoolFilter<"user_payment_methods"> | boolean
    created_at?: DateTimeFilter<"user_payment_methods"> | Date | string
    updated_at?: DateTimeFilter<"user_payment_methods"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    offers?: P2p_offer_payment_methodsListRelationFilter
  }

  export type user_payment_methodsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    label?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    offers?: p2p_offer_payment_methodsOrderByRelationAggregateInput
  }

  export type user_payment_methodsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    OR?: user_payment_methodsWhereInput[]
    NOT?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    user_id?: StringFilter<"user_payment_methods"> | string
    type?: EnumPaymentMethodTypeFilter<"user_payment_methods"> | $Enums.PaymentMethodType
    label?: StringNullableFilter<"user_payment_methods"> | string | null
    details?: JsonNullableFilter<"user_payment_methods">
    is_verified?: BoolFilter<"user_payment_methods"> | boolean
    is_active?: BoolFilter<"user_payment_methods"> | boolean
    created_at?: DateTimeFilter<"user_payment_methods"> | Date | string
    updated_at?: DateTimeFilter<"user_payment_methods"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    offers?: P2p_offer_payment_methodsListRelationFilter
  }, "id">

  export type user_payment_methodsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    label?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_payment_methodsCountOrderByAggregateInput
    _max?: user_payment_methodsMaxOrderByAggregateInput
    _min?: user_payment_methodsMinOrderByAggregateInput
  }

  export type user_payment_methodsScalarWhereWithAggregatesInput = {
    AND?: user_payment_methodsScalarWhereWithAggregatesInput | user_payment_methodsScalarWhereWithAggregatesInput[]
    OR?: user_payment_methodsScalarWhereWithAggregatesInput[]
    NOT?: user_payment_methodsScalarWhereWithAggregatesInput | user_payment_methodsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_payment_methods"> | string
    user_id?: StringWithAggregatesFilter<"user_payment_methods"> | string
    type?: EnumPaymentMethodTypeWithAggregatesFilter<"user_payment_methods"> | $Enums.PaymentMethodType
    label?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    details?: JsonNullableWithAggregatesFilter<"user_payment_methods">
    is_verified?: BoolWithAggregatesFilter<"user_payment_methods"> | boolean
    is_active?: BoolWithAggregatesFilter<"user_payment_methods"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"user_payment_methods"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_payment_methods"> | Date | string
  }

  export type p2p_offer_payment_methodsWhereInput = {
    AND?: p2p_offer_payment_methodsWhereInput | p2p_offer_payment_methodsWhereInput[]
    OR?: p2p_offer_payment_methodsWhereInput[]
    NOT?: p2p_offer_payment_methodsWhereInput | p2p_offer_payment_methodsWhereInput[]
    id?: StringFilter<"p2p_offer_payment_methods"> | string
    offer_id?: StringFilter<"p2p_offer_payment_methods"> | string
    payment_method_id?: StringFilter<"p2p_offer_payment_methods"> | string
    offer?: XOR<P2p_offersScalarRelationFilter, p2p_offersWhereInput>
    payment_method?: XOR<User_payment_methodsScalarRelationFilter, user_payment_methodsWhereInput>
  }

  export type p2p_offer_payment_methodsOrderByWithRelationInput = {
    id?: SortOrder
    offer_id?: SortOrder
    payment_method_id?: SortOrder
    offer?: p2p_offersOrderByWithRelationInput
    payment_method?: user_payment_methodsOrderByWithRelationInput
  }

  export type p2p_offer_payment_methodsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    offer_id_payment_method_id?: p2p_offer_payment_methodsOffer_idPayment_method_idCompoundUniqueInput
    AND?: p2p_offer_payment_methodsWhereInput | p2p_offer_payment_methodsWhereInput[]
    OR?: p2p_offer_payment_methodsWhereInput[]
    NOT?: p2p_offer_payment_methodsWhereInput | p2p_offer_payment_methodsWhereInput[]
    offer_id?: StringFilter<"p2p_offer_payment_methods"> | string
    payment_method_id?: StringFilter<"p2p_offer_payment_methods"> | string
    offer?: XOR<P2p_offersScalarRelationFilter, p2p_offersWhereInput>
    payment_method?: XOR<User_payment_methodsScalarRelationFilter, user_payment_methodsWhereInput>
  }, "id" | "offer_id_payment_method_id">

  export type p2p_offer_payment_methodsOrderByWithAggregationInput = {
    id?: SortOrder
    offer_id?: SortOrder
    payment_method_id?: SortOrder
    _count?: p2p_offer_payment_methodsCountOrderByAggregateInput
    _max?: p2p_offer_payment_methodsMaxOrderByAggregateInput
    _min?: p2p_offer_payment_methodsMinOrderByAggregateInput
  }

  export type p2p_offer_payment_methodsScalarWhereWithAggregatesInput = {
    AND?: p2p_offer_payment_methodsScalarWhereWithAggregatesInput | p2p_offer_payment_methodsScalarWhereWithAggregatesInput[]
    OR?: p2p_offer_payment_methodsScalarWhereWithAggregatesInput[]
    NOT?: p2p_offer_payment_methodsScalarWhereWithAggregatesInput | p2p_offer_payment_methodsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"p2p_offer_payment_methods"> | string
    offer_id?: StringWithAggregatesFilter<"p2p_offer_payment_methods"> | string
    payment_method_id?: StringWithAggregatesFilter<"p2p_offer_payment_methods"> | string
  }

  export type p2p_ordersWhereInput = {
    AND?: p2p_ordersWhereInput | p2p_ordersWhereInput[]
    OR?: p2p_ordersWhereInput[]
    NOT?: p2p_ordersWhereInput | p2p_ordersWhereInput[]
    id?: StringFilter<"p2p_orders"> | string
    offer_id?: StringFilter<"p2p_orders"> | string
    maker_id?: StringFilter<"p2p_orders"> | string
    taker_id?: StringFilter<"p2p_orders"> | string
    side?: EnumP2POrderSideFilter<"p2p_orders"> | $Enums.P2POrderSide
    asset_symbol?: StringFilter<"p2p_orders"> | string
    fiat_currency?: StringFilter<"p2p_orders"> | string
    price?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFilter<"p2p_orders"> | $Enums.P2PTradeStatus
    escrow_held?: BoolFilter<"p2p_orders"> | boolean
    escrow_ledger_id?: StringNullableFilter<"p2p_orders"> | string | null
    reference_code?: StringNullableFilter<"p2p_orders"> | string | null
    meta?: JsonNullableFilter<"p2p_orders">
    expires_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    paid_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    released_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    canceled_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    created_at?: DateTimeFilter<"p2p_orders"> | Date | string
    updated_at?: DateTimeFilter<"p2p_orders"> | Date | string
    offer?: XOR<P2p_offersScalarRelationFilter, p2p_offersWhereInput>
    maker?: XOR<UsersScalarRelationFilter, usersWhereInput>
    taker?: XOR<UsersScalarRelationFilter, usersWhereInput>
    messages?: P2p_messagesListRelationFilter
    disputes?: P2p_disputesListRelationFilter
    ratings?: P2p_ratingsListRelationFilter
  }

  export type p2p_ordersOrderByWithRelationInput = {
    id?: SortOrder
    offer_id?: SortOrder
    maker_id?: SortOrder
    taker_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    fiat_currency?: SortOrder
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
    status?: SortOrder
    escrow_held?: SortOrder
    escrow_ledger_id?: SortOrderInput | SortOrder
    reference_code?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    released_at?: SortOrderInput | SortOrder
    canceled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    offer?: p2p_offersOrderByWithRelationInput
    maker?: usersOrderByWithRelationInput
    taker?: usersOrderByWithRelationInput
    messages?: p2p_messagesOrderByRelationAggregateInput
    disputes?: p2p_disputesOrderByRelationAggregateInput
    ratings?: p2p_ratingsOrderByRelationAggregateInput
  }

  export type p2p_ordersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: p2p_ordersWhereInput | p2p_ordersWhereInput[]
    OR?: p2p_ordersWhereInput[]
    NOT?: p2p_ordersWhereInput | p2p_ordersWhereInput[]
    offer_id?: StringFilter<"p2p_orders"> | string
    maker_id?: StringFilter<"p2p_orders"> | string
    taker_id?: StringFilter<"p2p_orders"> | string
    side?: EnumP2POrderSideFilter<"p2p_orders"> | $Enums.P2POrderSide
    asset_symbol?: StringFilter<"p2p_orders"> | string
    fiat_currency?: StringFilter<"p2p_orders"> | string
    price?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFilter<"p2p_orders"> | $Enums.P2PTradeStatus
    escrow_held?: BoolFilter<"p2p_orders"> | boolean
    escrow_ledger_id?: StringNullableFilter<"p2p_orders"> | string | null
    reference_code?: StringNullableFilter<"p2p_orders"> | string | null
    meta?: JsonNullableFilter<"p2p_orders">
    expires_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    paid_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    released_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    canceled_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    created_at?: DateTimeFilter<"p2p_orders"> | Date | string
    updated_at?: DateTimeFilter<"p2p_orders"> | Date | string
    offer?: XOR<P2p_offersScalarRelationFilter, p2p_offersWhereInput>
    maker?: XOR<UsersScalarRelationFilter, usersWhereInput>
    taker?: XOR<UsersScalarRelationFilter, usersWhereInput>
    messages?: P2p_messagesListRelationFilter
    disputes?: P2p_disputesListRelationFilter
    ratings?: P2p_ratingsListRelationFilter
  }, "id">

  export type p2p_ordersOrderByWithAggregationInput = {
    id?: SortOrder
    offer_id?: SortOrder
    maker_id?: SortOrder
    taker_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    fiat_currency?: SortOrder
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
    status?: SortOrder
    escrow_held?: SortOrder
    escrow_ledger_id?: SortOrderInput | SortOrder
    reference_code?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    released_at?: SortOrderInput | SortOrder
    canceled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: p2p_ordersCountOrderByAggregateInput
    _avg?: p2p_ordersAvgOrderByAggregateInput
    _max?: p2p_ordersMaxOrderByAggregateInput
    _min?: p2p_ordersMinOrderByAggregateInput
    _sum?: p2p_ordersSumOrderByAggregateInput
  }

  export type p2p_ordersScalarWhereWithAggregatesInput = {
    AND?: p2p_ordersScalarWhereWithAggregatesInput | p2p_ordersScalarWhereWithAggregatesInput[]
    OR?: p2p_ordersScalarWhereWithAggregatesInput[]
    NOT?: p2p_ordersScalarWhereWithAggregatesInput | p2p_ordersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"p2p_orders"> | string
    offer_id?: StringWithAggregatesFilter<"p2p_orders"> | string
    maker_id?: StringWithAggregatesFilter<"p2p_orders"> | string
    taker_id?: StringWithAggregatesFilter<"p2p_orders"> | string
    side?: EnumP2POrderSideWithAggregatesFilter<"p2p_orders"> | $Enums.P2POrderSide
    asset_symbol?: StringWithAggregatesFilter<"p2p_orders"> | string
    fiat_currency?: StringWithAggregatesFilter<"p2p_orders"> | string
    price?: DecimalWithAggregatesFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalWithAggregatesFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalWithAggregatesFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusWithAggregatesFilter<"p2p_orders"> | $Enums.P2PTradeStatus
    escrow_held?: BoolWithAggregatesFilter<"p2p_orders"> | boolean
    escrow_ledger_id?: StringNullableWithAggregatesFilter<"p2p_orders"> | string | null
    reference_code?: StringNullableWithAggregatesFilter<"p2p_orders"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"p2p_orders">
    expires_at?: DateTimeNullableWithAggregatesFilter<"p2p_orders"> | Date | string | null
    paid_at?: DateTimeNullableWithAggregatesFilter<"p2p_orders"> | Date | string | null
    released_at?: DateTimeNullableWithAggregatesFilter<"p2p_orders"> | Date | string | null
    canceled_at?: DateTimeNullableWithAggregatesFilter<"p2p_orders"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"p2p_orders"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"p2p_orders"> | Date | string
  }

  export type p2p_messagesWhereInput = {
    AND?: p2p_messagesWhereInput | p2p_messagesWhereInput[]
    OR?: p2p_messagesWhereInput[]
    NOT?: p2p_messagesWhereInput | p2p_messagesWhereInput[]
    id?: StringFilter<"p2p_messages"> | string
    order_id?: StringFilter<"p2p_messages"> | string
    sender_id?: StringFilter<"p2p_messages"> | string
    message?: StringFilter<"p2p_messages"> | string
    attachments?: JsonNullableFilter<"p2p_messages">
    created_at?: DateTimeFilter<"p2p_messages"> | Date | string
    order?: XOR<P2p_ordersScalarRelationFilter, p2p_ordersWhereInput>
    sender?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type p2p_messagesOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    attachments?: SortOrderInput | SortOrder
    created_at?: SortOrder
    order?: p2p_ordersOrderByWithRelationInput
    sender?: usersOrderByWithRelationInput
  }

  export type p2p_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: p2p_messagesWhereInput | p2p_messagesWhereInput[]
    OR?: p2p_messagesWhereInput[]
    NOT?: p2p_messagesWhereInput | p2p_messagesWhereInput[]
    order_id?: StringFilter<"p2p_messages"> | string
    sender_id?: StringFilter<"p2p_messages"> | string
    message?: StringFilter<"p2p_messages"> | string
    attachments?: JsonNullableFilter<"p2p_messages">
    created_at?: DateTimeFilter<"p2p_messages"> | Date | string
    order?: XOR<P2p_ordersScalarRelationFilter, p2p_ordersWhereInput>
    sender?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type p2p_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    attachments?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: p2p_messagesCountOrderByAggregateInput
    _max?: p2p_messagesMaxOrderByAggregateInput
    _min?: p2p_messagesMinOrderByAggregateInput
  }

  export type p2p_messagesScalarWhereWithAggregatesInput = {
    AND?: p2p_messagesScalarWhereWithAggregatesInput | p2p_messagesScalarWhereWithAggregatesInput[]
    OR?: p2p_messagesScalarWhereWithAggregatesInput[]
    NOT?: p2p_messagesScalarWhereWithAggregatesInput | p2p_messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"p2p_messages"> | string
    order_id?: StringWithAggregatesFilter<"p2p_messages"> | string
    sender_id?: StringWithAggregatesFilter<"p2p_messages"> | string
    message?: StringWithAggregatesFilter<"p2p_messages"> | string
    attachments?: JsonNullableWithAggregatesFilter<"p2p_messages">
    created_at?: DateTimeWithAggregatesFilter<"p2p_messages"> | Date | string
  }

  export type p2p_disputesWhereInput = {
    AND?: p2p_disputesWhereInput | p2p_disputesWhereInput[]
    OR?: p2p_disputesWhereInput[]
    NOT?: p2p_disputesWhereInput | p2p_disputesWhereInput[]
    id?: StringFilter<"p2p_disputes"> | string
    order_id?: StringFilter<"p2p_disputes"> | string
    raised_by_user_id?: StringFilter<"p2p_disputes"> | string
    reason?: StringNullableFilter<"p2p_disputes"> | string | null
    description?: StringNullableFilter<"p2p_disputes"> | string | null
    status?: EnumP2PDisputeStatusFilter<"p2p_disputes"> | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: StringNullableFilter<"p2p_disputes"> | string | null
    resolution_note?: StringNullableFilter<"p2p_disputes"> | string | null
    resolved_at?: DateTimeNullableFilter<"p2p_disputes"> | Date | string | null
    attachments?: JsonNullableFilter<"p2p_disputes">
    created_at?: DateTimeFilter<"p2p_disputes"> | Date | string
    updated_at?: DateTimeFilter<"p2p_disputes"> | Date | string
    order?: XOR<P2p_ordersScalarRelationFilter, p2p_ordersWhereInput>
    raised_by?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type p2p_disputesOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    raised_by_user_id?: SortOrder
    reason?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    resolved_by_admin_id?: SortOrderInput | SortOrder
    resolution_note?: SortOrderInput | SortOrder
    resolved_at?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    order?: p2p_ordersOrderByWithRelationInput
    raised_by?: usersOrderByWithRelationInput
  }

  export type p2p_disputesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: p2p_disputesWhereInput | p2p_disputesWhereInput[]
    OR?: p2p_disputesWhereInput[]
    NOT?: p2p_disputesWhereInput | p2p_disputesWhereInput[]
    order_id?: StringFilter<"p2p_disputes"> | string
    raised_by_user_id?: StringFilter<"p2p_disputes"> | string
    reason?: StringNullableFilter<"p2p_disputes"> | string | null
    description?: StringNullableFilter<"p2p_disputes"> | string | null
    status?: EnumP2PDisputeStatusFilter<"p2p_disputes"> | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: StringNullableFilter<"p2p_disputes"> | string | null
    resolution_note?: StringNullableFilter<"p2p_disputes"> | string | null
    resolved_at?: DateTimeNullableFilter<"p2p_disputes"> | Date | string | null
    attachments?: JsonNullableFilter<"p2p_disputes">
    created_at?: DateTimeFilter<"p2p_disputes"> | Date | string
    updated_at?: DateTimeFilter<"p2p_disputes"> | Date | string
    order?: XOR<P2p_ordersScalarRelationFilter, p2p_ordersWhereInput>
    raised_by?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type p2p_disputesOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    raised_by_user_id?: SortOrder
    reason?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    resolved_by_admin_id?: SortOrderInput | SortOrder
    resolution_note?: SortOrderInput | SortOrder
    resolved_at?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: p2p_disputesCountOrderByAggregateInput
    _max?: p2p_disputesMaxOrderByAggregateInput
    _min?: p2p_disputesMinOrderByAggregateInput
  }

  export type p2p_disputesScalarWhereWithAggregatesInput = {
    AND?: p2p_disputesScalarWhereWithAggregatesInput | p2p_disputesScalarWhereWithAggregatesInput[]
    OR?: p2p_disputesScalarWhereWithAggregatesInput[]
    NOT?: p2p_disputesScalarWhereWithAggregatesInput | p2p_disputesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"p2p_disputes"> | string
    order_id?: StringWithAggregatesFilter<"p2p_disputes"> | string
    raised_by_user_id?: StringWithAggregatesFilter<"p2p_disputes"> | string
    reason?: StringNullableWithAggregatesFilter<"p2p_disputes"> | string | null
    description?: StringNullableWithAggregatesFilter<"p2p_disputes"> | string | null
    status?: EnumP2PDisputeStatusWithAggregatesFilter<"p2p_disputes"> | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: StringNullableWithAggregatesFilter<"p2p_disputes"> | string | null
    resolution_note?: StringNullableWithAggregatesFilter<"p2p_disputes"> | string | null
    resolved_at?: DateTimeNullableWithAggregatesFilter<"p2p_disputes"> | Date | string | null
    attachments?: JsonNullableWithAggregatesFilter<"p2p_disputes">
    created_at?: DateTimeWithAggregatesFilter<"p2p_disputes"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"p2p_disputes"> | Date | string
  }

  export type p2p_ratingsWhereInput = {
    AND?: p2p_ratingsWhereInput | p2p_ratingsWhereInput[]
    OR?: p2p_ratingsWhereInput[]
    NOT?: p2p_ratingsWhereInput | p2p_ratingsWhereInput[]
    id?: StringFilter<"p2p_ratings"> | string
    order_id?: StringFilter<"p2p_ratings"> | string
    from_user_id?: StringFilter<"p2p_ratings"> | string
    to_user_id?: StringFilter<"p2p_ratings"> | string
    stars?: IntFilter<"p2p_ratings"> | number
    comment?: StringNullableFilter<"p2p_ratings"> | string | null
    created_at?: DateTimeFilter<"p2p_ratings"> | Date | string
    order?: XOR<P2p_ordersScalarRelationFilter, p2p_ordersWhereInput>
    from_user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    to_user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type p2p_ratingsOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    stars?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    order?: p2p_ordersOrderByWithRelationInput
    from_user?: usersOrderByWithRelationInput
    to_user?: usersOrderByWithRelationInput
  }

  export type p2p_ratingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: p2p_ratingsWhereInput | p2p_ratingsWhereInput[]
    OR?: p2p_ratingsWhereInput[]
    NOT?: p2p_ratingsWhereInput | p2p_ratingsWhereInput[]
    order_id?: StringFilter<"p2p_ratings"> | string
    from_user_id?: StringFilter<"p2p_ratings"> | string
    to_user_id?: StringFilter<"p2p_ratings"> | string
    stars?: IntFilter<"p2p_ratings"> | number
    comment?: StringNullableFilter<"p2p_ratings"> | string | null
    created_at?: DateTimeFilter<"p2p_ratings"> | Date | string
    order?: XOR<P2p_ordersScalarRelationFilter, p2p_ordersWhereInput>
    from_user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    to_user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type p2p_ratingsOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    stars?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: p2p_ratingsCountOrderByAggregateInput
    _avg?: p2p_ratingsAvgOrderByAggregateInput
    _max?: p2p_ratingsMaxOrderByAggregateInput
    _min?: p2p_ratingsMinOrderByAggregateInput
    _sum?: p2p_ratingsSumOrderByAggregateInput
  }

  export type p2p_ratingsScalarWhereWithAggregatesInput = {
    AND?: p2p_ratingsScalarWhereWithAggregatesInput | p2p_ratingsScalarWhereWithAggregatesInput[]
    OR?: p2p_ratingsScalarWhereWithAggregatesInput[]
    NOT?: p2p_ratingsScalarWhereWithAggregatesInput | p2p_ratingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"p2p_ratings"> | string
    order_id?: StringWithAggregatesFilter<"p2p_ratings"> | string
    from_user_id?: StringWithAggregatesFilter<"p2p_ratings"> | string
    to_user_id?: StringWithAggregatesFilter<"p2p_ratings"> | string
    stars?: IntWithAggregatesFilter<"p2p_ratings"> | number
    comment?: StringNullableWithAggregatesFilter<"p2p_ratings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"p2p_ratings"> | Date | string
  }

  export type currency_pairsCreateInput = {
    id?: string
    base: string
    quote: string
    symbol: string
    display?: string | null
    provider?: string | null
    provider_symbol?: string | null
    price_decimals?: number | null
    status?: $Enums.PairStatus
    payout?: number | null
    latest_price?: Decimal | DecimalJsLike | number | string | null
    last_updated?: Date | string | null
    isDeleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type currency_pairsUncheckedCreateInput = {
    id?: string
    base: string
    quote: string
    symbol: string
    display?: string | null
    provider?: string | null
    provider_symbol?: string | null
    price_decimals?: number | null
    status?: $Enums.PairStatus
    payout?: number | null
    latest_price?: Decimal | DecimalJsLike | number | string | null
    last_updated?: Date | string | null
    isDeleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type currency_pairsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    base?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    provider_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    price_decimals?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPairStatusFieldUpdateOperationsInput | $Enums.PairStatus
    payout?: NullableIntFieldUpdateOperationsInput | number | null
    latest_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type currency_pairsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    base?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    provider_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    price_decimals?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPairStatusFieldUpdateOperationsInput | $Enums.PairStatus
    payout?: NullableIntFieldUpdateOperationsInput | number | null
    latest_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type currency_pairsCreateManyInput = {
    id?: string
    base: string
    quote: string
    symbol: string
    display?: string | null
    provider?: string | null
    provider_symbol?: string | null
    price_decimals?: number | null
    status?: $Enums.PairStatus
    payout?: number | null
    latest_price?: Decimal | DecimalJsLike | number | string | null
    last_updated?: Date | string | null
    isDeleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type currency_pairsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    base?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    provider_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    price_decimals?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPairStatusFieldUpdateOperationsInput | $Enums.PairStatus
    payout?: NullableIntFieldUpdateOperationsInput | number | null
    latest_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type currency_pairsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    base?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    provider_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    price_decimals?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPairStatusFieldUpdateOperationsInput | $Enums.PairStatus
    payout?: NullableIntFieldUpdateOperationsInput | number | null
    latest_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type forex_candlesCreateInput = {
    id?: string
    symbol: string
    interval: string
    time: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type forex_candlesUncheckedCreateInput = {
    id?: string
    symbol: string
    interval: string
    time: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type forex_candlesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type forex_candlesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type forex_candlesCreateManyInput = {
    id?: string
    symbol: string
    interval: string
    time: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type forex_candlesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type forex_candlesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type depositsCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    status?: string | null
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutDepositsInput
  }

  export type depositsUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type depositsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutDepositsNestedInput
  }

  export type depositsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositsCreateManyInput = {
    id?: string
    user_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type depositsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalsCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutWithdrawalsInput
  }

  export type withdrawalsUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    created_at?: Date | string
  }

  export type withdrawalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutWithdrawalsNestedInput
  }

  export type withdrawalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalsCreateManyInput = {
    id?: string
    user_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    created_at?: Date | string
  }

  export type withdrawalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tradesCreateInput = {
    id?: string
    symbol?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    direction?: string | null
    open_time?: Date | string | null
    close_time?: Date | string | null
    result?: string | null
    status?: string | null
    entry_price?: Decimal | DecimalJsLike | number | string | null
    payout?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    account_type?: string | null
    users?: usersCreateNestedOneWithoutTradesInput
  }

  export type tradesUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    symbol?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    direction?: string | null
    open_time?: Date | string | null
    close_time?: Date | string | null
    result?: string | null
    status?: string | null
    entry_price?: Decimal | DecimalJsLike | number | string | null
    payout?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    account_type?: string | null
  }

  export type tradesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneWithoutTradesNestedInput
  }

  export type tradesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tradesCreateManyInput = {
    id?: string
    user_id?: string | null
    symbol?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    direction?: string | null
    open_time?: Date | string | null
    close_time?: Date | string | null
    result?: string | null
    status?: string | null
    entry_price?: Decimal | DecimalJsLike | number | string | null
    payout?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    account_type?: string | null
  }

  export type tradesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tradesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type leaderboardCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    updated_at?: Date | string
    users?: usersCreateNestedOneWithoutLeaderboardInput
  }

  export type leaderboardUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    updated_at?: Date | string
  }

  export type leaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutLeaderboardNestedInput
  }

  export type leaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaderboardCreateManyInput = {
    id?: string
    user_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    updated_at?: Date | string
  }

  export type leaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsCreateInput = {
    id?: string
    title?: string | null
    prize_pool?: Decimal | DecimalJsLike | number | string | null
    entry_fee?: Decimal | DecimalJsLike | number | string | null
    participants?: number | null
    duration?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type tournamentsUncheckedCreateInput = {
    id?: string
    title?: string | null
    prize_pool?: Decimal | DecimalJsLike | number | string | null
    entry_fee?: Decimal | DecimalJsLike | number | string | null
    participants?: number | null
    duration?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type tournamentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prize_pool?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    entry_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    participants?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prize_pool?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    entry_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    participants?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsCreateManyInput = {
    id?: string
    title?: string | null
    prize_pool?: Decimal | DecimalJsLike | number | string | null
    entry_fee?: Decimal | DecimalJsLike | number | string | null
    participants?: number | null
    duration?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type tournamentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prize_pool?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    entry_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    participants?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prize_pool?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    entry_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    participants?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_messagesCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutSupport_messagesInput
  }

  export type support_messagesUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type support_messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutSupport_messagesNestedInput
  }

  export type support_messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_messagesCreateManyInput = {
    id?: string
    user_id?: string | null
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type support_messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateInput = {
    id?: string
    sender?: string | null
    message?: string | null
    time?: Date | string
    users?: usersCreateNestedOneWithoutChat_messagesInput
  }

  export type chat_messagesUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    sender?: string | null
    message?: string | null
    time?: Date | string
  }

  export type chat_messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutChat_messagesNestedInput
  }

  export type chat_messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateManyInput = {
    id?: string
    user_id?: string | null
    sender?: string | null
    message?: string | null
    time?: Date | string
  }

  export type chat_messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsCreateInput = {
    id?: string
    notifications?: boolean | null
    private?: boolean | null
    users?: usersCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    notifications?: boolean | null
    private?: boolean | null
  }

  export type settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type settingsCreateManyInput = {
    id?: string
    user_id?: string | null
    notifications?: boolean | null
    private?: boolean | null
  }

  export type settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type crypto_assetsCreateInput = {
    id?: string
    symbol: string
    network: string
    display_name?: string | null
    contract?: string | null
    decimals?: number
    min_deposit?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutCrypto_assetsInput
  }

  export type crypto_assetsUncheckedCreateInput = {
    id?: string
    symbol: string
    network: string
    display_name?: string | null
    contract?: string | null
    decimals?: number
    min_deposit?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutCrypto_assetsInput
  }

  export type crypto_assetsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    min_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deposit_sessions?: deposit_sessionsUpdateManyWithoutCrypto_assetsNestedInput
  }

  export type crypto_assetsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    min_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutCrypto_assetsNestedInput
  }

  export type crypto_assetsCreateManyInput = {
    id?: string
    symbol: string
    network: string
    display_name?: string | null
    contract?: string | null
    decimals?: number
    min_deposit?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type crypto_assetsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    min_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type crypto_assetsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    min_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsCreateInput = {
    id?: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutDeposit_sessionsInput
    crypto_assets: crypto_assetsCreateNestedOneWithoutDeposit_sessionsInput
  }

  export type deposit_sessionsUncheckedCreateInput = {
    id?: string
    user_id: string
    crypto_asset_id: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type deposit_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutDeposit_sessionsNestedInput
    crypto_assets?: crypto_assetsUpdateOneRequiredWithoutDeposit_sessionsNestedInput
  }

  export type deposit_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsCreateManyInput = {
    id?: string
    user_id: string
    crypto_asset_id: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type deposit_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_ledgerCreateInput = {
    id?: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    users: usersCreateNestedOneWithoutWallet_ledgerInput
  }

  export type wallet_ledgerUncheckedCreateInput = {
    id?: string
    user_id: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type wallet_ledgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutWallet_ledgerNestedInput
  }

  export type wallet_ledgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_ledgerCreateManyInput = {
    id?: string
    user_id: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type wallet_ledgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_ledgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_method_templatesCreateInput = {
    id?: string
    title: string
    type: $Enums.PaymentMethodType
    fields: JsonNullValueInput | InputJsonValue
    currency: string
    country: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_method_templatesUncheckedCreateInput = {
    id?: string
    title: string
    type: $Enums.PaymentMethodType
    fields: JsonNullValueInput | InputJsonValue
    currency: string
    country: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_method_templatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    fields?: JsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_method_templatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    fields?: JsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_method_templatesCreateManyInput = {
    id?: string
    title: string
    type: $Enums.PaymentMethodType
    fields: JsonNullValueInput | InputJsonValue
    currency: string
    country: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_method_templatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    fields?: JsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_method_templatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    fields?: JsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offersCreateInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutP2p_offersInput
    payment_methods?: p2p_offer_payment_methodsCreateNestedManyWithoutOfferInput
    orders?: p2p_ordersCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersUncheckedCreateInput = {
    id?: string
    user_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    payment_methods?: p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutOfferInput
    orders?: p2p_ordersUncheckedCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutP2p_offersNestedInput
    payment_methods?: p2p_offer_payment_methodsUpdateManyWithoutOfferNestedInput
    orders?: p2p_ordersUpdateManyWithoutOfferNestedInput
  }

  export type p2p_offersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_methods?: p2p_offer_payment_methodsUncheckedUpdateManyWithoutOfferNestedInput
    orders?: p2p_ordersUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type p2p_offersCreateManyInput = {
    id?: string
    user_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_offersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsCreateInput = {
    id?: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutUser_payment_methodsInput
    offers?: p2p_offer_payment_methodsCreateNestedManyWithoutPayment_methodInput
  }

  export type user_payment_methodsUncheckedCreateInput = {
    id?: string
    user_id: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    offers?: p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type user_payment_methodsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_payment_methodsNestedInput
    offers?: p2p_offer_payment_methodsUpdateManyWithoutPayment_methodNestedInput
  }

  export type user_payment_methodsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: p2p_offer_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type user_payment_methodsCreateManyInput = {
    id?: string
    user_id: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_payment_methodsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offer_payment_methodsCreateInput = {
    id?: string
    offer: p2p_offersCreateNestedOneWithoutPayment_methodsInput
    payment_method: user_payment_methodsCreateNestedOneWithoutOffersInput
  }

  export type p2p_offer_payment_methodsUncheckedCreateInput = {
    id?: string
    offer_id: string
    payment_method_id: string
  }

  export type p2p_offer_payment_methodsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer?: p2p_offersUpdateOneRequiredWithoutPayment_methodsNestedInput
    payment_method?: user_payment_methodsUpdateOneRequiredWithoutOffersNestedInput
  }

  export type p2p_offer_payment_methodsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_offer_payment_methodsCreateManyInput = {
    id?: string
    offer_id: string
    payment_method_id: string
  }

  export type p2p_offer_payment_methodsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_offer_payment_methodsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_ordersCreateInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    offer: p2p_offersCreateNestedOneWithoutOrdersInput
    maker: usersCreateNestedOneWithoutP2p_maker_ordersInput
    taker: usersCreateNestedOneWithoutP2p_taker_ordersInput
    messages?: p2p_messagesCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateInput = {
    id?: string
    offer_id: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    messages?: p2p_messagesUncheckedCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesUncheckedCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: p2p_offersUpdateOneRequiredWithoutOrdersNestedInput
    maker?: usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput
    taker?: usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput
    messages?: p2p_messagesUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersCreateManyInput = {
    id?: string
    offer_id: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_ordersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ordersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_messagesCreateInput = {
    id?: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutMessagesInput
    sender: usersCreateNestedOneWithoutP2p_messages_sentInput
  }

  export type p2p_messagesUncheckedCreateInput = {
    id?: string
    order_id: string
    sender_id: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutMessagesNestedInput
    sender?: usersUpdateOneRequiredWithoutP2p_messages_sentNestedInput
  }

  export type p2p_messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_messagesCreateManyInput = {
    id?: string
    order_id: string
    sender_id: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesCreateInput = {
    id?: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutDisputesInput
    raised_by: usersCreateNestedOneWithoutP2p_disputes_raisedInput
  }

  export type p2p_disputesUncheckedCreateInput = {
    id?: string
    order_id: string
    raised_by_user_id: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_disputesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutDisputesNestedInput
    raised_by?: usersUpdateOneRequiredWithoutP2p_disputes_raisedNestedInput
  }

  export type p2p_disputesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    raised_by_user_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesCreateManyInput = {
    id?: string
    order_id: string
    raised_by_user_id: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_disputesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    raised_by_user_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsCreateInput = {
    id?: string
    stars: number
    comment?: string | null
    created_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutRatingsInput
    from_user: usersCreateNestedOneWithoutP2p_ratings_fromInput
    to_user: usersCreateNestedOneWithoutP2p_ratings_toInput
  }

  export type p2p_ratingsUncheckedCreateInput = {
    id?: string
    order_id: string
    from_user_id: string
    to_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_ratingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutRatingsNestedInput
    from_user?: usersUpdateOneRequiredWithoutP2p_ratings_fromNestedInput
    to_user?: usersUpdateOneRequiredWithoutP2p_ratings_toNestedInput
  }

  export type p2p_ratingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsCreateManyInput = {
    id?: string
    order_id: string
    from_user_id: string
    to_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_ratingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumPairStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PairStatus | EnumPairStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PairStatus[]
    notIn?: $Enums.PairStatus[]
    not?: NestedEnumPairStatusFilter<$PrismaModel> | $Enums.PairStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type currency_pairsCountOrderByAggregateInput = {
    id?: SortOrder
    base?: SortOrder
    quote?: SortOrder
    symbol?: SortOrder
    display?: SortOrder
    provider?: SortOrder
    provider_symbol?: SortOrder
    price_decimals?: SortOrder
    status?: SortOrder
    payout?: SortOrder
    latest_price?: SortOrder
    last_updated?: SortOrder
    isDeleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currency_pairsAvgOrderByAggregateInput = {
    price_decimals?: SortOrder
    payout?: SortOrder
    latest_price?: SortOrder
  }

  export type currency_pairsMaxOrderByAggregateInput = {
    id?: SortOrder
    base?: SortOrder
    quote?: SortOrder
    symbol?: SortOrder
    display?: SortOrder
    provider?: SortOrder
    provider_symbol?: SortOrder
    price_decimals?: SortOrder
    status?: SortOrder
    payout?: SortOrder
    latest_price?: SortOrder
    last_updated?: SortOrder
    isDeleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currency_pairsMinOrderByAggregateInput = {
    id?: SortOrder
    base?: SortOrder
    quote?: SortOrder
    symbol?: SortOrder
    display?: SortOrder
    provider?: SortOrder
    provider_symbol?: SortOrder
    price_decimals?: SortOrder
    status?: SortOrder
    payout?: SortOrder
    latest_price?: SortOrder
    last_updated?: SortOrder
    isDeleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currency_pairsSumOrderByAggregateInput = {
    price_decimals?: SortOrder
    payout?: SortOrder
    latest_price?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPairStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PairStatus | EnumPairStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PairStatus[]
    notIn?: $Enums.PairStatus[]
    not?: NestedEnumPairStatusWithAggregatesFilter<$PrismaModel> | $Enums.PairStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPairStatusFilter<$PrismaModel>
    _max?: NestedEnumPairStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type forex_candlesSymbolIntervalTimeCompoundUniqueInput = {
    symbol: string
    interval: string
    time: Date | string
  }

  export type forex_candlesCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    interval?: SortOrder
    time?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type forex_candlesAvgOrderByAggregateInput = {
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
  }

  export type forex_candlesMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    interval?: SortOrder
    time?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type forex_candlesMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    interval?: SortOrder
    time?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type forex_candlesSumOrderByAggregateInput = {
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Chat_messagesListRelationFilter = {
    every?: chat_messagesWhereInput
    some?: chat_messagesWhereInput
    none?: chat_messagesWhereInput
  }

  export type DepositsListRelationFilter = {
    every?: depositsWhereInput
    some?: depositsWhereInput
    none?: depositsWhereInput
  }

  export type LeaderboardListRelationFilter = {
    every?: leaderboardWhereInput
    some?: leaderboardWhereInput
    none?: leaderboardWhereInput
  }

  export type SettingsListRelationFilter = {
    every?: settingsWhereInput
    some?: settingsWhereInput
    none?: settingsWhereInput
  }

  export type Support_messagesListRelationFilter = {
    every?: support_messagesWhereInput
    some?: support_messagesWhereInput
    none?: support_messagesWhereInput
  }

  export type TradesListRelationFilter = {
    every?: tradesWhereInput
    some?: tradesWhereInput
    none?: tradesWhereInput
  }

  export type WithdrawalsListRelationFilter = {
    every?: withdrawalsWhereInput
    some?: withdrawalsWhereInput
    none?: withdrawalsWhereInput
  }

  export type Deposit_sessionsListRelationFilter = {
    every?: deposit_sessionsWhereInput
    some?: deposit_sessionsWhereInput
    none?: deposit_sessionsWhereInput
  }

  export type Wallet_ledgerListRelationFilter = {
    every?: wallet_ledgerWhereInput
    some?: wallet_ledgerWhereInput
    none?: wallet_ledgerWhereInput
  }

  export type P2p_offersListRelationFilter = {
    every?: p2p_offersWhereInput
    some?: p2p_offersWhereInput
    none?: p2p_offersWhereInput
  }

  export type User_payment_methodsListRelationFilter = {
    every?: user_payment_methodsWhereInput
    some?: user_payment_methodsWhereInput
    none?: user_payment_methodsWhereInput
  }

  export type P2p_ordersListRelationFilter = {
    every?: p2p_ordersWhereInput
    some?: p2p_ordersWhereInput
    none?: p2p_ordersWhereInput
  }

  export type P2p_messagesListRelationFilter = {
    every?: p2p_messagesWhereInput
    some?: p2p_messagesWhereInput
    none?: p2p_messagesWhereInput
  }

  export type P2p_disputesListRelationFilter = {
    every?: p2p_disputesWhereInput
    some?: p2p_disputesWhereInput
    none?: p2p_disputesWhereInput
  }

  export type P2p_ratingsListRelationFilter = {
    every?: p2p_ratingsWhereInput
    some?: p2p_ratingsWhereInput
    none?: p2p_ratingsWhereInput
  }

  export type chat_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type depositsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type leaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type support_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tradesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type withdrawalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deposit_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wallet_ledgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2p_offersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_payment_methodsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2p_ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2p_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2p_disputesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2p_ratingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    date_of_birth?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    balance?: SortOrder
    is_verified?: SortOrder
    is_admin?: SortOrder
    is_suspended?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    demo_balance?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    balance?: SortOrder
    demo_balance?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    date_of_birth?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    balance?: SortOrder
    is_verified?: SortOrder
    is_admin?: SortOrder
    is_suspended?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    demo_balance?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    date_of_birth?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    balance?: SortOrder
    is_verified?: SortOrder
    is_admin?: SortOrder
    is_suspended?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    demo_balance?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    balance?: SortOrder
    demo_balance?: SortOrder
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type depositsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type depositsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type depositsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type depositsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type depositsSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type withdrawalsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    account_info?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type withdrawalsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type withdrawalsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type withdrawalsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type withdrawalsSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type tradesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    direction?: SortOrder
    open_time?: SortOrder
    close_time?: SortOrder
    result?: SortOrder
    status?: SortOrder
    entry_price?: SortOrder
    payout?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_type?: SortOrder
  }

  export type tradesAvgOrderByAggregateInput = {
    amount?: SortOrder
    entry_price?: SortOrder
    payout?: SortOrder
  }

  export type tradesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    direction?: SortOrder
    open_time?: SortOrder
    close_time?: SortOrder
    result?: SortOrder
    status?: SortOrder
    entry_price?: SortOrder
    payout?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_type?: SortOrder
  }

  export type tradesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    direction?: SortOrder
    open_time?: SortOrder
    close_time?: SortOrder
    result?: SortOrder
    status?: SortOrder
    entry_price?: SortOrder
    payout?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_type?: SortOrder
  }

  export type tradesSumOrderByAggregateInput = {
    amount?: SortOrder
    entry_price?: SortOrder
    payout?: SortOrder
  }

  export type leaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    rank?: SortOrder
    updated_at?: SortOrder
  }

  export type leaderboardAvgOrderByAggregateInput = {
    amount?: SortOrder
    rank?: SortOrder
  }

  export type leaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    rank?: SortOrder
    updated_at?: SortOrder
  }

  export type leaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    rank?: SortOrder
    updated_at?: SortOrder
  }

  export type leaderboardSumOrderByAggregateInput = {
    amount?: SortOrder
    rank?: SortOrder
  }

  export type tournamentsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    prize_pool?: SortOrder
    entry_fee?: SortOrder
    participants?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type tournamentsAvgOrderByAggregateInput = {
    prize_pool?: SortOrder
    entry_fee?: SortOrder
    participants?: SortOrder
  }

  export type tournamentsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    prize_pool?: SortOrder
    entry_fee?: SortOrder
    participants?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type tournamentsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    prize_pool?: SortOrder
    entry_fee?: SortOrder
    participants?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type tournamentsSumOrderByAggregateInput = {
    prize_pool?: SortOrder
    entry_fee?: SortOrder
    participants?: SortOrder
  }

  export type support_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type support_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type support_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type chat_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    time?: SortOrder
  }

  export type chat_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    time?: SortOrder
  }

  export type chat_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    time?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notifications?: SortOrder
    private?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notifications?: SortOrder
    private?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notifications?: SortOrder
    private?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type crypto_assetsSymbolNetworkCompoundUniqueInput = {
    symbol: string
    network: string
  }

  export type crypto_assetsCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    display_name?: SortOrder
    contract?: SortOrder
    decimals?: SortOrder
    min_deposit?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crypto_assetsAvgOrderByAggregateInput = {
    decimals?: SortOrder
    min_deposit?: SortOrder
  }

  export type crypto_assetsMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    display_name?: SortOrder
    contract?: SortOrder
    decimals?: SortOrder
    min_deposit?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crypto_assetsMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    display_name?: SortOrder
    contract?: SortOrder
    decimals?: SortOrder
    min_deposit?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crypto_assetsSumOrderByAggregateInput = {
    decimals?: SortOrder
    min_deposit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDepositSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositSessionStatus | EnumDepositSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositSessionStatus[]
    notIn?: $Enums.DepositSessionStatus[]
    not?: NestedEnumDepositSessionStatusFilter<$PrismaModel> | $Enums.DepositSessionStatus
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type Crypto_assetsScalarRelationFilter = {
    is?: crypto_assetsWhereInput
    isNot?: crypto_assetsWhereInput
  }

  export type deposit_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    crypto_asset_id?: SortOrder
    address?: SortOrder
    derivation_path?: SortOrder
    memo_tag?: SortOrder
    amount_expected?: SortOrder
    fiat_locked_usd?: SortOrder
    rate_source?: SortOrder
    status?: SortOrder
    tx_hash?: SortOrder
    detected_amount?: SortOrder
    confirmations?: SortOrder
    min_confirmations?: SortOrder
    is_late?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type deposit_sessionsAvgOrderByAggregateInput = {
    amount_expected?: SortOrder
    fiat_locked_usd?: SortOrder
    detected_amount?: SortOrder
    confirmations?: SortOrder
    min_confirmations?: SortOrder
  }

  export type deposit_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    crypto_asset_id?: SortOrder
    address?: SortOrder
    derivation_path?: SortOrder
    memo_tag?: SortOrder
    amount_expected?: SortOrder
    fiat_locked_usd?: SortOrder
    rate_source?: SortOrder
    status?: SortOrder
    tx_hash?: SortOrder
    detected_amount?: SortOrder
    confirmations?: SortOrder
    min_confirmations?: SortOrder
    is_late?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type deposit_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    crypto_asset_id?: SortOrder
    address?: SortOrder
    derivation_path?: SortOrder
    memo_tag?: SortOrder
    amount_expected?: SortOrder
    fiat_locked_usd?: SortOrder
    rate_source?: SortOrder
    status?: SortOrder
    tx_hash?: SortOrder
    detected_amount?: SortOrder
    confirmations?: SortOrder
    min_confirmations?: SortOrder
    is_late?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type deposit_sessionsSumOrderByAggregateInput = {
    amount_expected?: SortOrder
    fiat_locked_usd?: SortOrder
    detected_amount?: SortOrder
    confirmations?: SortOrder
    min_confirmations?: SortOrder
  }

  export type EnumDepositSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositSessionStatus | EnumDepositSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositSessionStatus[]
    notIn?: $Enums.DepositSessionStatus[]
    not?: NestedEnumDepositSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.DepositSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumDepositSessionStatusFilter<$PrismaModel>
  }

  export type EnumLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[]
    notIn?: $Enums.LedgerType[]
    not?: NestedEnumLedgerTypeFilter<$PrismaModel> | $Enums.LedgerType
  }

  export type wallet_ledgerCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    meta?: SortOrder
    created_at?: SortOrder
  }

  export type wallet_ledgerAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type wallet_ledgerMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
  }

  export type wallet_ledgerMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
  }

  export type wallet_ledgerSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[]
    notIn?: $Enums.LedgerType[]
    not?: NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type payment_method_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fields?: SortOrder
    currency?: SortOrder
    country?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_method_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    country?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_method_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    country?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumP2POrderSideFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POrderSide | EnumP2POrderSideFieldRefInput<$PrismaModel>
    in?: $Enums.P2POrderSide[]
    notIn?: $Enums.P2POrderSide[]
    not?: NestedEnumP2POrderSideFilter<$PrismaModel> | $Enums.P2POrderSide
  }

  export type EnumP2POfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POfferStatus | EnumP2POfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2POfferStatus[]
    notIn?: $Enums.P2POfferStatus[]
    not?: NestedEnumP2POfferStatusFilter<$PrismaModel> | $Enums.P2POfferStatus
  }

  export type P2p_offer_payment_methodsListRelationFilter = {
    every?: p2p_offer_payment_methodsWhereInput
    some?: p2p_offer_payment_methodsWhereInput
    none?: p2p_offer_payment_methodsWhereInput
  }

  export type p2p_offer_payment_methodsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2p_offersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    crypto_asset_id?: SortOrder
    fiat_currency?: SortOrder
    price_type?: SortOrder
    fixed_price?: SortOrder
    margin_percent?: SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    terms?: SortOrder
    auto_reply?: SortOrder
    status?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_offersAvgOrderByAggregateInput = {
    fixed_price?: SortOrder
    margin_percent?: SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
  }

  export type p2p_offersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    crypto_asset_id?: SortOrder
    fiat_currency?: SortOrder
    price_type?: SortOrder
    fixed_price?: SortOrder
    margin_percent?: SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    terms?: SortOrder
    auto_reply?: SortOrder
    status?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_offersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    crypto_asset_id?: SortOrder
    fiat_currency?: SortOrder
    price_type?: SortOrder
    fixed_price?: SortOrder
    margin_percent?: SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    terms?: SortOrder
    auto_reply?: SortOrder
    status?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_offersSumOrderByAggregateInput = {
    fixed_price?: SortOrder
    margin_percent?: SortOrder
    min_amount_asset?: SortOrder
    max_amount_asset?: SortOrder
    min_limit_fiat?: SortOrder
    max_limit_fiat?: SortOrder
    total_trades?: SortOrder
    completion_rate?: SortOrder
  }

  export type EnumP2POrderSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POrderSide | EnumP2POrderSideFieldRefInput<$PrismaModel>
    in?: $Enums.P2POrderSide[]
    notIn?: $Enums.P2POrderSide[]
    not?: NestedEnumP2POrderSideWithAggregatesFilter<$PrismaModel> | $Enums.P2POrderSide
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2POrderSideFilter<$PrismaModel>
    _max?: NestedEnumP2POrderSideFilter<$PrismaModel>
  }

  export type EnumP2POfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POfferStatus | EnumP2POfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2POfferStatus[]
    notIn?: $Enums.P2POfferStatus[]
    not?: NestedEnumP2POfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2POfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2POfferStatusFilter<$PrismaModel>
    _max?: NestedEnumP2POfferStatusFilter<$PrismaModel>
  }

  export type user_payment_methodsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    details?: SortOrder
    is_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_payment_methodsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    is_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_payment_methodsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    is_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type P2p_offersScalarRelationFilter = {
    is?: p2p_offersWhereInput
    isNot?: p2p_offersWhereInput
  }

  export type User_payment_methodsScalarRelationFilter = {
    is?: user_payment_methodsWhereInput
    isNot?: user_payment_methodsWhereInput
  }

  export type p2p_offer_payment_methodsOffer_idPayment_method_idCompoundUniqueInput = {
    offer_id: string
    payment_method_id: string
  }

  export type p2p_offer_payment_methodsCountOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    payment_method_id?: SortOrder
  }

  export type p2p_offer_payment_methodsMaxOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    payment_method_id?: SortOrder
  }

  export type p2p_offer_payment_methodsMinOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    payment_method_id?: SortOrder
  }

  export type EnumP2PTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PTradeStatus | EnumP2PTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PTradeStatus[]
    notIn?: $Enums.P2PTradeStatus[]
    not?: NestedEnumP2PTradeStatusFilter<$PrismaModel> | $Enums.P2PTradeStatus
  }

  export type p2p_ordersCountOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    maker_id?: SortOrder
    taker_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    fiat_currency?: SortOrder
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
    status?: SortOrder
    escrow_held?: SortOrder
    escrow_ledger_id?: SortOrder
    reference_code?: SortOrder
    meta?: SortOrder
    expires_at?: SortOrder
    paid_at?: SortOrder
    released_at?: SortOrder
    canceled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_ordersAvgOrderByAggregateInput = {
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
  }

  export type p2p_ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    maker_id?: SortOrder
    taker_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    fiat_currency?: SortOrder
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
    status?: SortOrder
    escrow_held?: SortOrder
    escrow_ledger_id?: SortOrder
    reference_code?: SortOrder
    expires_at?: SortOrder
    paid_at?: SortOrder
    released_at?: SortOrder
    canceled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_ordersMinOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    maker_id?: SortOrder
    taker_id?: SortOrder
    side?: SortOrder
    asset_symbol?: SortOrder
    fiat_currency?: SortOrder
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
    status?: SortOrder
    escrow_held?: SortOrder
    escrow_ledger_id?: SortOrder
    reference_code?: SortOrder
    expires_at?: SortOrder
    paid_at?: SortOrder
    released_at?: SortOrder
    canceled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_ordersSumOrderByAggregateInput = {
    price?: SortOrder
    amount_asset?: SortOrder
    amount_fiat?: SortOrder
  }

  export type EnumP2PTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PTradeStatus | EnumP2PTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PTradeStatus[]
    notIn?: $Enums.P2PTradeStatus[]
    not?: NestedEnumP2PTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2PTradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2PTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumP2PTradeStatusFilter<$PrismaModel>
  }

  export type P2p_ordersScalarRelationFilter = {
    is?: p2p_ordersWhereInput
    isNot?: p2p_ordersWhereInput
  }

  export type p2p_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
  }

  export type p2p_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type p2p_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type EnumP2PDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PDisputeStatus | EnumP2PDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PDisputeStatus[]
    notIn?: $Enums.P2PDisputeStatus[]
    not?: NestedEnumP2PDisputeStatusFilter<$PrismaModel> | $Enums.P2PDisputeStatus
  }

  export type p2p_disputesCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    raised_by_user_id?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolved_by_admin_id?: SortOrder
    resolution_note?: SortOrder
    resolved_at?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_disputesMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    raised_by_user_id?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolved_by_admin_id?: SortOrder
    resolution_note?: SortOrder
    resolved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p2p_disputesMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    raised_by_user_id?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolved_by_admin_id?: SortOrder
    resolution_note?: SortOrder
    resolved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumP2PDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PDisputeStatus | EnumP2PDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PDisputeStatus[]
    notIn?: $Enums.P2PDisputeStatus[]
    not?: NestedEnumP2PDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2PDisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2PDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumP2PDisputeStatusFilter<$PrismaModel>
  }

  export type p2p_ratingsCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type p2p_ratingsAvgOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type p2p_ratingsMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type p2p_ratingsMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type p2p_ratingsSumOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPairStatusFieldUpdateOperationsInput = {
    set?: $Enums.PairStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type chat_messagesCreateNestedManyWithoutUsersInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type depositsCreateNestedManyWithoutUsersInput = {
    create?: XOR<depositsCreateWithoutUsersInput, depositsUncheckedCreateWithoutUsersInput> | depositsCreateWithoutUsersInput[] | depositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: depositsCreateOrConnectWithoutUsersInput | depositsCreateOrConnectWithoutUsersInput[]
    createMany?: depositsCreateManyUsersInputEnvelope
    connect?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
  }

  export type leaderboardCreateNestedManyWithoutUsersInput = {
    create?: XOR<leaderboardCreateWithoutUsersInput, leaderboardUncheckedCreateWithoutUsersInput> | leaderboardCreateWithoutUsersInput[] | leaderboardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leaderboardCreateOrConnectWithoutUsersInput | leaderboardCreateOrConnectWithoutUsersInput[]
    createMany?: leaderboardCreateManyUsersInputEnvelope
    connect?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
  }

  export type settingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<settingsCreateWithoutUsersInput, settingsUncheckedCreateWithoutUsersInput> | settingsCreateWithoutUsersInput[] | settingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutUsersInput | settingsCreateOrConnectWithoutUsersInput[]
    createMany?: settingsCreateManyUsersInputEnvelope
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
  }

  export type support_messagesCreateNestedManyWithoutUsersInput = {
    create?: XOR<support_messagesCreateWithoutUsersInput, support_messagesUncheckedCreateWithoutUsersInput> | support_messagesCreateWithoutUsersInput[] | support_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: support_messagesCreateOrConnectWithoutUsersInput | support_messagesCreateOrConnectWithoutUsersInput[]
    createMany?: support_messagesCreateManyUsersInputEnvelope
    connect?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
  }

  export type tradesCreateNestedManyWithoutUsersInput = {
    create?: XOR<tradesCreateWithoutUsersInput, tradesUncheckedCreateWithoutUsersInput> | tradesCreateWithoutUsersInput[] | tradesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutUsersInput | tradesCreateOrConnectWithoutUsersInput[]
    createMany?: tradesCreateManyUsersInputEnvelope
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
  }

  export type withdrawalsCreateNestedManyWithoutUsersInput = {
    create?: XOR<withdrawalsCreateWithoutUsersInput, withdrawalsUncheckedCreateWithoutUsersInput> | withdrawalsCreateWithoutUsersInput[] | withdrawalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: withdrawalsCreateOrConnectWithoutUsersInput | withdrawalsCreateOrConnectWithoutUsersInput[]
    createMany?: withdrawalsCreateManyUsersInputEnvelope
    connect?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
  }

  export type deposit_sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<deposit_sessionsCreateWithoutUsersInput, deposit_sessionsUncheckedCreateWithoutUsersInput> | deposit_sessionsCreateWithoutUsersInput[] | deposit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutUsersInput | deposit_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: deposit_sessionsCreateManyUsersInputEnvelope
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
  }

  export type wallet_ledgerCreateNestedManyWithoutUsersInput = {
    create?: XOR<wallet_ledgerCreateWithoutUsersInput, wallet_ledgerUncheckedCreateWithoutUsersInput> | wallet_ledgerCreateWithoutUsersInput[] | wallet_ledgerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: wallet_ledgerCreateOrConnectWithoutUsersInput | wallet_ledgerCreateOrConnectWithoutUsersInput[]
    createMany?: wallet_ledgerCreateManyUsersInputEnvelope
    connect?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
  }

  export type p2p_offersCreateNestedManyWithoutUsersInput = {
    create?: XOR<p2p_offersCreateWithoutUsersInput, p2p_offersUncheckedCreateWithoutUsersInput> | p2p_offersCreateWithoutUsersInput[] | p2p_offersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: p2p_offersCreateOrConnectWithoutUsersInput | p2p_offersCreateOrConnectWithoutUsersInput[]
    createMany?: p2p_offersCreateManyUsersInputEnvelope
    connect?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
  }

  export type user_payment_methodsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
  }

  export type p2p_ordersCreateNestedManyWithoutMakerInput = {
    create?: XOR<p2p_ordersCreateWithoutMakerInput, p2p_ordersUncheckedCreateWithoutMakerInput> | p2p_ordersCreateWithoutMakerInput[] | p2p_ordersUncheckedCreateWithoutMakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutMakerInput | p2p_ordersCreateOrConnectWithoutMakerInput[]
    createMany?: p2p_ordersCreateManyMakerInputEnvelope
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
  }

  export type p2p_ordersCreateNestedManyWithoutTakerInput = {
    create?: XOR<p2p_ordersCreateWithoutTakerInput, p2p_ordersUncheckedCreateWithoutTakerInput> | p2p_ordersCreateWithoutTakerInput[] | p2p_ordersUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutTakerInput | p2p_ordersCreateOrConnectWithoutTakerInput[]
    createMany?: p2p_ordersCreateManyTakerInputEnvelope
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
  }

  export type p2p_messagesCreateNestedManyWithoutSenderInput = {
    create?: XOR<p2p_messagesCreateWithoutSenderInput, p2p_messagesUncheckedCreateWithoutSenderInput> | p2p_messagesCreateWithoutSenderInput[] | p2p_messagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutSenderInput | p2p_messagesCreateOrConnectWithoutSenderInput[]
    createMany?: p2p_messagesCreateManySenderInputEnvelope
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
  }

  export type p2p_disputesCreateNestedManyWithoutRaised_byInput = {
    create?: XOR<p2p_disputesCreateWithoutRaised_byInput, p2p_disputesUncheckedCreateWithoutRaised_byInput> | p2p_disputesCreateWithoutRaised_byInput[] | p2p_disputesUncheckedCreateWithoutRaised_byInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutRaised_byInput | p2p_disputesCreateOrConnectWithoutRaised_byInput[]
    createMany?: p2p_disputesCreateManyRaised_byInputEnvelope
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
  }

  export type p2p_ratingsCreateNestedManyWithoutFrom_userInput = {
    create?: XOR<p2p_ratingsCreateWithoutFrom_userInput, p2p_ratingsUncheckedCreateWithoutFrom_userInput> | p2p_ratingsCreateWithoutFrom_userInput[] | p2p_ratingsUncheckedCreateWithoutFrom_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutFrom_userInput | p2p_ratingsCreateOrConnectWithoutFrom_userInput[]
    createMany?: p2p_ratingsCreateManyFrom_userInputEnvelope
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
  }

  export type p2p_ratingsCreateNestedManyWithoutTo_userInput = {
    create?: XOR<p2p_ratingsCreateWithoutTo_userInput, p2p_ratingsUncheckedCreateWithoutTo_userInput> | p2p_ratingsCreateWithoutTo_userInput[] | p2p_ratingsUncheckedCreateWithoutTo_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutTo_userInput | p2p_ratingsCreateOrConnectWithoutTo_userInput[]
    createMany?: p2p_ratingsCreateManyTo_userInputEnvelope
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type depositsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<depositsCreateWithoutUsersInput, depositsUncheckedCreateWithoutUsersInput> | depositsCreateWithoutUsersInput[] | depositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: depositsCreateOrConnectWithoutUsersInput | depositsCreateOrConnectWithoutUsersInput[]
    createMany?: depositsCreateManyUsersInputEnvelope
    connect?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
  }

  export type leaderboardUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<leaderboardCreateWithoutUsersInput, leaderboardUncheckedCreateWithoutUsersInput> | leaderboardCreateWithoutUsersInput[] | leaderboardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leaderboardCreateOrConnectWithoutUsersInput | leaderboardCreateOrConnectWithoutUsersInput[]
    createMany?: leaderboardCreateManyUsersInputEnvelope
    connect?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
  }

  export type settingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<settingsCreateWithoutUsersInput, settingsUncheckedCreateWithoutUsersInput> | settingsCreateWithoutUsersInput[] | settingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutUsersInput | settingsCreateOrConnectWithoutUsersInput[]
    createMany?: settingsCreateManyUsersInputEnvelope
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
  }

  export type support_messagesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<support_messagesCreateWithoutUsersInput, support_messagesUncheckedCreateWithoutUsersInput> | support_messagesCreateWithoutUsersInput[] | support_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: support_messagesCreateOrConnectWithoutUsersInput | support_messagesCreateOrConnectWithoutUsersInput[]
    createMany?: support_messagesCreateManyUsersInputEnvelope
    connect?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
  }

  export type tradesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tradesCreateWithoutUsersInput, tradesUncheckedCreateWithoutUsersInput> | tradesCreateWithoutUsersInput[] | tradesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutUsersInput | tradesCreateOrConnectWithoutUsersInput[]
    createMany?: tradesCreateManyUsersInputEnvelope
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
  }

  export type withdrawalsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<withdrawalsCreateWithoutUsersInput, withdrawalsUncheckedCreateWithoutUsersInput> | withdrawalsCreateWithoutUsersInput[] | withdrawalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: withdrawalsCreateOrConnectWithoutUsersInput | withdrawalsCreateOrConnectWithoutUsersInput[]
    createMany?: withdrawalsCreateManyUsersInputEnvelope
    connect?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
  }

  export type deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<deposit_sessionsCreateWithoutUsersInput, deposit_sessionsUncheckedCreateWithoutUsersInput> | deposit_sessionsCreateWithoutUsersInput[] | deposit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutUsersInput | deposit_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: deposit_sessionsCreateManyUsersInputEnvelope
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
  }

  export type wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<wallet_ledgerCreateWithoutUsersInput, wallet_ledgerUncheckedCreateWithoutUsersInput> | wallet_ledgerCreateWithoutUsersInput[] | wallet_ledgerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: wallet_ledgerCreateOrConnectWithoutUsersInput | wallet_ledgerCreateOrConnectWithoutUsersInput[]
    createMany?: wallet_ledgerCreateManyUsersInputEnvelope
    connect?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
  }

  export type p2p_offersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<p2p_offersCreateWithoutUsersInput, p2p_offersUncheckedCreateWithoutUsersInput> | p2p_offersCreateWithoutUsersInput[] | p2p_offersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: p2p_offersCreateOrConnectWithoutUsersInput | p2p_offersCreateOrConnectWithoutUsersInput[]
    createMany?: p2p_offersCreateManyUsersInputEnvelope
    connect?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
  }

  export type user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
  }

  export type p2p_ordersUncheckedCreateNestedManyWithoutMakerInput = {
    create?: XOR<p2p_ordersCreateWithoutMakerInput, p2p_ordersUncheckedCreateWithoutMakerInput> | p2p_ordersCreateWithoutMakerInput[] | p2p_ordersUncheckedCreateWithoutMakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutMakerInput | p2p_ordersCreateOrConnectWithoutMakerInput[]
    createMany?: p2p_ordersCreateManyMakerInputEnvelope
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
  }

  export type p2p_ordersUncheckedCreateNestedManyWithoutTakerInput = {
    create?: XOR<p2p_ordersCreateWithoutTakerInput, p2p_ordersUncheckedCreateWithoutTakerInput> | p2p_ordersCreateWithoutTakerInput[] | p2p_ordersUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutTakerInput | p2p_ordersCreateOrConnectWithoutTakerInput[]
    createMany?: p2p_ordersCreateManyTakerInputEnvelope
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
  }

  export type p2p_messagesUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<p2p_messagesCreateWithoutSenderInput, p2p_messagesUncheckedCreateWithoutSenderInput> | p2p_messagesCreateWithoutSenderInput[] | p2p_messagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutSenderInput | p2p_messagesCreateOrConnectWithoutSenderInput[]
    createMany?: p2p_messagesCreateManySenderInputEnvelope
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
  }

  export type p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput = {
    create?: XOR<p2p_disputesCreateWithoutRaised_byInput, p2p_disputesUncheckedCreateWithoutRaised_byInput> | p2p_disputesCreateWithoutRaised_byInput[] | p2p_disputesUncheckedCreateWithoutRaised_byInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutRaised_byInput | p2p_disputesCreateOrConnectWithoutRaised_byInput[]
    createMany?: p2p_disputesCreateManyRaised_byInputEnvelope
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
  }

  export type p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput = {
    create?: XOR<p2p_ratingsCreateWithoutFrom_userInput, p2p_ratingsUncheckedCreateWithoutFrom_userInput> | p2p_ratingsCreateWithoutFrom_userInput[] | p2p_ratingsUncheckedCreateWithoutFrom_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutFrom_userInput | p2p_ratingsCreateOrConnectWithoutFrom_userInput[]
    createMany?: p2p_ratingsCreateManyFrom_userInputEnvelope
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
  }

  export type p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput = {
    create?: XOR<p2p_ratingsCreateWithoutTo_userInput, p2p_ratingsUncheckedCreateWithoutTo_userInput> | p2p_ratingsCreateWithoutTo_userInput[] | p2p_ratingsUncheckedCreateWithoutTo_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutTo_userInput | p2p_ratingsCreateOrConnectWithoutTo_userInput[]
    createMany?: p2p_ratingsCreateManyTo_userInputEnvelope
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
  }

  export type chat_messagesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutUsersInput | chat_messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutUsersInput | chat_messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutUsersInput | chat_messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type depositsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<depositsCreateWithoutUsersInput, depositsUncheckedCreateWithoutUsersInput> | depositsCreateWithoutUsersInput[] | depositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: depositsCreateOrConnectWithoutUsersInput | depositsCreateOrConnectWithoutUsersInput[]
    upsert?: depositsUpsertWithWhereUniqueWithoutUsersInput | depositsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: depositsCreateManyUsersInputEnvelope
    set?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    disconnect?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    delete?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    connect?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    update?: depositsUpdateWithWhereUniqueWithoutUsersInput | depositsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: depositsUpdateManyWithWhereWithoutUsersInput | depositsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: depositsScalarWhereInput | depositsScalarWhereInput[]
  }

  export type leaderboardUpdateManyWithoutUsersNestedInput = {
    create?: XOR<leaderboardCreateWithoutUsersInput, leaderboardUncheckedCreateWithoutUsersInput> | leaderboardCreateWithoutUsersInput[] | leaderboardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leaderboardCreateOrConnectWithoutUsersInput | leaderboardCreateOrConnectWithoutUsersInput[]
    upsert?: leaderboardUpsertWithWhereUniqueWithoutUsersInput | leaderboardUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: leaderboardCreateManyUsersInputEnvelope
    set?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    disconnect?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    delete?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    connect?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    update?: leaderboardUpdateWithWhereUniqueWithoutUsersInput | leaderboardUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: leaderboardUpdateManyWithWhereWithoutUsersInput | leaderboardUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: leaderboardScalarWhereInput | leaderboardScalarWhereInput[]
  }

  export type settingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<settingsCreateWithoutUsersInput, settingsUncheckedCreateWithoutUsersInput> | settingsCreateWithoutUsersInput[] | settingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutUsersInput | settingsCreateOrConnectWithoutUsersInput[]
    upsert?: settingsUpsertWithWhereUniqueWithoutUsersInput | settingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: settingsCreateManyUsersInputEnvelope
    set?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    disconnect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    delete?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    update?: settingsUpdateWithWhereUniqueWithoutUsersInput | settingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: settingsUpdateManyWithWhereWithoutUsersInput | settingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: settingsScalarWhereInput | settingsScalarWhereInput[]
  }

  export type support_messagesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<support_messagesCreateWithoutUsersInput, support_messagesUncheckedCreateWithoutUsersInput> | support_messagesCreateWithoutUsersInput[] | support_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: support_messagesCreateOrConnectWithoutUsersInput | support_messagesCreateOrConnectWithoutUsersInput[]
    upsert?: support_messagesUpsertWithWhereUniqueWithoutUsersInput | support_messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: support_messagesCreateManyUsersInputEnvelope
    set?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    disconnect?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    delete?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    connect?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    update?: support_messagesUpdateWithWhereUniqueWithoutUsersInput | support_messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: support_messagesUpdateManyWithWhereWithoutUsersInput | support_messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: support_messagesScalarWhereInput | support_messagesScalarWhereInput[]
  }

  export type tradesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tradesCreateWithoutUsersInput, tradesUncheckedCreateWithoutUsersInput> | tradesCreateWithoutUsersInput[] | tradesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutUsersInput | tradesCreateOrConnectWithoutUsersInput[]
    upsert?: tradesUpsertWithWhereUniqueWithoutUsersInput | tradesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tradesCreateManyUsersInputEnvelope
    set?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    disconnect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    delete?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    update?: tradesUpdateWithWhereUniqueWithoutUsersInput | tradesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tradesUpdateManyWithWhereWithoutUsersInput | tradesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tradesScalarWhereInput | tradesScalarWhereInput[]
  }

  export type withdrawalsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<withdrawalsCreateWithoutUsersInput, withdrawalsUncheckedCreateWithoutUsersInput> | withdrawalsCreateWithoutUsersInput[] | withdrawalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: withdrawalsCreateOrConnectWithoutUsersInput | withdrawalsCreateOrConnectWithoutUsersInput[]
    upsert?: withdrawalsUpsertWithWhereUniqueWithoutUsersInput | withdrawalsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: withdrawalsCreateManyUsersInputEnvelope
    set?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    disconnect?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    delete?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    connect?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    update?: withdrawalsUpdateWithWhereUniqueWithoutUsersInput | withdrawalsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: withdrawalsUpdateManyWithWhereWithoutUsersInput | withdrawalsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: withdrawalsScalarWhereInput | withdrawalsScalarWhereInput[]
  }

  export type deposit_sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<deposit_sessionsCreateWithoutUsersInput, deposit_sessionsUncheckedCreateWithoutUsersInput> | deposit_sessionsCreateWithoutUsersInput[] | deposit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutUsersInput | deposit_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: deposit_sessionsUpsertWithWhereUniqueWithoutUsersInput | deposit_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: deposit_sessionsCreateManyUsersInputEnvelope
    set?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    disconnect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    delete?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    update?: deposit_sessionsUpdateWithWhereUniqueWithoutUsersInput | deposit_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: deposit_sessionsUpdateManyWithWhereWithoutUsersInput | deposit_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: deposit_sessionsScalarWhereInput | deposit_sessionsScalarWhereInput[]
  }

  export type wallet_ledgerUpdateManyWithoutUsersNestedInput = {
    create?: XOR<wallet_ledgerCreateWithoutUsersInput, wallet_ledgerUncheckedCreateWithoutUsersInput> | wallet_ledgerCreateWithoutUsersInput[] | wallet_ledgerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: wallet_ledgerCreateOrConnectWithoutUsersInput | wallet_ledgerCreateOrConnectWithoutUsersInput[]
    upsert?: wallet_ledgerUpsertWithWhereUniqueWithoutUsersInput | wallet_ledgerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: wallet_ledgerCreateManyUsersInputEnvelope
    set?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    disconnect?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    delete?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    connect?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    update?: wallet_ledgerUpdateWithWhereUniqueWithoutUsersInput | wallet_ledgerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: wallet_ledgerUpdateManyWithWhereWithoutUsersInput | wallet_ledgerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: wallet_ledgerScalarWhereInput | wallet_ledgerScalarWhereInput[]
  }

  export type p2p_offersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<p2p_offersCreateWithoutUsersInput, p2p_offersUncheckedCreateWithoutUsersInput> | p2p_offersCreateWithoutUsersInput[] | p2p_offersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: p2p_offersCreateOrConnectWithoutUsersInput | p2p_offersCreateOrConnectWithoutUsersInput[]
    upsert?: p2p_offersUpsertWithWhereUniqueWithoutUsersInput | p2p_offersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: p2p_offersCreateManyUsersInputEnvelope
    set?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    disconnect?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    delete?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    connect?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    update?: p2p_offersUpdateWithWhereUniqueWithoutUsersInput | p2p_offersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: p2p_offersUpdateManyWithWhereWithoutUsersInput | p2p_offersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: p2p_offersScalarWhereInput | p2p_offersScalarWhereInput[]
  }

  export type user_payment_methodsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    upsert?: user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput | user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    set?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    disconnect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    delete?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    update?: user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput | user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_payment_methodsUpdateManyWithWhereWithoutUsersInput | user_payment_methodsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
  }

  export type p2p_ordersUpdateManyWithoutMakerNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutMakerInput, p2p_ordersUncheckedCreateWithoutMakerInput> | p2p_ordersCreateWithoutMakerInput[] | p2p_ordersUncheckedCreateWithoutMakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutMakerInput | p2p_ordersCreateOrConnectWithoutMakerInput[]
    upsert?: p2p_ordersUpsertWithWhereUniqueWithoutMakerInput | p2p_ordersUpsertWithWhereUniqueWithoutMakerInput[]
    createMany?: p2p_ordersCreateManyMakerInputEnvelope
    set?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    disconnect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    delete?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    update?: p2p_ordersUpdateWithWhereUniqueWithoutMakerInput | p2p_ordersUpdateWithWhereUniqueWithoutMakerInput[]
    updateMany?: p2p_ordersUpdateManyWithWhereWithoutMakerInput | p2p_ordersUpdateManyWithWhereWithoutMakerInput[]
    deleteMany?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
  }

  export type p2p_ordersUpdateManyWithoutTakerNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutTakerInput, p2p_ordersUncheckedCreateWithoutTakerInput> | p2p_ordersCreateWithoutTakerInput[] | p2p_ordersUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutTakerInput | p2p_ordersCreateOrConnectWithoutTakerInput[]
    upsert?: p2p_ordersUpsertWithWhereUniqueWithoutTakerInput | p2p_ordersUpsertWithWhereUniqueWithoutTakerInput[]
    createMany?: p2p_ordersCreateManyTakerInputEnvelope
    set?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    disconnect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    delete?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    update?: p2p_ordersUpdateWithWhereUniqueWithoutTakerInput | p2p_ordersUpdateWithWhereUniqueWithoutTakerInput[]
    updateMany?: p2p_ordersUpdateManyWithWhereWithoutTakerInput | p2p_ordersUpdateManyWithWhereWithoutTakerInput[]
    deleteMany?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
  }

  export type p2p_messagesUpdateManyWithoutSenderNestedInput = {
    create?: XOR<p2p_messagesCreateWithoutSenderInput, p2p_messagesUncheckedCreateWithoutSenderInput> | p2p_messagesCreateWithoutSenderInput[] | p2p_messagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutSenderInput | p2p_messagesCreateOrConnectWithoutSenderInput[]
    upsert?: p2p_messagesUpsertWithWhereUniqueWithoutSenderInput | p2p_messagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: p2p_messagesCreateManySenderInputEnvelope
    set?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    disconnect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    delete?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    update?: p2p_messagesUpdateWithWhereUniqueWithoutSenderInput | p2p_messagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: p2p_messagesUpdateManyWithWhereWithoutSenderInput | p2p_messagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: p2p_messagesScalarWhereInput | p2p_messagesScalarWhereInput[]
  }

  export type p2p_disputesUpdateManyWithoutRaised_byNestedInput = {
    create?: XOR<p2p_disputesCreateWithoutRaised_byInput, p2p_disputesUncheckedCreateWithoutRaised_byInput> | p2p_disputesCreateWithoutRaised_byInput[] | p2p_disputesUncheckedCreateWithoutRaised_byInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutRaised_byInput | p2p_disputesCreateOrConnectWithoutRaised_byInput[]
    upsert?: p2p_disputesUpsertWithWhereUniqueWithoutRaised_byInput | p2p_disputesUpsertWithWhereUniqueWithoutRaised_byInput[]
    createMany?: p2p_disputesCreateManyRaised_byInputEnvelope
    set?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    disconnect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    delete?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    update?: p2p_disputesUpdateWithWhereUniqueWithoutRaised_byInput | p2p_disputesUpdateWithWhereUniqueWithoutRaised_byInput[]
    updateMany?: p2p_disputesUpdateManyWithWhereWithoutRaised_byInput | p2p_disputesUpdateManyWithWhereWithoutRaised_byInput[]
    deleteMany?: p2p_disputesScalarWhereInput | p2p_disputesScalarWhereInput[]
  }

  export type p2p_ratingsUpdateManyWithoutFrom_userNestedInput = {
    create?: XOR<p2p_ratingsCreateWithoutFrom_userInput, p2p_ratingsUncheckedCreateWithoutFrom_userInput> | p2p_ratingsCreateWithoutFrom_userInput[] | p2p_ratingsUncheckedCreateWithoutFrom_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutFrom_userInput | p2p_ratingsCreateOrConnectWithoutFrom_userInput[]
    upsert?: p2p_ratingsUpsertWithWhereUniqueWithoutFrom_userInput | p2p_ratingsUpsertWithWhereUniqueWithoutFrom_userInput[]
    createMany?: p2p_ratingsCreateManyFrom_userInputEnvelope
    set?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    disconnect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    delete?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    update?: p2p_ratingsUpdateWithWhereUniqueWithoutFrom_userInput | p2p_ratingsUpdateWithWhereUniqueWithoutFrom_userInput[]
    updateMany?: p2p_ratingsUpdateManyWithWhereWithoutFrom_userInput | p2p_ratingsUpdateManyWithWhereWithoutFrom_userInput[]
    deleteMany?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
  }

  export type p2p_ratingsUpdateManyWithoutTo_userNestedInput = {
    create?: XOR<p2p_ratingsCreateWithoutTo_userInput, p2p_ratingsUncheckedCreateWithoutTo_userInput> | p2p_ratingsCreateWithoutTo_userInput[] | p2p_ratingsUncheckedCreateWithoutTo_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutTo_userInput | p2p_ratingsCreateOrConnectWithoutTo_userInput[]
    upsert?: p2p_ratingsUpsertWithWhereUniqueWithoutTo_userInput | p2p_ratingsUpsertWithWhereUniqueWithoutTo_userInput[]
    createMany?: p2p_ratingsCreateManyTo_userInputEnvelope
    set?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    disconnect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    delete?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    update?: p2p_ratingsUpdateWithWhereUniqueWithoutTo_userInput | p2p_ratingsUpdateWithWhereUniqueWithoutTo_userInput[]
    updateMany?: p2p_ratingsUpdateManyWithWhereWithoutTo_userInput | p2p_ratingsUpdateManyWithWhereWithoutTo_userInput[]
    deleteMany?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutUsersInput | chat_messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutUsersInput | chat_messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutUsersInput | chat_messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type depositsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<depositsCreateWithoutUsersInput, depositsUncheckedCreateWithoutUsersInput> | depositsCreateWithoutUsersInput[] | depositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: depositsCreateOrConnectWithoutUsersInput | depositsCreateOrConnectWithoutUsersInput[]
    upsert?: depositsUpsertWithWhereUniqueWithoutUsersInput | depositsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: depositsCreateManyUsersInputEnvelope
    set?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    disconnect?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    delete?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    connect?: depositsWhereUniqueInput | depositsWhereUniqueInput[]
    update?: depositsUpdateWithWhereUniqueWithoutUsersInput | depositsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: depositsUpdateManyWithWhereWithoutUsersInput | depositsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: depositsScalarWhereInput | depositsScalarWhereInput[]
  }

  export type leaderboardUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<leaderboardCreateWithoutUsersInput, leaderboardUncheckedCreateWithoutUsersInput> | leaderboardCreateWithoutUsersInput[] | leaderboardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leaderboardCreateOrConnectWithoutUsersInput | leaderboardCreateOrConnectWithoutUsersInput[]
    upsert?: leaderboardUpsertWithWhereUniqueWithoutUsersInput | leaderboardUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: leaderboardCreateManyUsersInputEnvelope
    set?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    disconnect?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    delete?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    connect?: leaderboardWhereUniqueInput | leaderboardWhereUniqueInput[]
    update?: leaderboardUpdateWithWhereUniqueWithoutUsersInput | leaderboardUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: leaderboardUpdateManyWithWhereWithoutUsersInput | leaderboardUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: leaderboardScalarWhereInput | leaderboardScalarWhereInput[]
  }

  export type settingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<settingsCreateWithoutUsersInput, settingsUncheckedCreateWithoutUsersInput> | settingsCreateWithoutUsersInput[] | settingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutUsersInput | settingsCreateOrConnectWithoutUsersInput[]
    upsert?: settingsUpsertWithWhereUniqueWithoutUsersInput | settingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: settingsCreateManyUsersInputEnvelope
    set?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    disconnect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    delete?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    update?: settingsUpdateWithWhereUniqueWithoutUsersInput | settingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: settingsUpdateManyWithWhereWithoutUsersInput | settingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: settingsScalarWhereInput | settingsScalarWhereInput[]
  }

  export type support_messagesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<support_messagesCreateWithoutUsersInput, support_messagesUncheckedCreateWithoutUsersInput> | support_messagesCreateWithoutUsersInput[] | support_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: support_messagesCreateOrConnectWithoutUsersInput | support_messagesCreateOrConnectWithoutUsersInput[]
    upsert?: support_messagesUpsertWithWhereUniqueWithoutUsersInput | support_messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: support_messagesCreateManyUsersInputEnvelope
    set?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    disconnect?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    delete?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    connect?: support_messagesWhereUniqueInput | support_messagesWhereUniqueInput[]
    update?: support_messagesUpdateWithWhereUniqueWithoutUsersInput | support_messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: support_messagesUpdateManyWithWhereWithoutUsersInput | support_messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: support_messagesScalarWhereInput | support_messagesScalarWhereInput[]
  }

  export type tradesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tradesCreateWithoutUsersInput, tradesUncheckedCreateWithoutUsersInput> | tradesCreateWithoutUsersInput[] | tradesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutUsersInput | tradesCreateOrConnectWithoutUsersInput[]
    upsert?: tradesUpsertWithWhereUniqueWithoutUsersInput | tradesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tradesCreateManyUsersInputEnvelope
    set?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    disconnect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    delete?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    update?: tradesUpdateWithWhereUniqueWithoutUsersInput | tradesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tradesUpdateManyWithWhereWithoutUsersInput | tradesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tradesScalarWhereInput | tradesScalarWhereInput[]
  }

  export type withdrawalsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<withdrawalsCreateWithoutUsersInput, withdrawalsUncheckedCreateWithoutUsersInput> | withdrawalsCreateWithoutUsersInput[] | withdrawalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: withdrawalsCreateOrConnectWithoutUsersInput | withdrawalsCreateOrConnectWithoutUsersInput[]
    upsert?: withdrawalsUpsertWithWhereUniqueWithoutUsersInput | withdrawalsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: withdrawalsCreateManyUsersInputEnvelope
    set?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    disconnect?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    delete?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    connect?: withdrawalsWhereUniqueInput | withdrawalsWhereUniqueInput[]
    update?: withdrawalsUpdateWithWhereUniqueWithoutUsersInput | withdrawalsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: withdrawalsUpdateManyWithWhereWithoutUsersInput | withdrawalsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: withdrawalsScalarWhereInput | withdrawalsScalarWhereInput[]
  }

  export type deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<deposit_sessionsCreateWithoutUsersInput, deposit_sessionsUncheckedCreateWithoutUsersInput> | deposit_sessionsCreateWithoutUsersInput[] | deposit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutUsersInput | deposit_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: deposit_sessionsUpsertWithWhereUniqueWithoutUsersInput | deposit_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: deposit_sessionsCreateManyUsersInputEnvelope
    set?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    disconnect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    delete?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    update?: deposit_sessionsUpdateWithWhereUniqueWithoutUsersInput | deposit_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: deposit_sessionsUpdateManyWithWhereWithoutUsersInput | deposit_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: deposit_sessionsScalarWhereInput | deposit_sessionsScalarWhereInput[]
  }

  export type wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<wallet_ledgerCreateWithoutUsersInput, wallet_ledgerUncheckedCreateWithoutUsersInput> | wallet_ledgerCreateWithoutUsersInput[] | wallet_ledgerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: wallet_ledgerCreateOrConnectWithoutUsersInput | wallet_ledgerCreateOrConnectWithoutUsersInput[]
    upsert?: wallet_ledgerUpsertWithWhereUniqueWithoutUsersInput | wallet_ledgerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: wallet_ledgerCreateManyUsersInputEnvelope
    set?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    disconnect?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    delete?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    connect?: wallet_ledgerWhereUniqueInput | wallet_ledgerWhereUniqueInput[]
    update?: wallet_ledgerUpdateWithWhereUniqueWithoutUsersInput | wallet_ledgerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: wallet_ledgerUpdateManyWithWhereWithoutUsersInput | wallet_ledgerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: wallet_ledgerScalarWhereInput | wallet_ledgerScalarWhereInput[]
  }

  export type p2p_offersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<p2p_offersCreateWithoutUsersInput, p2p_offersUncheckedCreateWithoutUsersInput> | p2p_offersCreateWithoutUsersInput[] | p2p_offersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: p2p_offersCreateOrConnectWithoutUsersInput | p2p_offersCreateOrConnectWithoutUsersInput[]
    upsert?: p2p_offersUpsertWithWhereUniqueWithoutUsersInput | p2p_offersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: p2p_offersCreateManyUsersInputEnvelope
    set?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    disconnect?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    delete?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    connect?: p2p_offersWhereUniqueInput | p2p_offersWhereUniqueInput[]
    update?: p2p_offersUpdateWithWhereUniqueWithoutUsersInput | p2p_offersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: p2p_offersUpdateManyWithWhereWithoutUsersInput | p2p_offersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: p2p_offersScalarWhereInput | p2p_offersScalarWhereInput[]
  }

  export type user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    upsert?: user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput | user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    set?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    disconnect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    delete?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    update?: user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput | user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_payment_methodsUpdateManyWithWhereWithoutUsersInput | user_payment_methodsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
  }

  export type p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutMakerInput, p2p_ordersUncheckedCreateWithoutMakerInput> | p2p_ordersCreateWithoutMakerInput[] | p2p_ordersUncheckedCreateWithoutMakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutMakerInput | p2p_ordersCreateOrConnectWithoutMakerInput[]
    upsert?: p2p_ordersUpsertWithWhereUniqueWithoutMakerInput | p2p_ordersUpsertWithWhereUniqueWithoutMakerInput[]
    createMany?: p2p_ordersCreateManyMakerInputEnvelope
    set?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    disconnect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    delete?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    update?: p2p_ordersUpdateWithWhereUniqueWithoutMakerInput | p2p_ordersUpdateWithWhereUniqueWithoutMakerInput[]
    updateMany?: p2p_ordersUpdateManyWithWhereWithoutMakerInput | p2p_ordersUpdateManyWithWhereWithoutMakerInput[]
    deleteMany?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
  }

  export type p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutTakerInput, p2p_ordersUncheckedCreateWithoutTakerInput> | p2p_ordersCreateWithoutTakerInput[] | p2p_ordersUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutTakerInput | p2p_ordersCreateOrConnectWithoutTakerInput[]
    upsert?: p2p_ordersUpsertWithWhereUniqueWithoutTakerInput | p2p_ordersUpsertWithWhereUniqueWithoutTakerInput[]
    createMany?: p2p_ordersCreateManyTakerInputEnvelope
    set?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    disconnect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    delete?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    update?: p2p_ordersUpdateWithWhereUniqueWithoutTakerInput | p2p_ordersUpdateWithWhereUniqueWithoutTakerInput[]
    updateMany?: p2p_ordersUpdateManyWithWhereWithoutTakerInput | p2p_ordersUpdateManyWithWhereWithoutTakerInput[]
    deleteMany?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
  }

  export type p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<p2p_messagesCreateWithoutSenderInput, p2p_messagesUncheckedCreateWithoutSenderInput> | p2p_messagesCreateWithoutSenderInput[] | p2p_messagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutSenderInput | p2p_messagesCreateOrConnectWithoutSenderInput[]
    upsert?: p2p_messagesUpsertWithWhereUniqueWithoutSenderInput | p2p_messagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: p2p_messagesCreateManySenderInputEnvelope
    set?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    disconnect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    delete?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    update?: p2p_messagesUpdateWithWhereUniqueWithoutSenderInput | p2p_messagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: p2p_messagesUpdateManyWithWhereWithoutSenderInput | p2p_messagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: p2p_messagesScalarWhereInput | p2p_messagesScalarWhereInput[]
  }

  export type p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput = {
    create?: XOR<p2p_disputesCreateWithoutRaised_byInput, p2p_disputesUncheckedCreateWithoutRaised_byInput> | p2p_disputesCreateWithoutRaised_byInput[] | p2p_disputesUncheckedCreateWithoutRaised_byInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutRaised_byInput | p2p_disputesCreateOrConnectWithoutRaised_byInput[]
    upsert?: p2p_disputesUpsertWithWhereUniqueWithoutRaised_byInput | p2p_disputesUpsertWithWhereUniqueWithoutRaised_byInput[]
    createMany?: p2p_disputesCreateManyRaised_byInputEnvelope
    set?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    disconnect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    delete?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    update?: p2p_disputesUpdateWithWhereUniqueWithoutRaised_byInput | p2p_disputesUpdateWithWhereUniqueWithoutRaised_byInput[]
    updateMany?: p2p_disputesUpdateManyWithWhereWithoutRaised_byInput | p2p_disputesUpdateManyWithWhereWithoutRaised_byInput[]
    deleteMany?: p2p_disputesScalarWhereInput | p2p_disputesScalarWhereInput[]
  }

  export type p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput = {
    create?: XOR<p2p_ratingsCreateWithoutFrom_userInput, p2p_ratingsUncheckedCreateWithoutFrom_userInput> | p2p_ratingsCreateWithoutFrom_userInput[] | p2p_ratingsUncheckedCreateWithoutFrom_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutFrom_userInput | p2p_ratingsCreateOrConnectWithoutFrom_userInput[]
    upsert?: p2p_ratingsUpsertWithWhereUniqueWithoutFrom_userInput | p2p_ratingsUpsertWithWhereUniqueWithoutFrom_userInput[]
    createMany?: p2p_ratingsCreateManyFrom_userInputEnvelope
    set?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    disconnect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    delete?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    update?: p2p_ratingsUpdateWithWhereUniqueWithoutFrom_userInput | p2p_ratingsUpdateWithWhereUniqueWithoutFrom_userInput[]
    updateMany?: p2p_ratingsUpdateManyWithWhereWithoutFrom_userInput | p2p_ratingsUpdateManyWithWhereWithoutFrom_userInput[]
    deleteMany?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
  }

  export type p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput = {
    create?: XOR<p2p_ratingsCreateWithoutTo_userInput, p2p_ratingsUncheckedCreateWithoutTo_userInput> | p2p_ratingsCreateWithoutTo_userInput[] | p2p_ratingsUncheckedCreateWithoutTo_userInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutTo_userInput | p2p_ratingsCreateOrConnectWithoutTo_userInput[]
    upsert?: p2p_ratingsUpsertWithWhereUniqueWithoutTo_userInput | p2p_ratingsUpsertWithWhereUniqueWithoutTo_userInput[]
    createMany?: p2p_ratingsCreateManyTo_userInputEnvelope
    set?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    disconnect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    delete?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    update?: p2p_ratingsUpdateWithWhereUniqueWithoutTo_userInput | p2p_ratingsUpdateWithWhereUniqueWithoutTo_userInput[]
    updateMany?: p2p_ratingsUpdateManyWithWhereWithoutTo_userInput | p2p_ratingsUpdateManyWithWhereWithoutTo_userInput[]
    deleteMany?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutDepositsInput = {
    create?: XOR<usersCreateWithoutDepositsInput, usersUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: usersCreateOrConnectWithoutDepositsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutDepositsNestedInput = {
    create?: XOR<usersCreateWithoutDepositsInput, usersUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: usersCreateOrConnectWithoutDepositsInput
    upsert?: usersUpsertWithoutDepositsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDepositsInput, usersUpdateWithoutDepositsInput>, usersUncheckedUpdateWithoutDepositsInput>
  }

  export type usersCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<usersCreateWithoutWithdrawalsInput, usersUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWithdrawalsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutWithdrawalsNestedInput = {
    create?: XOR<usersCreateWithoutWithdrawalsInput, usersUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWithdrawalsInput
    upsert?: usersUpsertWithoutWithdrawalsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWithdrawalsInput, usersUpdateWithoutWithdrawalsInput>, usersUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type usersCreateNestedOneWithoutTradesInput = {
    create?: XOR<usersCreateWithoutTradesInput, usersUncheckedCreateWithoutTradesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTradesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutTradesNestedInput = {
    create?: XOR<usersCreateWithoutTradesInput, usersUncheckedCreateWithoutTradesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTradesInput
    upsert?: usersUpsertWithoutTradesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTradesInput, usersUpdateWithoutTradesInput>, usersUncheckedUpdateWithoutTradesInput>
  }

  export type usersCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<usersCreateWithoutLeaderboardInput, usersUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: usersCreateOrConnectWithoutLeaderboardInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutLeaderboardNestedInput = {
    create?: XOR<usersCreateWithoutLeaderboardInput, usersUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: usersCreateOrConnectWithoutLeaderboardInput
    upsert?: usersUpsertWithoutLeaderboardInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLeaderboardInput, usersUpdateWithoutLeaderboardInput>, usersUncheckedUpdateWithoutLeaderboardInput>
  }

  export type usersCreateNestedOneWithoutSupport_messagesInput = {
    create?: XOR<usersCreateWithoutSupport_messagesInput, usersUncheckedCreateWithoutSupport_messagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutSupport_messagesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutSupport_messagesNestedInput = {
    create?: XOR<usersCreateWithoutSupport_messagesInput, usersUncheckedCreateWithoutSupport_messagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutSupport_messagesInput
    upsert?: usersUpsertWithoutSupport_messagesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSupport_messagesInput, usersUpdateWithoutSupport_messagesInput>, usersUncheckedUpdateWithoutSupport_messagesInput>
  }

  export type usersCreateNestedOneWithoutChat_messagesInput = {
    create?: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChat_messagesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutChat_messagesNestedInput = {
    create?: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChat_messagesInput
    upsert?: usersUpsertWithoutChat_messagesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChat_messagesInput, usersUpdateWithoutChat_messagesInput>, usersUncheckedUpdateWithoutChat_messagesInput>
  }

  export type usersCreateNestedOneWithoutSettingsInput = {
    create?: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSettingsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type usersUpdateOneWithoutSettingsNestedInput = {
    create?: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSettingsInput
    upsert?: usersUpsertWithoutSettingsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSettingsInput, usersUpdateWithoutSettingsInput>, usersUncheckedUpdateWithoutSettingsInput>
  }

  export type deposit_sessionsCreateNestedManyWithoutCrypto_assetsInput = {
    create?: XOR<deposit_sessionsCreateWithoutCrypto_assetsInput, deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput> | deposit_sessionsCreateWithoutCrypto_assetsInput[] | deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput | deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput[]
    createMany?: deposit_sessionsCreateManyCrypto_assetsInputEnvelope
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
  }

  export type deposit_sessionsUncheckedCreateNestedManyWithoutCrypto_assetsInput = {
    create?: XOR<deposit_sessionsCreateWithoutCrypto_assetsInput, deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput> | deposit_sessionsCreateWithoutCrypto_assetsInput[] | deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput | deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput[]
    createMany?: deposit_sessionsCreateManyCrypto_assetsInputEnvelope
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type deposit_sessionsUpdateManyWithoutCrypto_assetsNestedInput = {
    create?: XOR<deposit_sessionsCreateWithoutCrypto_assetsInput, deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput> | deposit_sessionsCreateWithoutCrypto_assetsInput[] | deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput | deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput[]
    upsert?: deposit_sessionsUpsertWithWhereUniqueWithoutCrypto_assetsInput | deposit_sessionsUpsertWithWhereUniqueWithoutCrypto_assetsInput[]
    createMany?: deposit_sessionsCreateManyCrypto_assetsInputEnvelope
    set?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    disconnect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    delete?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    update?: deposit_sessionsUpdateWithWhereUniqueWithoutCrypto_assetsInput | deposit_sessionsUpdateWithWhereUniqueWithoutCrypto_assetsInput[]
    updateMany?: deposit_sessionsUpdateManyWithWhereWithoutCrypto_assetsInput | deposit_sessionsUpdateManyWithWhereWithoutCrypto_assetsInput[]
    deleteMany?: deposit_sessionsScalarWhereInput | deposit_sessionsScalarWhereInput[]
  }

  export type deposit_sessionsUncheckedUpdateManyWithoutCrypto_assetsNestedInput = {
    create?: XOR<deposit_sessionsCreateWithoutCrypto_assetsInput, deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput> | deposit_sessionsCreateWithoutCrypto_assetsInput[] | deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput[]
    connectOrCreate?: deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput | deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput[]
    upsert?: deposit_sessionsUpsertWithWhereUniqueWithoutCrypto_assetsInput | deposit_sessionsUpsertWithWhereUniqueWithoutCrypto_assetsInput[]
    createMany?: deposit_sessionsCreateManyCrypto_assetsInputEnvelope
    set?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    disconnect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    delete?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    connect?: deposit_sessionsWhereUniqueInput | deposit_sessionsWhereUniqueInput[]
    update?: deposit_sessionsUpdateWithWhereUniqueWithoutCrypto_assetsInput | deposit_sessionsUpdateWithWhereUniqueWithoutCrypto_assetsInput[]
    updateMany?: deposit_sessionsUpdateManyWithWhereWithoutCrypto_assetsInput | deposit_sessionsUpdateManyWithWhereWithoutCrypto_assetsInput[]
    deleteMany?: deposit_sessionsScalarWhereInput | deposit_sessionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutDeposit_sessionsInput = {
    create?: XOR<usersCreateWithoutDeposit_sessionsInput, usersUncheckedCreateWithoutDeposit_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutDeposit_sessionsInput
    connect?: usersWhereUniqueInput
  }

  export type crypto_assetsCreateNestedOneWithoutDeposit_sessionsInput = {
    create?: XOR<crypto_assetsCreateWithoutDeposit_sessionsInput, crypto_assetsUncheckedCreateWithoutDeposit_sessionsInput>
    connectOrCreate?: crypto_assetsCreateOrConnectWithoutDeposit_sessionsInput
    connect?: crypto_assetsWhereUniqueInput
  }

  export type EnumDepositSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.DepositSessionStatus
  }

  export type usersUpdateOneRequiredWithoutDeposit_sessionsNestedInput = {
    create?: XOR<usersCreateWithoutDeposit_sessionsInput, usersUncheckedCreateWithoutDeposit_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutDeposit_sessionsInput
    upsert?: usersUpsertWithoutDeposit_sessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDeposit_sessionsInput, usersUpdateWithoutDeposit_sessionsInput>, usersUncheckedUpdateWithoutDeposit_sessionsInput>
  }

  export type crypto_assetsUpdateOneRequiredWithoutDeposit_sessionsNestedInput = {
    create?: XOR<crypto_assetsCreateWithoutDeposit_sessionsInput, crypto_assetsUncheckedCreateWithoutDeposit_sessionsInput>
    connectOrCreate?: crypto_assetsCreateOrConnectWithoutDeposit_sessionsInput
    upsert?: crypto_assetsUpsertWithoutDeposit_sessionsInput
    connect?: crypto_assetsWhereUniqueInput
    update?: XOR<XOR<crypto_assetsUpdateToOneWithWhereWithoutDeposit_sessionsInput, crypto_assetsUpdateWithoutDeposit_sessionsInput>, crypto_assetsUncheckedUpdateWithoutDeposit_sessionsInput>
  }

  export type usersCreateNestedOneWithoutWallet_ledgerInput = {
    create?: XOR<usersCreateWithoutWallet_ledgerInput, usersUncheckedCreateWithoutWallet_ledgerInput>
    connectOrCreate?: usersCreateOrConnectWithoutWallet_ledgerInput
    connect?: usersWhereUniqueInput
  }

  export type EnumLedgerTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerType
  }

  export type usersUpdateOneRequiredWithoutWallet_ledgerNestedInput = {
    create?: XOR<usersCreateWithoutWallet_ledgerInput, usersUncheckedCreateWithoutWallet_ledgerInput>
    connectOrCreate?: usersCreateOrConnectWithoutWallet_ledgerInput
    upsert?: usersUpsertWithoutWallet_ledgerInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWallet_ledgerInput, usersUpdateWithoutWallet_ledgerInput>, usersUncheckedUpdateWithoutWallet_ledgerInput>
  }

  export type EnumPaymentMethodTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodType
  }

  export type usersCreateNestedOneWithoutP2p_offersInput = {
    create?: XOR<usersCreateWithoutP2p_offersInput, usersUncheckedCreateWithoutP2p_offersInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_offersInput
    connect?: usersWhereUniqueInput
  }

  export type p2p_offer_payment_methodsCreateNestedManyWithoutOfferInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutOfferInput, p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput> | p2p_offer_payment_methodsCreateWithoutOfferInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput | p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput[]
    createMany?: p2p_offer_payment_methodsCreateManyOfferInputEnvelope
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
  }

  export type p2p_ordersCreateNestedManyWithoutOfferInput = {
    create?: XOR<p2p_ordersCreateWithoutOfferInput, p2p_ordersUncheckedCreateWithoutOfferInput> | p2p_ordersCreateWithoutOfferInput[] | p2p_ordersUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutOfferInput | p2p_ordersCreateOrConnectWithoutOfferInput[]
    createMany?: p2p_ordersCreateManyOfferInputEnvelope
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
  }

  export type p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutOfferInput, p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput> | p2p_offer_payment_methodsCreateWithoutOfferInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput | p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput[]
    createMany?: p2p_offer_payment_methodsCreateManyOfferInputEnvelope
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
  }

  export type p2p_ordersUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<p2p_ordersCreateWithoutOfferInput, p2p_ordersUncheckedCreateWithoutOfferInput> | p2p_ordersCreateWithoutOfferInput[] | p2p_ordersUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutOfferInput | p2p_ordersCreateOrConnectWithoutOfferInput[]
    createMany?: p2p_ordersCreateManyOfferInputEnvelope
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
  }

  export type EnumP2POrderSideFieldUpdateOperationsInput = {
    set?: $Enums.P2POrderSide
  }

  export type EnumP2POfferStatusFieldUpdateOperationsInput = {
    set?: $Enums.P2POfferStatus
  }

  export type usersUpdateOneRequiredWithoutP2p_offersNestedInput = {
    create?: XOR<usersCreateWithoutP2p_offersInput, usersUncheckedCreateWithoutP2p_offersInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_offersInput
    upsert?: usersUpsertWithoutP2p_offersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_offersInput, usersUpdateWithoutP2p_offersInput>, usersUncheckedUpdateWithoutP2p_offersInput>
  }

  export type p2p_offer_payment_methodsUpdateManyWithoutOfferNestedInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutOfferInput, p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput> | p2p_offer_payment_methodsCreateWithoutOfferInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput | p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput[]
    upsert?: p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutOfferInput | p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: p2p_offer_payment_methodsCreateManyOfferInputEnvelope
    set?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    disconnect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    delete?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    update?: p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutOfferInput | p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: p2p_offer_payment_methodsUpdateManyWithWhereWithoutOfferInput | p2p_offer_payment_methodsUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: p2p_offer_payment_methodsScalarWhereInput | p2p_offer_payment_methodsScalarWhereInput[]
  }

  export type p2p_ordersUpdateManyWithoutOfferNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutOfferInput, p2p_ordersUncheckedCreateWithoutOfferInput> | p2p_ordersCreateWithoutOfferInput[] | p2p_ordersUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutOfferInput | p2p_ordersCreateOrConnectWithoutOfferInput[]
    upsert?: p2p_ordersUpsertWithWhereUniqueWithoutOfferInput | p2p_ordersUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: p2p_ordersCreateManyOfferInputEnvelope
    set?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    disconnect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    delete?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    update?: p2p_ordersUpdateWithWhereUniqueWithoutOfferInput | p2p_ordersUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: p2p_ordersUpdateManyWithWhereWithoutOfferInput | p2p_ordersUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
  }

  export type p2p_offer_payment_methodsUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutOfferInput, p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput> | p2p_offer_payment_methodsCreateWithoutOfferInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput | p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput[]
    upsert?: p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutOfferInput | p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: p2p_offer_payment_methodsCreateManyOfferInputEnvelope
    set?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    disconnect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    delete?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    update?: p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutOfferInput | p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: p2p_offer_payment_methodsUpdateManyWithWhereWithoutOfferInput | p2p_offer_payment_methodsUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: p2p_offer_payment_methodsScalarWhereInput | p2p_offer_payment_methodsScalarWhereInput[]
  }

  export type p2p_ordersUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutOfferInput, p2p_ordersUncheckedCreateWithoutOfferInput> | p2p_ordersCreateWithoutOfferInput[] | p2p_ordersUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutOfferInput | p2p_ordersCreateOrConnectWithoutOfferInput[]
    upsert?: p2p_ordersUpsertWithWhereUniqueWithoutOfferInput | p2p_ordersUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: p2p_ordersCreateManyOfferInputEnvelope
    set?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    disconnect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    delete?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    connect?: p2p_ordersWhereUniqueInput | p2p_ordersWhereUniqueInput[]
    update?: p2p_ordersUpdateWithWhereUniqueWithoutOfferInput | p2p_ordersUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: p2p_ordersUpdateManyWithWhereWithoutOfferInput | p2p_ordersUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_payment_methodsInput = {
    create?: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_payment_methodsInput
    connect?: usersWhereUniqueInput
  }

  export type p2p_offer_payment_methodsCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput> | p2p_offer_payment_methodsCreateWithoutPayment_methodInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput | p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    createMany?: p2p_offer_payment_methodsCreateManyPayment_methodInputEnvelope
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
  }

  export type p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput> | p2p_offer_payment_methodsCreateWithoutPayment_methodInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput | p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    createMany?: p2p_offer_payment_methodsCreateManyPayment_methodInputEnvelope
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutUser_payment_methodsNestedInput = {
    create?: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_payment_methodsInput
    upsert?: usersUpsertWithoutUser_payment_methodsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_payment_methodsInput, usersUpdateWithoutUser_payment_methodsInput>, usersUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type p2p_offer_payment_methodsUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput> | p2p_offer_payment_methodsCreateWithoutPayment_methodInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput | p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    upsert?: p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput | p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: p2p_offer_payment_methodsCreateManyPayment_methodInputEnvelope
    set?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    disconnect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    delete?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    update?: p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput | p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: p2p_offer_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput | p2p_offer_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: p2p_offer_payment_methodsScalarWhereInput | p2p_offer_payment_methodsScalarWhereInput[]
  }

  export type p2p_offer_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<p2p_offer_payment_methodsCreateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput> | p2p_offer_payment_methodsCreateWithoutPayment_methodInput[] | p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput | p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    upsert?: p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput | p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: p2p_offer_payment_methodsCreateManyPayment_methodInputEnvelope
    set?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    disconnect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    delete?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    connect?: p2p_offer_payment_methodsWhereUniqueInput | p2p_offer_payment_methodsWhereUniqueInput[]
    update?: p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput | p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: p2p_offer_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput | p2p_offer_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: p2p_offer_payment_methodsScalarWhereInput | p2p_offer_payment_methodsScalarWhereInput[]
  }

  export type p2p_offersCreateNestedOneWithoutPayment_methodsInput = {
    create?: XOR<p2p_offersCreateWithoutPayment_methodsInput, p2p_offersUncheckedCreateWithoutPayment_methodsInput>
    connectOrCreate?: p2p_offersCreateOrConnectWithoutPayment_methodsInput
    connect?: p2p_offersWhereUniqueInput
  }

  export type user_payment_methodsCreateNestedOneWithoutOffersInput = {
    create?: XOR<user_payment_methodsCreateWithoutOffersInput, user_payment_methodsUncheckedCreateWithoutOffersInput>
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutOffersInput
    connect?: user_payment_methodsWhereUniqueInput
  }

  export type p2p_offersUpdateOneRequiredWithoutPayment_methodsNestedInput = {
    create?: XOR<p2p_offersCreateWithoutPayment_methodsInput, p2p_offersUncheckedCreateWithoutPayment_methodsInput>
    connectOrCreate?: p2p_offersCreateOrConnectWithoutPayment_methodsInput
    upsert?: p2p_offersUpsertWithoutPayment_methodsInput
    connect?: p2p_offersWhereUniqueInput
    update?: XOR<XOR<p2p_offersUpdateToOneWithWhereWithoutPayment_methodsInput, p2p_offersUpdateWithoutPayment_methodsInput>, p2p_offersUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type user_payment_methodsUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutOffersInput, user_payment_methodsUncheckedCreateWithoutOffersInput>
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutOffersInput
    upsert?: user_payment_methodsUpsertWithoutOffersInput
    connect?: user_payment_methodsWhereUniqueInput
    update?: XOR<XOR<user_payment_methodsUpdateToOneWithWhereWithoutOffersInput, user_payment_methodsUpdateWithoutOffersInput>, user_payment_methodsUncheckedUpdateWithoutOffersInput>
  }

  export type p2p_offersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<p2p_offersCreateWithoutOrdersInput, p2p_offersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: p2p_offersCreateOrConnectWithoutOrdersInput
    connect?: p2p_offersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutP2p_maker_ordersInput = {
    create?: XOR<usersCreateWithoutP2p_maker_ordersInput, usersUncheckedCreateWithoutP2p_maker_ordersInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_maker_ordersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutP2p_taker_ordersInput = {
    create?: XOR<usersCreateWithoutP2p_taker_ordersInput, usersUncheckedCreateWithoutP2p_taker_ordersInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_taker_ordersInput
    connect?: usersWhereUniqueInput
  }

  export type p2p_messagesCreateNestedManyWithoutOrderInput = {
    create?: XOR<p2p_messagesCreateWithoutOrderInput, p2p_messagesUncheckedCreateWithoutOrderInput> | p2p_messagesCreateWithoutOrderInput[] | p2p_messagesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutOrderInput | p2p_messagesCreateOrConnectWithoutOrderInput[]
    createMany?: p2p_messagesCreateManyOrderInputEnvelope
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
  }

  export type p2p_disputesCreateNestedManyWithoutOrderInput = {
    create?: XOR<p2p_disputesCreateWithoutOrderInput, p2p_disputesUncheckedCreateWithoutOrderInput> | p2p_disputesCreateWithoutOrderInput[] | p2p_disputesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutOrderInput | p2p_disputesCreateOrConnectWithoutOrderInput[]
    createMany?: p2p_disputesCreateManyOrderInputEnvelope
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
  }

  export type p2p_ratingsCreateNestedManyWithoutOrderInput = {
    create?: XOR<p2p_ratingsCreateWithoutOrderInput, p2p_ratingsUncheckedCreateWithoutOrderInput> | p2p_ratingsCreateWithoutOrderInput[] | p2p_ratingsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutOrderInput | p2p_ratingsCreateOrConnectWithoutOrderInput[]
    createMany?: p2p_ratingsCreateManyOrderInputEnvelope
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
  }

  export type p2p_messagesUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<p2p_messagesCreateWithoutOrderInput, p2p_messagesUncheckedCreateWithoutOrderInput> | p2p_messagesCreateWithoutOrderInput[] | p2p_messagesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutOrderInput | p2p_messagesCreateOrConnectWithoutOrderInput[]
    createMany?: p2p_messagesCreateManyOrderInputEnvelope
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
  }

  export type p2p_disputesUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<p2p_disputesCreateWithoutOrderInput, p2p_disputesUncheckedCreateWithoutOrderInput> | p2p_disputesCreateWithoutOrderInput[] | p2p_disputesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutOrderInput | p2p_disputesCreateOrConnectWithoutOrderInput[]
    createMany?: p2p_disputesCreateManyOrderInputEnvelope
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
  }

  export type p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<p2p_ratingsCreateWithoutOrderInput, p2p_ratingsUncheckedCreateWithoutOrderInput> | p2p_ratingsCreateWithoutOrderInput[] | p2p_ratingsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutOrderInput | p2p_ratingsCreateOrConnectWithoutOrderInput[]
    createMany?: p2p_ratingsCreateManyOrderInputEnvelope
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
  }

  export type EnumP2PTradeStatusFieldUpdateOperationsInput = {
    set?: $Enums.P2PTradeStatus
  }

  export type p2p_offersUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<p2p_offersCreateWithoutOrdersInput, p2p_offersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: p2p_offersCreateOrConnectWithoutOrdersInput
    upsert?: p2p_offersUpsertWithoutOrdersInput
    connect?: p2p_offersWhereUniqueInput
    update?: XOR<XOR<p2p_offersUpdateToOneWithWhereWithoutOrdersInput, p2p_offersUpdateWithoutOrdersInput>, p2p_offersUncheckedUpdateWithoutOrdersInput>
  }

  export type usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput = {
    create?: XOR<usersCreateWithoutP2p_maker_ordersInput, usersUncheckedCreateWithoutP2p_maker_ordersInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_maker_ordersInput
    upsert?: usersUpsertWithoutP2p_maker_ordersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_maker_ordersInput, usersUpdateWithoutP2p_maker_ordersInput>, usersUncheckedUpdateWithoutP2p_maker_ordersInput>
  }

  export type usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput = {
    create?: XOR<usersCreateWithoutP2p_taker_ordersInput, usersUncheckedCreateWithoutP2p_taker_ordersInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_taker_ordersInput
    upsert?: usersUpsertWithoutP2p_taker_ordersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_taker_ordersInput, usersUpdateWithoutP2p_taker_ordersInput>, usersUncheckedUpdateWithoutP2p_taker_ordersInput>
  }

  export type p2p_messagesUpdateManyWithoutOrderNestedInput = {
    create?: XOR<p2p_messagesCreateWithoutOrderInput, p2p_messagesUncheckedCreateWithoutOrderInput> | p2p_messagesCreateWithoutOrderInput[] | p2p_messagesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutOrderInput | p2p_messagesCreateOrConnectWithoutOrderInput[]
    upsert?: p2p_messagesUpsertWithWhereUniqueWithoutOrderInput | p2p_messagesUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: p2p_messagesCreateManyOrderInputEnvelope
    set?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    disconnect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    delete?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    update?: p2p_messagesUpdateWithWhereUniqueWithoutOrderInput | p2p_messagesUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: p2p_messagesUpdateManyWithWhereWithoutOrderInput | p2p_messagesUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: p2p_messagesScalarWhereInput | p2p_messagesScalarWhereInput[]
  }

  export type p2p_disputesUpdateManyWithoutOrderNestedInput = {
    create?: XOR<p2p_disputesCreateWithoutOrderInput, p2p_disputesUncheckedCreateWithoutOrderInput> | p2p_disputesCreateWithoutOrderInput[] | p2p_disputesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutOrderInput | p2p_disputesCreateOrConnectWithoutOrderInput[]
    upsert?: p2p_disputesUpsertWithWhereUniqueWithoutOrderInput | p2p_disputesUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: p2p_disputesCreateManyOrderInputEnvelope
    set?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    disconnect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    delete?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    update?: p2p_disputesUpdateWithWhereUniqueWithoutOrderInput | p2p_disputesUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: p2p_disputesUpdateManyWithWhereWithoutOrderInput | p2p_disputesUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: p2p_disputesScalarWhereInput | p2p_disputesScalarWhereInput[]
  }

  export type p2p_ratingsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<p2p_ratingsCreateWithoutOrderInput, p2p_ratingsUncheckedCreateWithoutOrderInput> | p2p_ratingsCreateWithoutOrderInput[] | p2p_ratingsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutOrderInput | p2p_ratingsCreateOrConnectWithoutOrderInput[]
    upsert?: p2p_ratingsUpsertWithWhereUniqueWithoutOrderInput | p2p_ratingsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: p2p_ratingsCreateManyOrderInputEnvelope
    set?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    disconnect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    delete?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    update?: p2p_ratingsUpdateWithWhereUniqueWithoutOrderInput | p2p_ratingsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: p2p_ratingsUpdateManyWithWhereWithoutOrderInput | p2p_ratingsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
  }

  export type p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<p2p_messagesCreateWithoutOrderInput, p2p_messagesUncheckedCreateWithoutOrderInput> | p2p_messagesCreateWithoutOrderInput[] | p2p_messagesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_messagesCreateOrConnectWithoutOrderInput | p2p_messagesCreateOrConnectWithoutOrderInput[]
    upsert?: p2p_messagesUpsertWithWhereUniqueWithoutOrderInput | p2p_messagesUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: p2p_messagesCreateManyOrderInputEnvelope
    set?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    disconnect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    delete?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    connect?: p2p_messagesWhereUniqueInput | p2p_messagesWhereUniqueInput[]
    update?: p2p_messagesUpdateWithWhereUniqueWithoutOrderInput | p2p_messagesUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: p2p_messagesUpdateManyWithWhereWithoutOrderInput | p2p_messagesUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: p2p_messagesScalarWhereInput | p2p_messagesScalarWhereInput[]
  }

  export type p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<p2p_disputesCreateWithoutOrderInput, p2p_disputesUncheckedCreateWithoutOrderInput> | p2p_disputesCreateWithoutOrderInput[] | p2p_disputesUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_disputesCreateOrConnectWithoutOrderInput | p2p_disputesCreateOrConnectWithoutOrderInput[]
    upsert?: p2p_disputesUpsertWithWhereUniqueWithoutOrderInput | p2p_disputesUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: p2p_disputesCreateManyOrderInputEnvelope
    set?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    disconnect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    delete?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    connect?: p2p_disputesWhereUniqueInput | p2p_disputesWhereUniqueInput[]
    update?: p2p_disputesUpdateWithWhereUniqueWithoutOrderInput | p2p_disputesUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: p2p_disputesUpdateManyWithWhereWithoutOrderInput | p2p_disputesUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: p2p_disputesScalarWhereInput | p2p_disputesScalarWhereInput[]
  }

  export type p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<p2p_ratingsCreateWithoutOrderInput, p2p_ratingsUncheckedCreateWithoutOrderInput> | p2p_ratingsCreateWithoutOrderInput[] | p2p_ratingsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: p2p_ratingsCreateOrConnectWithoutOrderInput | p2p_ratingsCreateOrConnectWithoutOrderInput[]
    upsert?: p2p_ratingsUpsertWithWhereUniqueWithoutOrderInput | p2p_ratingsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: p2p_ratingsCreateManyOrderInputEnvelope
    set?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    disconnect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    delete?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    connect?: p2p_ratingsWhereUniqueInput | p2p_ratingsWhereUniqueInput[]
    update?: p2p_ratingsUpdateWithWhereUniqueWithoutOrderInput | p2p_ratingsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: p2p_ratingsUpdateManyWithWhereWithoutOrderInput | p2p_ratingsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
  }

  export type p2p_ordersCreateNestedOneWithoutMessagesInput = {
    create?: XOR<p2p_ordersCreateWithoutMessagesInput, p2p_ordersUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutMessagesInput
    connect?: p2p_ordersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutP2p_messages_sentInput = {
    create?: XOR<usersCreateWithoutP2p_messages_sentInput, usersUncheckedCreateWithoutP2p_messages_sentInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_messages_sentInput
    connect?: usersWhereUniqueInput
  }

  export type p2p_ordersUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutMessagesInput, p2p_ordersUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutMessagesInput
    upsert?: p2p_ordersUpsertWithoutMessagesInput
    connect?: p2p_ordersWhereUniqueInput
    update?: XOR<XOR<p2p_ordersUpdateToOneWithWhereWithoutMessagesInput, p2p_ordersUpdateWithoutMessagesInput>, p2p_ordersUncheckedUpdateWithoutMessagesInput>
  }

  export type usersUpdateOneRequiredWithoutP2p_messages_sentNestedInput = {
    create?: XOR<usersCreateWithoutP2p_messages_sentInput, usersUncheckedCreateWithoutP2p_messages_sentInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_messages_sentInput
    upsert?: usersUpsertWithoutP2p_messages_sentInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_messages_sentInput, usersUpdateWithoutP2p_messages_sentInput>, usersUncheckedUpdateWithoutP2p_messages_sentInput>
  }

  export type p2p_ordersCreateNestedOneWithoutDisputesInput = {
    create?: XOR<p2p_ordersCreateWithoutDisputesInput, p2p_ordersUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutDisputesInput
    connect?: p2p_ordersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutP2p_disputes_raisedInput = {
    create?: XOR<usersCreateWithoutP2p_disputes_raisedInput, usersUncheckedCreateWithoutP2p_disputes_raisedInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_disputes_raisedInput
    connect?: usersWhereUniqueInput
  }

  export type EnumP2PDisputeStatusFieldUpdateOperationsInput = {
    set?: $Enums.P2PDisputeStatus
  }

  export type p2p_ordersUpdateOneRequiredWithoutDisputesNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutDisputesInput, p2p_ordersUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutDisputesInput
    upsert?: p2p_ordersUpsertWithoutDisputesInput
    connect?: p2p_ordersWhereUniqueInput
    update?: XOR<XOR<p2p_ordersUpdateToOneWithWhereWithoutDisputesInput, p2p_ordersUpdateWithoutDisputesInput>, p2p_ordersUncheckedUpdateWithoutDisputesInput>
  }

  export type usersUpdateOneRequiredWithoutP2p_disputes_raisedNestedInput = {
    create?: XOR<usersCreateWithoutP2p_disputes_raisedInput, usersUncheckedCreateWithoutP2p_disputes_raisedInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_disputes_raisedInput
    upsert?: usersUpsertWithoutP2p_disputes_raisedInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_disputes_raisedInput, usersUpdateWithoutP2p_disputes_raisedInput>, usersUncheckedUpdateWithoutP2p_disputes_raisedInput>
  }

  export type p2p_ordersCreateNestedOneWithoutRatingsInput = {
    create?: XOR<p2p_ordersCreateWithoutRatingsInput, p2p_ordersUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutRatingsInput
    connect?: p2p_ordersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutP2p_ratings_fromInput = {
    create?: XOR<usersCreateWithoutP2p_ratings_fromInput, usersUncheckedCreateWithoutP2p_ratings_fromInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_ratings_fromInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutP2p_ratings_toInput = {
    create?: XOR<usersCreateWithoutP2p_ratings_toInput, usersUncheckedCreateWithoutP2p_ratings_toInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_ratings_toInput
    connect?: usersWhereUniqueInput
  }

  export type p2p_ordersUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<p2p_ordersCreateWithoutRatingsInput, p2p_ordersUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: p2p_ordersCreateOrConnectWithoutRatingsInput
    upsert?: p2p_ordersUpsertWithoutRatingsInput
    connect?: p2p_ordersWhereUniqueInput
    update?: XOR<XOR<p2p_ordersUpdateToOneWithWhereWithoutRatingsInput, p2p_ordersUpdateWithoutRatingsInput>, p2p_ordersUncheckedUpdateWithoutRatingsInput>
  }

  export type usersUpdateOneRequiredWithoutP2p_ratings_fromNestedInput = {
    create?: XOR<usersCreateWithoutP2p_ratings_fromInput, usersUncheckedCreateWithoutP2p_ratings_fromInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_ratings_fromInput
    upsert?: usersUpsertWithoutP2p_ratings_fromInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_ratings_fromInput, usersUpdateWithoutP2p_ratings_fromInput>, usersUncheckedUpdateWithoutP2p_ratings_fromInput>
  }

  export type usersUpdateOneRequiredWithoutP2p_ratings_toNestedInput = {
    create?: XOR<usersCreateWithoutP2p_ratings_toInput, usersUncheckedCreateWithoutP2p_ratings_toInput>
    connectOrCreate?: usersCreateOrConnectWithoutP2p_ratings_toInput
    upsert?: usersUpsertWithoutP2p_ratings_toInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutP2p_ratings_toInput, usersUpdateWithoutP2p_ratings_toInput>, usersUncheckedUpdateWithoutP2p_ratings_toInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPairStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PairStatus | EnumPairStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PairStatus[]
    notIn?: $Enums.PairStatus[]
    not?: NestedEnumPairStatusFilter<$PrismaModel> | $Enums.PairStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPairStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PairStatus | EnumPairStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PairStatus[]
    notIn?: $Enums.PairStatus[]
    not?: NestedEnumPairStatusWithAggregatesFilter<$PrismaModel> | $Enums.PairStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPairStatusFilter<$PrismaModel>
    _max?: NestedEnumPairStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDepositSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositSessionStatus | EnumDepositSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositSessionStatus[]
    notIn?: $Enums.DepositSessionStatus[]
    not?: NestedEnumDepositSessionStatusFilter<$PrismaModel> | $Enums.DepositSessionStatus
  }

  export type NestedEnumDepositSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositSessionStatus | EnumDepositSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositSessionStatus[]
    notIn?: $Enums.DepositSessionStatus[]
    not?: NestedEnumDepositSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.DepositSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumDepositSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[]
    notIn?: $Enums.LedgerType[]
    not?: NestedEnumLedgerTypeFilter<$PrismaModel> | $Enums.LedgerType
  }

  export type NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[]
    notIn?: $Enums.LedgerType[]
    not?: NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumP2POrderSideFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POrderSide | EnumP2POrderSideFieldRefInput<$PrismaModel>
    in?: $Enums.P2POrderSide[]
    notIn?: $Enums.P2POrderSide[]
    not?: NestedEnumP2POrderSideFilter<$PrismaModel> | $Enums.P2POrderSide
  }

  export type NestedEnumP2POfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POfferStatus | EnumP2POfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2POfferStatus[]
    notIn?: $Enums.P2POfferStatus[]
    not?: NestedEnumP2POfferStatusFilter<$PrismaModel> | $Enums.P2POfferStatus
  }

  export type NestedEnumP2POrderSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POrderSide | EnumP2POrderSideFieldRefInput<$PrismaModel>
    in?: $Enums.P2POrderSide[]
    notIn?: $Enums.P2POrderSide[]
    not?: NestedEnumP2POrderSideWithAggregatesFilter<$PrismaModel> | $Enums.P2POrderSide
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2POrderSideFilter<$PrismaModel>
    _max?: NestedEnumP2POrderSideFilter<$PrismaModel>
  }

  export type NestedEnumP2POfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2POfferStatus | EnumP2POfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2POfferStatus[]
    notIn?: $Enums.P2POfferStatus[]
    not?: NestedEnumP2POfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2POfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2POfferStatusFilter<$PrismaModel>
    _max?: NestedEnumP2POfferStatusFilter<$PrismaModel>
  }

  export type NestedEnumP2PTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PTradeStatus | EnumP2PTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PTradeStatus[]
    notIn?: $Enums.P2PTradeStatus[]
    not?: NestedEnumP2PTradeStatusFilter<$PrismaModel> | $Enums.P2PTradeStatus
  }

  export type NestedEnumP2PTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PTradeStatus | EnumP2PTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PTradeStatus[]
    notIn?: $Enums.P2PTradeStatus[]
    not?: NestedEnumP2PTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2PTradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2PTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumP2PTradeStatusFilter<$PrismaModel>
  }

  export type NestedEnumP2PDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PDisputeStatus | EnumP2PDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PDisputeStatus[]
    notIn?: $Enums.P2PDisputeStatus[]
    not?: NestedEnumP2PDisputeStatusFilter<$PrismaModel> | $Enums.P2PDisputeStatus
  }

  export type NestedEnumP2PDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PDisputeStatus | EnumP2PDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PDisputeStatus[]
    notIn?: $Enums.P2PDisputeStatus[]
    not?: NestedEnumP2PDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2PDisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2PDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumP2PDisputeStatusFilter<$PrismaModel>
  }

  export type chat_messagesCreateWithoutUsersInput = {
    id?: string
    sender?: string | null
    message?: string | null
    time?: Date | string
  }

  export type chat_messagesUncheckedCreateWithoutUsersInput = {
    id?: string
    sender?: string | null
    message?: string | null
    time?: Date | string
  }

  export type chat_messagesCreateOrConnectWithoutUsersInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput>
  }

  export type chat_messagesCreateManyUsersInputEnvelope = {
    data: chat_messagesCreateManyUsersInput | chat_messagesCreateManyUsersInput[]
  }

  export type depositsCreateWithoutUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type depositsUncheckedCreateWithoutUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type depositsCreateOrConnectWithoutUsersInput = {
    where: depositsWhereUniqueInput
    create: XOR<depositsCreateWithoutUsersInput, depositsUncheckedCreateWithoutUsersInput>
  }

  export type depositsCreateManyUsersInputEnvelope = {
    data: depositsCreateManyUsersInput | depositsCreateManyUsersInput[]
  }

  export type leaderboardCreateWithoutUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    updated_at?: Date | string
  }

  export type leaderboardUncheckedCreateWithoutUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    updated_at?: Date | string
  }

  export type leaderboardCreateOrConnectWithoutUsersInput = {
    where: leaderboardWhereUniqueInput
    create: XOR<leaderboardCreateWithoutUsersInput, leaderboardUncheckedCreateWithoutUsersInput>
  }

  export type leaderboardCreateManyUsersInputEnvelope = {
    data: leaderboardCreateManyUsersInput | leaderboardCreateManyUsersInput[]
  }

  export type settingsCreateWithoutUsersInput = {
    id?: string
    notifications?: boolean | null
    private?: boolean | null
  }

  export type settingsUncheckedCreateWithoutUsersInput = {
    id?: string
    notifications?: boolean | null
    private?: boolean | null
  }

  export type settingsCreateOrConnectWithoutUsersInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutUsersInput, settingsUncheckedCreateWithoutUsersInput>
  }

  export type settingsCreateManyUsersInputEnvelope = {
    data: settingsCreateManyUsersInput | settingsCreateManyUsersInput[]
  }

  export type support_messagesCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type support_messagesUncheckedCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type support_messagesCreateOrConnectWithoutUsersInput = {
    where: support_messagesWhereUniqueInput
    create: XOR<support_messagesCreateWithoutUsersInput, support_messagesUncheckedCreateWithoutUsersInput>
  }

  export type support_messagesCreateManyUsersInputEnvelope = {
    data: support_messagesCreateManyUsersInput | support_messagesCreateManyUsersInput[]
  }

  export type tradesCreateWithoutUsersInput = {
    id?: string
    symbol?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    direction?: string | null
    open_time?: Date | string | null
    close_time?: Date | string | null
    result?: string | null
    status?: string | null
    entry_price?: Decimal | DecimalJsLike | number | string | null
    payout?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    account_type?: string | null
  }

  export type tradesUncheckedCreateWithoutUsersInput = {
    id?: string
    symbol?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    direction?: string | null
    open_time?: Date | string | null
    close_time?: Date | string | null
    result?: string | null
    status?: string | null
    entry_price?: Decimal | DecimalJsLike | number | string | null
    payout?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    account_type?: string | null
  }

  export type tradesCreateOrConnectWithoutUsersInput = {
    where: tradesWhereUniqueInput
    create: XOR<tradesCreateWithoutUsersInput, tradesUncheckedCreateWithoutUsersInput>
  }

  export type tradesCreateManyUsersInputEnvelope = {
    data: tradesCreateManyUsersInput | tradesCreateManyUsersInput[]
  }

  export type withdrawalsCreateWithoutUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    created_at?: Date | string
  }

  export type withdrawalsUncheckedCreateWithoutUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    created_at?: Date | string
  }

  export type withdrawalsCreateOrConnectWithoutUsersInput = {
    where: withdrawalsWhereUniqueInput
    create: XOR<withdrawalsCreateWithoutUsersInput, withdrawalsUncheckedCreateWithoutUsersInput>
  }

  export type withdrawalsCreateManyUsersInputEnvelope = {
    data: withdrawalsCreateManyUsersInput | withdrawalsCreateManyUsersInput[]
  }

  export type deposit_sessionsCreateWithoutUsersInput = {
    id?: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    crypto_assets: crypto_assetsCreateNestedOneWithoutDeposit_sessionsInput
  }

  export type deposit_sessionsUncheckedCreateWithoutUsersInput = {
    id?: string
    crypto_asset_id: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type deposit_sessionsCreateOrConnectWithoutUsersInput = {
    where: deposit_sessionsWhereUniqueInput
    create: XOR<deposit_sessionsCreateWithoutUsersInput, deposit_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type deposit_sessionsCreateManyUsersInputEnvelope = {
    data: deposit_sessionsCreateManyUsersInput | deposit_sessionsCreateManyUsersInput[]
  }

  export type wallet_ledgerCreateWithoutUsersInput = {
    id?: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type wallet_ledgerUncheckedCreateWithoutUsersInput = {
    id?: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type wallet_ledgerCreateOrConnectWithoutUsersInput = {
    where: wallet_ledgerWhereUniqueInput
    create: XOR<wallet_ledgerCreateWithoutUsersInput, wallet_ledgerUncheckedCreateWithoutUsersInput>
  }

  export type wallet_ledgerCreateManyUsersInputEnvelope = {
    data: wallet_ledgerCreateManyUsersInput | wallet_ledgerCreateManyUsersInput[]
  }

  export type p2p_offersCreateWithoutUsersInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    payment_methods?: p2p_offer_payment_methodsCreateNestedManyWithoutOfferInput
    orders?: p2p_ordersCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersUncheckedCreateWithoutUsersInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    payment_methods?: p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutOfferInput
    orders?: p2p_ordersUncheckedCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersCreateOrConnectWithoutUsersInput = {
    where: p2p_offersWhereUniqueInput
    create: XOR<p2p_offersCreateWithoutUsersInput, p2p_offersUncheckedCreateWithoutUsersInput>
  }

  export type p2p_offersCreateManyUsersInputEnvelope = {
    data: p2p_offersCreateManyUsersInput | p2p_offersCreateManyUsersInput[]
  }

  export type user_payment_methodsCreateWithoutUsersInput = {
    id?: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    offers?: p2p_offer_payment_methodsCreateNestedManyWithoutPayment_methodInput
  }

  export type user_payment_methodsUncheckedCreateWithoutUsersInput = {
    id?: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    offers?: p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type user_payment_methodsCreateOrConnectWithoutUsersInput = {
    where: user_payment_methodsWhereUniqueInput
    create: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput>
  }

  export type user_payment_methodsCreateManyUsersInputEnvelope = {
    data: user_payment_methodsCreateManyUsersInput | user_payment_methodsCreateManyUsersInput[]
  }

  export type p2p_ordersCreateWithoutMakerInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    offer: p2p_offersCreateNestedOneWithoutOrdersInput
    taker: usersCreateNestedOneWithoutP2p_taker_ordersInput
    messages?: p2p_messagesCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateWithoutMakerInput = {
    id?: string
    offer_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    messages?: p2p_messagesUncheckedCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesUncheckedCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersCreateOrConnectWithoutMakerInput = {
    where: p2p_ordersWhereUniqueInput
    create: XOR<p2p_ordersCreateWithoutMakerInput, p2p_ordersUncheckedCreateWithoutMakerInput>
  }

  export type p2p_ordersCreateManyMakerInputEnvelope = {
    data: p2p_ordersCreateManyMakerInput | p2p_ordersCreateManyMakerInput[]
  }

  export type p2p_ordersCreateWithoutTakerInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    offer: p2p_offersCreateNestedOneWithoutOrdersInput
    maker: usersCreateNestedOneWithoutP2p_maker_ordersInput
    messages?: p2p_messagesCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateWithoutTakerInput = {
    id?: string
    offer_id: string
    maker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    messages?: p2p_messagesUncheckedCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesUncheckedCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersCreateOrConnectWithoutTakerInput = {
    where: p2p_ordersWhereUniqueInput
    create: XOR<p2p_ordersCreateWithoutTakerInput, p2p_ordersUncheckedCreateWithoutTakerInput>
  }

  export type p2p_ordersCreateManyTakerInputEnvelope = {
    data: p2p_ordersCreateManyTakerInput | p2p_ordersCreateManyTakerInput[]
  }

  export type p2p_messagesCreateWithoutSenderInput = {
    id?: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutMessagesInput
  }

  export type p2p_messagesUncheckedCreateWithoutSenderInput = {
    id?: string
    order_id: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_messagesCreateOrConnectWithoutSenderInput = {
    where: p2p_messagesWhereUniqueInput
    create: XOR<p2p_messagesCreateWithoutSenderInput, p2p_messagesUncheckedCreateWithoutSenderInput>
  }

  export type p2p_messagesCreateManySenderInputEnvelope = {
    data: p2p_messagesCreateManySenderInput | p2p_messagesCreateManySenderInput[]
  }

  export type p2p_disputesCreateWithoutRaised_byInput = {
    id?: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutDisputesInput
  }

  export type p2p_disputesUncheckedCreateWithoutRaised_byInput = {
    id?: string
    order_id: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_disputesCreateOrConnectWithoutRaised_byInput = {
    where: p2p_disputesWhereUniqueInput
    create: XOR<p2p_disputesCreateWithoutRaised_byInput, p2p_disputesUncheckedCreateWithoutRaised_byInput>
  }

  export type p2p_disputesCreateManyRaised_byInputEnvelope = {
    data: p2p_disputesCreateManyRaised_byInput | p2p_disputesCreateManyRaised_byInput[]
  }

  export type p2p_ratingsCreateWithoutFrom_userInput = {
    id?: string
    stars: number
    comment?: string | null
    created_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutRatingsInput
    to_user: usersCreateNestedOneWithoutP2p_ratings_toInput
  }

  export type p2p_ratingsUncheckedCreateWithoutFrom_userInput = {
    id?: string
    order_id: string
    to_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_ratingsCreateOrConnectWithoutFrom_userInput = {
    where: p2p_ratingsWhereUniqueInput
    create: XOR<p2p_ratingsCreateWithoutFrom_userInput, p2p_ratingsUncheckedCreateWithoutFrom_userInput>
  }

  export type p2p_ratingsCreateManyFrom_userInputEnvelope = {
    data: p2p_ratingsCreateManyFrom_userInput | p2p_ratingsCreateManyFrom_userInput[]
  }

  export type p2p_ratingsCreateWithoutTo_userInput = {
    id?: string
    stars: number
    comment?: string | null
    created_at?: Date | string
    order: p2p_ordersCreateNestedOneWithoutRatingsInput
    from_user: usersCreateNestedOneWithoutP2p_ratings_fromInput
  }

  export type p2p_ratingsUncheckedCreateWithoutTo_userInput = {
    id?: string
    order_id: string
    from_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_ratingsCreateOrConnectWithoutTo_userInput = {
    where: p2p_ratingsWhereUniqueInput
    create: XOR<p2p_ratingsCreateWithoutTo_userInput, p2p_ratingsUncheckedCreateWithoutTo_userInput>
  }

  export type p2p_ratingsCreateManyTo_userInputEnvelope = {
    data: p2p_ratingsCreateManyTo_userInput | p2p_ratingsCreateManyTo_userInput[]
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutUsersInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutUsersInput, chat_messagesUncheckedUpdateWithoutUsersInput>
    create: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutUsersInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutUsersInput, chat_messagesUncheckedUpdateWithoutUsersInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutUsersInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutUsersInput>
  }

  export type chat_messagesScalarWhereInput = {
    AND?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    OR?: chat_messagesScalarWhereInput[]
    NOT?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    id?: StringFilter<"chat_messages"> | string
    user_id?: StringNullableFilter<"chat_messages"> | string | null
    sender?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringNullableFilter<"chat_messages"> | string | null
    time?: DateTimeFilter<"chat_messages"> | Date | string
  }

  export type depositsUpsertWithWhereUniqueWithoutUsersInput = {
    where: depositsWhereUniqueInput
    update: XOR<depositsUpdateWithoutUsersInput, depositsUncheckedUpdateWithoutUsersInput>
    create: XOR<depositsCreateWithoutUsersInput, depositsUncheckedCreateWithoutUsersInput>
  }

  export type depositsUpdateWithWhereUniqueWithoutUsersInput = {
    where: depositsWhereUniqueInput
    data: XOR<depositsUpdateWithoutUsersInput, depositsUncheckedUpdateWithoutUsersInput>
  }

  export type depositsUpdateManyWithWhereWithoutUsersInput = {
    where: depositsScalarWhereInput
    data: XOR<depositsUpdateManyMutationInput, depositsUncheckedUpdateManyWithoutUsersInput>
  }

  export type depositsScalarWhereInput = {
    AND?: depositsScalarWhereInput | depositsScalarWhereInput[]
    OR?: depositsScalarWhereInput[]
    NOT?: depositsScalarWhereInput | depositsScalarWhereInput[]
    id?: StringFilter<"deposits"> | string
    user_id?: StringNullableFilter<"deposits"> | string | null
    amount?: DecimalNullableFilter<"deposits"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableFilter<"deposits"> | string | null
    status?: StringNullableFilter<"deposits"> | string | null
    created_at?: DateTimeFilter<"deposits"> | Date | string
  }

  export type leaderboardUpsertWithWhereUniqueWithoutUsersInput = {
    where: leaderboardWhereUniqueInput
    update: XOR<leaderboardUpdateWithoutUsersInput, leaderboardUncheckedUpdateWithoutUsersInput>
    create: XOR<leaderboardCreateWithoutUsersInput, leaderboardUncheckedCreateWithoutUsersInput>
  }

  export type leaderboardUpdateWithWhereUniqueWithoutUsersInput = {
    where: leaderboardWhereUniqueInput
    data: XOR<leaderboardUpdateWithoutUsersInput, leaderboardUncheckedUpdateWithoutUsersInput>
  }

  export type leaderboardUpdateManyWithWhereWithoutUsersInput = {
    where: leaderboardScalarWhereInput
    data: XOR<leaderboardUpdateManyMutationInput, leaderboardUncheckedUpdateManyWithoutUsersInput>
  }

  export type leaderboardScalarWhereInput = {
    AND?: leaderboardScalarWhereInput | leaderboardScalarWhereInput[]
    OR?: leaderboardScalarWhereInput[]
    NOT?: leaderboardScalarWhereInput | leaderboardScalarWhereInput[]
    id?: StringFilter<"leaderboard"> | string
    user_id?: StringNullableFilter<"leaderboard"> | string | null
    amount?: DecimalNullableFilter<"leaderboard"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableFilter<"leaderboard"> | number | null
    updated_at?: DateTimeFilter<"leaderboard"> | Date | string
  }

  export type settingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: settingsWhereUniqueInput
    update: XOR<settingsUpdateWithoutUsersInput, settingsUncheckedUpdateWithoutUsersInput>
    create: XOR<settingsCreateWithoutUsersInput, settingsUncheckedCreateWithoutUsersInput>
  }

  export type settingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: settingsWhereUniqueInput
    data: XOR<settingsUpdateWithoutUsersInput, settingsUncheckedUpdateWithoutUsersInput>
  }

  export type settingsUpdateManyWithWhereWithoutUsersInput = {
    where: settingsScalarWhereInput
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type settingsScalarWhereInput = {
    AND?: settingsScalarWhereInput | settingsScalarWhereInput[]
    OR?: settingsScalarWhereInput[]
    NOT?: settingsScalarWhereInput | settingsScalarWhereInput[]
    id?: StringFilter<"settings"> | string
    user_id?: StringNullableFilter<"settings"> | string | null
    notifications?: BoolNullableFilter<"settings"> | boolean | null
    private?: BoolNullableFilter<"settings"> | boolean | null
  }

  export type support_messagesUpsertWithWhereUniqueWithoutUsersInput = {
    where: support_messagesWhereUniqueInput
    update: XOR<support_messagesUpdateWithoutUsersInput, support_messagesUncheckedUpdateWithoutUsersInput>
    create: XOR<support_messagesCreateWithoutUsersInput, support_messagesUncheckedCreateWithoutUsersInput>
  }

  export type support_messagesUpdateWithWhereUniqueWithoutUsersInput = {
    where: support_messagesWhereUniqueInput
    data: XOR<support_messagesUpdateWithoutUsersInput, support_messagesUncheckedUpdateWithoutUsersInput>
  }

  export type support_messagesUpdateManyWithWhereWithoutUsersInput = {
    where: support_messagesScalarWhereInput
    data: XOR<support_messagesUpdateManyMutationInput, support_messagesUncheckedUpdateManyWithoutUsersInput>
  }

  export type support_messagesScalarWhereInput = {
    AND?: support_messagesScalarWhereInput | support_messagesScalarWhereInput[]
    OR?: support_messagesScalarWhereInput[]
    NOT?: support_messagesScalarWhereInput | support_messagesScalarWhereInput[]
    id?: StringFilter<"support_messages"> | string
    user_id?: StringNullableFilter<"support_messages"> | string | null
    name?: StringNullableFilter<"support_messages"> | string | null
    email?: StringNullableFilter<"support_messages"> | string | null
    subject?: StringNullableFilter<"support_messages"> | string | null
    message?: StringNullableFilter<"support_messages"> | string | null
    created_at?: DateTimeFilter<"support_messages"> | Date | string
  }

  export type tradesUpsertWithWhereUniqueWithoutUsersInput = {
    where: tradesWhereUniqueInput
    update: XOR<tradesUpdateWithoutUsersInput, tradesUncheckedUpdateWithoutUsersInput>
    create: XOR<tradesCreateWithoutUsersInput, tradesUncheckedCreateWithoutUsersInput>
  }

  export type tradesUpdateWithWhereUniqueWithoutUsersInput = {
    where: tradesWhereUniqueInput
    data: XOR<tradesUpdateWithoutUsersInput, tradesUncheckedUpdateWithoutUsersInput>
  }

  export type tradesUpdateManyWithWhereWithoutUsersInput = {
    where: tradesScalarWhereInput
    data: XOR<tradesUpdateManyMutationInput, tradesUncheckedUpdateManyWithoutUsersInput>
  }

  export type tradesScalarWhereInput = {
    AND?: tradesScalarWhereInput | tradesScalarWhereInput[]
    OR?: tradesScalarWhereInput[]
    NOT?: tradesScalarWhereInput | tradesScalarWhereInput[]
    id?: StringFilter<"trades"> | string
    user_id?: StringNullableFilter<"trades"> | string | null
    symbol?: StringNullableFilter<"trades"> | string | null
    amount?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    direction?: StringNullableFilter<"trades"> | string | null
    open_time?: DateTimeNullableFilter<"trades"> | Date | string | null
    close_time?: DateTimeNullableFilter<"trades"> | Date | string | null
    result?: StringNullableFilter<"trades"> | string | null
    status?: StringNullableFilter<"trades"> | string | null
    entry_price?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    payout?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"trades"> | Date | string
    updated_at?: DateTimeFilter<"trades"> | Date | string
    account_type?: StringNullableFilter<"trades"> | string | null
  }

  export type withdrawalsUpsertWithWhereUniqueWithoutUsersInput = {
    where: withdrawalsWhereUniqueInput
    update: XOR<withdrawalsUpdateWithoutUsersInput, withdrawalsUncheckedUpdateWithoutUsersInput>
    create: XOR<withdrawalsCreateWithoutUsersInput, withdrawalsUncheckedCreateWithoutUsersInput>
  }

  export type withdrawalsUpdateWithWhereUniqueWithoutUsersInput = {
    where: withdrawalsWhereUniqueInput
    data: XOR<withdrawalsUpdateWithoutUsersInput, withdrawalsUncheckedUpdateWithoutUsersInput>
  }

  export type withdrawalsUpdateManyWithWhereWithoutUsersInput = {
    where: withdrawalsScalarWhereInput
    data: XOR<withdrawalsUpdateManyMutationInput, withdrawalsUncheckedUpdateManyWithoutUsersInput>
  }

  export type withdrawalsScalarWhereInput = {
    AND?: withdrawalsScalarWhereInput | withdrawalsScalarWhereInput[]
    OR?: withdrawalsScalarWhereInput[]
    NOT?: withdrawalsScalarWhereInput | withdrawalsScalarWhereInput[]
    id?: StringFilter<"withdrawals"> | string
    user_id?: StringNullableFilter<"withdrawals"> | string | null
    amount?: DecimalNullableFilter<"withdrawals"> | Decimal | DecimalJsLike | number | string | null
    method?: StringNullableFilter<"withdrawals"> | string | null
    account_info?: JsonNullableFilter<"withdrawals">
    status?: StringNullableFilter<"withdrawals"> | string | null
    created_at?: DateTimeFilter<"withdrawals"> | Date | string
  }

  export type deposit_sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: deposit_sessionsWhereUniqueInput
    update: XOR<deposit_sessionsUpdateWithoutUsersInput, deposit_sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<deposit_sessionsCreateWithoutUsersInput, deposit_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type deposit_sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: deposit_sessionsWhereUniqueInput
    data: XOR<deposit_sessionsUpdateWithoutUsersInput, deposit_sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type deposit_sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: deposit_sessionsScalarWhereInput
    data: XOR<deposit_sessionsUpdateManyMutationInput, deposit_sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type deposit_sessionsScalarWhereInput = {
    AND?: deposit_sessionsScalarWhereInput | deposit_sessionsScalarWhereInput[]
    OR?: deposit_sessionsScalarWhereInput[]
    NOT?: deposit_sessionsScalarWhereInput | deposit_sessionsScalarWhereInput[]
    id?: StringFilter<"deposit_sessions"> | string
    user_id?: StringFilter<"deposit_sessions"> | string
    crypto_asset_id?: StringFilter<"deposit_sessions"> | string
    address?: StringFilter<"deposit_sessions"> | string
    derivation_path?: StringNullableFilter<"deposit_sessions"> | string | null
    memo_tag?: StringNullableFilter<"deposit_sessions"> | string | null
    amount_expected?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    rate_source?: StringNullableFilter<"deposit_sessions"> | string | null
    status?: EnumDepositSessionStatusFilter<"deposit_sessions"> | $Enums.DepositSessionStatus
    tx_hash?: StringNullableFilter<"deposit_sessions"> | string | null
    detected_amount?: DecimalNullableFilter<"deposit_sessions"> | Decimal | DecimalJsLike | number | string | null
    confirmations?: IntNullableFilter<"deposit_sessions"> | number | null
    min_confirmations?: IntFilter<"deposit_sessions"> | number
    is_late?: BoolFilter<"deposit_sessions"> | boolean
    expires_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    created_at?: DateTimeFilter<"deposit_sessions"> | Date | string
    updated_at?: DateTimeFilter<"deposit_sessions"> | Date | string
  }

  export type wallet_ledgerUpsertWithWhereUniqueWithoutUsersInput = {
    where: wallet_ledgerWhereUniqueInput
    update: XOR<wallet_ledgerUpdateWithoutUsersInput, wallet_ledgerUncheckedUpdateWithoutUsersInput>
    create: XOR<wallet_ledgerCreateWithoutUsersInput, wallet_ledgerUncheckedCreateWithoutUsersInput>
  }

  export type wallet_ledgerUpdateWithWhereUniqueWithoutUsersInput = {
    where: wallet_ledgerWhereUniqueInput
    data: XOR<wallet_ledgerUpdateWithoutUsersInput, wallet_ledgerUncheckedUpdateWithoutUsersInput>
  }

  export type wallet_ledgerUpdateManyWithWhereWithoutUsersInput = {
    where: wallet_ledgerScalarWhereInput
    data: XOR<wallet_ledgerUpdateManyMutationInput, wallet_ledgerUncheckedUpdateManyWithoutUsersInput>
  }

  export type wallet_ledgerScalarWhereInput = {
    AND?: wallet_ledgerScalarWhereInput | wallet_ledgerScalarWhereInput[]
    OR?: wallet_ledgerScalarWhereInput[]
    NOT?: wallet_ledgerScalarWhereInput | wallet_ledgerScalarWhereInput[]
    id?: StringFilter<"wallet_ledger"> | string
    user_id?: StringFilter<"wallet_ledger"> | string
    type?: EnumLedgerTypeFilter<"wallet_ledger"> | $Enums.LedgerType
    asset?: StringFilter<"wallet_ledger"> | string
    amount?: DecimalFilter<"wallet_ledger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableFilter<"wallet_ledger">
    created_at?: DateTimeFilter<"wallet_ledger"> | Date | string
  }

  export type p2p_offersUpsertWithWhereUniqueWithoutUsersInput = {
    where: p2p_offersWhereUniqueInput
    update: XOR<p2p_offersUpdateWithoutUsersInput, p2p_offersUncheckedUpdateWithoutUsersInput>
    create: XOR<p2p_offersCreateWithoutUsersInput, p2p_offersUncheckedCreateWithoutUsersInput>
  }

  export type p2p_offersUpdateWithWhereUniqueWithoutUsersInput = {
    where: p2p_offersWhereUniqueInput
    data: XOR<p2p_offersUpdateWithoutUsersInput, p2p_offersUncheckedUpdateWithoutUsersInput>
  }

  export type p2p_offersUpdateManyWithWhereWithoutUsersInput = {
    where: p2p_offersScalarWhereInput
    data: XOR<p2p_offersUpdateManyMutationInput, p2p_offersUncheckedUpdateManyWithoutUsersInput>
  }

  export type p2p_offersScalarWhereInput = {
    AND?: p2p_offersScalarWhereInput | p2p_offersScalarWhereInput[]
    OR?: p2p_offersScalarWhereInput[]
    NOT?: p2p_offersScalarWhereInput | p2p_offersScalarWhereInput[]
    id?: StringFilter<"p2p_offers"> | string
    user_id?: StringFilter<"p2p_offers"> | string
    side?: EnumP2POrderSideFilter<"p2p_offers"> | $Enums.P2POrderSide
    asset_symbol?: StringFilter<"p2p_offers"> | string
    crypto_asset_id?: StringNullableFilter<"p2p_offers"> | string | null
    fiat_currency?: StringFilter<"p2p_offers"> | string
    price_type?: StringFilter<"p2p_offers"> | string
    fixed_price?: DecimalNullableFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    margin_percent?: DecimalNullableFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFilter<"p2p_offers"> | Decimal | DecimalJsLike | number | string
    terms?: StringNullableFilter<"p2p_offers"> | string | null
    auto_reply?: StringNullableFilter<"p2p_offers"> | string | null
    status?: EnumP2POfferStatusFilter<"p2p_offers"> | $Enums.P2POfferStatus
    total_trades?: IntFilter<"p2p_offers"> | number
    completion_rate?: IntFilter<"p2p_offers"> | number
    created_at?: DateTimeFilter<"p2p_offers"> | Date | string
    updated_at?: DateTimeFilter<"p2p_offers"> | Date | string
  }

  export type user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_payment_methodsWhereUniqueInput
    update: XOR<user_payment_methodsUpdateWithoutUsersInput, user_payment_methodsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput>
  }

  export type user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_payment_methodsWhereUniqueInput
    data: XOR<user_payment_methodsUpdateWithoutUsersInput, user_payment_methodsUncheckedUpdateWithoutUsersInput>
  }

  export type user_payment_methodsUpdateManyWithWhereWithoutUsersInput = {
    where: user_payment_methodsScalarWhereInput
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_payment_methodsScalarWhereInput = {
    AND?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
    OR?: user_payment_methodsScalarWhereInput[]
    NOT?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
    id?: StringFilter<"user_payment_methods"> | string
    user_id?: StringFilter<"user_payment_methods"> | string
    type?: EnumPaymentMethodTypeFilter<"user_payment_methods"> | $Enums.PaymentMethodType
    label?: StringNullableFilter<"user_payment_methods"> | string | null
    details?: JsonNullableFilter<"user_payment_methods">
    is_verified?: BoolFilter<"user_payment_methods"> | boolean
    is_active?: BoolFilter<"user_payment_methods"> | boolean
    created_at?: DateTimeFilter<"user_payment_methods"> | Date | string
    updated_at?: DateTimeFilter<"user_payment_methods"> | Date | string
  }

  export type p2p_ordersUpsertWithWhereUniqueWithoutMakerInput = {
    where: p2p_ordersWhereUniqueInput
    update: XOR<p2p_ordersUpdateWithoutMakerInput, p2p_ordersUncheckedUpdateWithoutMakerInput>
    create: XOR<p2p_ordersCreateWithoutMakerInput, p2p_ordersUncheckedCreateWithoutMakerInput>
  }

  export type p2p_ordersUpdateWithWhereUniqueWithoutMakerInput = {
    where: p2p_ordersWhereUniqueInput
    data: XOR<p2p_ordersUpdateWithoutMakerInput, p2p_ordersUncheckedUpdateWithoutMakerInput>
  }

  export type p2p_ordersUpdateManyWithWhereWithoutMakerInput = {
    where: p2p_ordersScalarWhereInput
    data: XOR<p2p_ordersUpdateManyMutationInput, p2p_ordersUncheckedUpdateManyWithoutMakerInput>
  }

  export type p2p_ordersScalarWhereInput = {
    AND?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
    OR?: p2p_ordersScalarWhereInput[]
    NOT?: p2p_ordersScalarWhereInput | p2p_ordersScalarWhereInput[]
    id?: StringFilter<"p2p_orders"> | string
    offer_id?: StringFilter<"p2p_orders"> | string
    maker_id?: StringFilter<"p2p_orders"> | string
    taker_id?: StringFilter<"p2p_orders"> | string
    side?: EnumP2POrderSideFilter<"p2p_orders"> | $Enums.P2POrderSide
    asset_symbol?: StringFilter<"p2p_orders"> | string
    fiat_currency?: StringFilter<"p2p_orders"> | string
    price?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFilter<"p2p_orders"> | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFilter<"p2p_orders"> | $Enums.P2PTradeStatus
    escrow_held?: BoolFilter<"p2p_orders"> | boolean
    escrow_ledger_id?: StringNullableFilter<"p2p_orders"> | string | null
    reference_code?: StringNullableFilter<"p2p_orders"> | string | null
    meta?: JsonNullableFilter<"p2p_orders">
    expires_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    paid_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    released_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    canceled_at?: DateTimeNullableFilter<"p2p_orders"> | Date | string | null
    created_at?: DateTimeFilter<"p2p_orders"> | Date | string
    updated_at?: DateTimeFilter<"p2p_orders"> | Date | string
  }

  export type p2p_ordersUpsertWithWhereUniqueWithoutTakerInput = {
    where: p2p_ordersWhereUniqueInput
    update: XOR<p2p_ordersUpdateWithoutTakerInput, p2p_ordersUncheckedUpdateWithoutTakerInput>
    create: XOR<p2p_ordersCreateWithoutTakerInput, p2p_ordersUncheckedCreateWithoutTakerInput>
  }

  export type p2p_ordersUpdateWithWhereUniqueWithoutTakerInput = {
    where: p2p_ordersWhereUniqueInput
    data: XOR<p2p_ordersUpdateWithoutTakerInput, p2p_ordersUncheckedUpdateWithoutTakerInput>
  }

  export type p2p_ordersUpdateManyWithWhereWithoutTakerInput = {
    where: p2p_ordersScalarWhereInput
    data: XOR<p2p_ordersUpdateManyMutationInput, p2p_ordersUncheckedUpdateManyWithoutTakerInput>
  }

  export type p2p_messagesUpsertWithWhereUniqueWithoutSenderInput = {
    where: p2p_messagesWhereUniqueInput
    update: XOR<p2p_messagesUpdateWithoutSenderInput, p2p_messagesUncheckedUpdateWithoutSenderInput>
    create: XOR<p2p_messagesCreateWithoutSenderInput, p2p_messagesUncheckedCreateWithoutSenderInput>
  }

  export type p2p_messagesUpdateWithWhereUniqueWithoutSenderInput = {
    where: p2p_messagesWhereUniqueInput
    data: XOR<p2p_messagesUpdateWithoutSenderInput, p2p_messagesUncheckedUpdateWithoutSenderInput>
  }

  export type p2p_messagesUpdateManyWithWhereWithoutSenderInput = {
    where: p2p_messagesScalarWhereInput
    data: XOR<p2p_messagesUpdateManyMutationInput, p2p_messagesUncheckedUpdateManyWithoutSenderInput>
  }

  export type p2p_messagesScalarWhereInput = {
    AND?: p2p_messagesScalarWhereInput | p2p_messagesScalarWhereInput[]
    OR?: p2p_messagesScalarWhereInput[]
    NOT?: p2p_messagesScalarWhereInput | p2p_messagesScalarWhereInput[]
    id?: StringFilter<"p2p_messages"> | string
    order_id?: StringFilter<"p2p_messages"> | string
    sender_id?: StringFilter<"p2p_messages"> | string
    message?: StringFilter<"p2p_messages"> | string
    attachments?: JsonNullableFilter<"p2p_messages">
    created_at?: DateTimeFilter<"p2p_messages"> | Date | string
  }

  export type p2p_disputesUpsertWithWhereUniqueWithoutRaised_byInput = {
    where: p2p_disputesWhereUniqueInput
    update: XOR<p2p_disputesUpdateWithoutRaised_byInput, p2p_disputesUncheckedUpdateWithoutRaised_byInput>
    create: XOR<p2p_disputesCreateWithoutRaised_byInput, p2p_disputesUncheckedCreateWithoutRaised_byInput>
  }

  export type p2p_disputesUpdateWithWhereUniqueWithoutRaised_byInput = {
    where: p2p_disputesWhereUniqueInput
    data: XOR<p2p_disputesUpdateWithoutRaised_byInput, p2p_disputesUncheckedUpdateWithoutRaised_byInput>
  }

  export type p2p_disputesUpdateManyWithWhereWithoutRaised_byInput = {
    where: p2p_disputesScalarWhereInput
    data: XOR<p2p_disputesUpdateManyMutationInput, p2p_disputesUncheckedUpdateManyWithoutRaised_byInput>
  }

  export type p2p_disputesScalarWhereInput = {
    AND?: p2p_disputesScalarWhereInput | p2p_disputesScalarWhereInput[]
    OR?: p2p_disputesScalarWhereInput[]
    NOT?: p2p_disputesScalarWhereInput | p2p_disputesScalarWhereInput[]
    id?: StringFilter<"p2p_disputes"> | string
    order_id?: StringFilter<"p2p_disputes"> | string
    raised_by_user_id?: StringFilter<"p2p_disputes"> | string
    reason?: StringNullableFilter<"p2p_disputes"> | string | null
    description?: StringNullableFilter<"p2p_disputes"> | string | null
    status?: EnumP2PDisputeStatusFilter<"p2p_disputes"> | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: StringNullableFilter<"p2p_disputes"> | string | null
    resolution_note?: StringNullableFilter<"p2p_disputes"> | string | null
    resolved_at?: DateTimeNullableFilter<"p2p_disputes"> | Date | string | null
    attachments?: JsonNullableFilter<"p2p_disputes">
    created_at?: DateTimeFilter<"p2p_disputes"> | Date | string
    updated_at?: DateTimeFilter<"p2p_disputes"> | Date | string
  }

  export type p2p_ratingsUpsertWithWhereUniqueWithoutFrom_userInput = {
    where: p2p_ratingsWhereUniqueInput
    update: XOR<p2p_ratingsUpdateWithoutFrom_userInput, p2p_ratingsUncheckedUpdateWithoutFrom_userInput>
    create: XOR<p2p_ratingsCreateWithoutFrom_userInput, p2p_ratingsUncheckedCreateWithoutFrom_userInput>
  }

  export type p2p_ratingsUpdateWithWhereUniqueWithoutFrom_userInput = {
    where: p2p_ratingsWhereUniqueInput
    data: XOR<p2p_ratingsUpdateWithoutFrom_userInput, p2p_ratingsUncheckedUpdateWithoutFrom_userInput>
  }

  export type p2p_ratingsUpdateManyWithWhereWithoutFrom_userInput = {
    where: p2p_ratingsScalarWhereInput
    data: XOR<p2p_ratingsUpdateManyMutationInput, p2p_ratingsUncheckedUpdateManyWithoutFrom_userInput>
  }

  export type p2p_ratingsScalarWhereInput = {
    AND?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
    OR?: p2p_ratingsScalarWhereInput[]
    NOT?: p2p_ratingsScalarWhereInput | p2p_ratingsScalarWhereInput[]
    id?: StringFilter<"p2p_ratings"> | string
    order_id?: StringFilter<"p2p_ratings"> | string
    from_user_id?: StringFilter<"p2p_ratings"> | string
    to_user_id?: StringFilter<"p2p_ratings"> | string
    stars?: IntFilter<"p2p_ratings"> | number
    comment?: StringNullableFilter<"p2p_ratings"> | string | null
    created_at?: DateTimeFilter<"p2p_ratings"> | Date | string
  }

  export type p2p_ratingsUpsertWithWhereUniqueWithoutTo_userInput = {
    where: p2p_ratingsWhereUniqueInput
    update: XOR<p2p_ratingsUpdateWithoutTo_userInput, p2p_ratingsUncheckedUpdateWithoutTo_userInput>
    create: XOR<p2p_ratingsCreateWithoutTo_userInput, p2p_ratingsUncheckedCreateWithoutTo_userInput>
  }

  export type p2p_ratingsUpdateWithWhereUniqueWithoutTo_userInput = {
    where: p2p_ratingsWhereUniqueInput
    data: XOR<p2p_ratingsUpdateWithoutTo_userInput, p2p_ratingsUncheckedUpdateWithoutTo_userInput>
  }

  export type p2p_ratingsUpdateManyWithWhereWithoutTo_userInput = {
    where: p2p_ratingsScalarWhereInput
    data: XOR<p2p_ratingsUpdateManyMutationInput, p2p_ratingsUncheckedUpdateManyWithoutTo_userInput>
  }

  export type usersCreateWithoutDepositsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutDepositsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutDepositsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDepositsInput, usersUncheckedCreateWithoutDepositsInput>
  }

  export type usersUpsertWithoutDepositsInput = {
    update: XOR<usersUpdateWithoutDepositsInput, usersUncheckedUpdateWithoutDepositsInput>
    create: XOR<usersCreateWithoutDepositsInput, usersUncheckedCreateWithoutDepositsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDepositsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDepositsInput, usersUncheckedUpdateWithoutDepositsInput>
  }

  export type usersUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutWithdrawalsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutWithdrawalsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWithdrawalsInput, usersUncheckedCreateWithoutWithdrawalsInput>
  }

  export type usersUpsertWithoutWithdrawalsInput = {
    update: XOR<usersUpdateWithoutWithdrawalsInput, usersUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<usersCreateWithoutWithdrawalsInput, usersUncheckedCreateWithoutWithdrawalsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWithdrawalsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWithdrawalsInput, usersUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type usersUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutTradesInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutTradesInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutTradesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTradesInput, usersUncheckedCreateWithoutTradesInput>
  }

  export type usersUpsertWithoutTradesInput = {
    update: XOR<usersUpdateWithoutTradesInput, usersUncheckedUpdateWithoutTradesInput>
    create: XOR<usersCreateWithoutTradesInput, usersUncheckedCreateWithoutTradesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTradesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTradesInput, usersUncheckedUpdateWithoutTradesInput>
  }

  export type usersUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutLeaderboardInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutLeaderboardInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutLeaderboardInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLeaderboardInput, usersUncheckedCreateWithoutLeaderboardInput>
  }

  export type usersUpsertWithoutLeaderboardInput = {
    update: XOR<usersUpdateWithoutLeaderboardInput, usersUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<usersCreateWithoutLeaderboardInput, usersUncheckedCreateWithoutLeaderboardInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLeaderboardInput, usersUncheckedUpdateWithoutLeaderboardInput>
  }

  export type usersUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutSupport_messagesInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutSupport_messagesInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutSupport_messagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSupport_messagesInput, usersUncheckedCreateWithoutSupport_messagesInput>
  }

  export type usersUpsertWithoutSupport_messagesInput = {
    update: XOR<usersUpdateWithoutSupport_messagesInput, usersUncheckedUpdateWithoutSupport_messagesInput>
    create: XOR<usersCreateWithoutSupport_messagesInput, usersUncheckedCreateWithoutSupport_messagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSupport_messagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSupport_messagesInput, usersUncheckedUpdateWithoutSupport_messagesInput>
  }

  export type usersUpdateWithoutSupport_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutSupport_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutChat_messagesInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutChat_messagesInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutChat_messagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
  }

  export type usersUpsertWithoutChat_messagesInput = {
    update: XOR<usersUpdateWithoutChat_messagesInput, usersUncheckedUpdateWithoutChat_messagesInput>
    create: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChat_messagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChat_messagesInput, usersUncheckedUpdateWithoutChat_messagesInput>
  }

  export type usersUpdateWithoutChat_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutChat_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutSettingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
  }

  export type usersUpsertWithoutSettingsInput = {
    update: XOR<usersUpdateWithoutSettingsInput, usersUncheckedUpdateWithoutSettingsInput>
    create: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSettingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSettingsInput, usersUncheckedUpdateWithoutSettingsInput>
  }

  export type usersUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type deposit_sessionsCreateWithoutCrypto_assetsInput = {
    id?: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutDeposit_sessionsInput
  }

  export type deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput = {
    id?: string
    user_id: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type deposit_sessionsCreateOrConnectWithoutCrypto_assetsInput = {
    where: deposit_sessionsWhereUniqueInput
    create: XOR<deposit_sessionsCreateWithoutCrypto_assetsInput, deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput>
  }

  export type deposit_sessionsCreateManyCrypto_assetsInputEnvelope = {
    data: deposit_sessionsCreateManyCrypto_assetsInput | deposit_sessionsCreateManyCrypto_assetsInput[]
  }

  export type deposit_sessionsUpsertWithWhereUniqueWithoutCrypto_assetsInput = {
    where: deposit_sessionsWhereUniqueInput
    update: XOR<deposit_sessionsUpdateWithoutCrypto_assetsInput, deposit_sessionsUncheckedUpdateWithoutCrypto_assetsInput>
    create: XOR<deposit_sessionsCreateWithoutCrypto_assetsInput, deposit_sessionsUncheckedCreateWithoutCrypto_assetsInput>
  }

  export type deposit_sessionsUpdateWithWhereUniqueWithoutCrypto_assetsInput = {
    where: deposit_sessionsWhereUniqueInput
    data: XOR<deposit_sessionsUpdateWithoutCrypto_assetsInput, deposit_sessionsUncheckedUpdateWithoutCrypto_assetsInput>
  }

  export type deposit_sessionsUpdateManyWithWhereWithoutCrypto_assetsInput = {
    where: deposit_sessionsScalarWhereInput
    data: XOR<deposit_sessionsUpdateManyMutationInput, deposit_sessionsUncheckedUpdateManyWithoutCrypto_assetsInput>
  }

  export type usersCreateWithoutDeposit_sessionsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutDeposit_sessionsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutDeposit_sessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDeposit_sessionsInput, usersUncheckedCreateWithoutDeposit_sessionsInput>
  }

  export type crypto_assetsCreateWithoutDeposit_sessionsInput = {
    id?: string
    symbol: string
    network: string
    display_name?: string | null
    contract?: string | null
    decimals?: number
    min_deposit?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type crypto_assetsUncheckedCreateWithoutDeposit_sessionsInput = {
    id?: string
    symbol: string
    network: string
    display_name?: string | null
    contract?: string | null
    decimals?: number
    min_deposit?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type crypto_assetsCreateOrConnectWithoutDeposit_sessionsInput = {
    where: crypto_assetsWhereUniqueInput
    create: XOR<crypto_assetsCreateWithoutDeposit_sessionsInput, crypto_assetsUncheckedCreateWithoutDeposit_sessionsInput>
  }

  export type usersUpsertWithoutDeposit_sessionsInput = {
    update: XOR<usersUpdateWithoutDeposit_sessionsInput, usersUncheckedUpdateWithoutDeposit_sessionsInput>
    create: XOR<usersCreateWithoutDeposit_sessionsInput, usersUncheckedCreateWithoutDeposit_sessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDeposit_sessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDeposit_sessionsInput, usersUncheckedUpdateWithoutDeposit_sessionsInput>
  }

  export type usersUpdateWithoutDeposit_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutDeposit_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type crypto_assetsUpsertWithoutDeposit_sessionsInput = {
    update: XOR<crypto_assetsUpdateWithoutDeposit_sessionsInput, crypto_assetsUncheckedUpdateWithoutDeposit_sessionsInput>
    create: XOR<crypto_assetsCreateWithoutDeposit_sessionsInput, crypto_assetsUncheckedCreateWithoutDeposit_sessionsInput>
    where?: crypto_assetsWhereInput
  }

  export type crypto_assetsUpdateToOneWithWhereWithoutDeposit_sessionsInput = {
    where?: crypto_assetsWhereInput
    data: XOR<crypto_assetsUpdateWithoutDeposit_sessionsInput, crypto_assetsUncheckedUpdateWithoutDeposit_sessionsInput>
  }

  export type crypto_assetsUpdateWithoutDeposit_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    min_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type crypto_assetsUncheckedUpdateWithoutDeposit_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    min_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutWallet_ledgerInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutWallet_ledgerInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutWallet_ledgerInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWallet_ledgerInput, usersUncheckedCreateWithoutWallet_ledgerInput>
  }

  export type usersUpsertWithoutWallet_ledgerInput = {
    update: XOR<usersUpdateWithoutWallet_ledgerInput, usersUncheckedUpdateWithoutWallet_ledgerInput>
    create: XOR<usersCreateWithoutWallet_ledgerInput, usersUncheckedCreateWithoutWallet_ledgerInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWallet_ledgerInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWallet_ledgerInput, usersUncheckedUpdateWithoutWallet_ledgerInput>
  }

  export type usersUpdateWithoutWallet_ledgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutWallet_ledgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersCreateWithoutP2p_offersInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutP2p_offersInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutP2p_offersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_offersInput, usersUncheckedCreateWithoutP2p_offersInput>
  }

  export type p2p_offer_payment_methodsCreateWithoutOfferInput = {
    id?: string
    payment_method: user_payment_methodsCreateNestedOneWithoutOffersInput
  }

  export type p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput = {
    id?: string
    payment_method_id: string
  }

  export type p2p_offer_payment_methodsCreateOrConnectWithoutOfferInput = {
    where: p2p_offer_payment_methodsWhereUniqueInput
    create: XOR<p2p_offer_payment_methodsCreateWithoutOfferInput, p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput>
  }

  export type p2p_offer_payment_methodsCreateManyOfferInputEnvelope = {
    data: p2p_offer_payment_methodsCreateManyOfferInput | p2p_offer_payment_methodsCreateManyOfferInput[]
  }

  export type p2p_ordersCreateWithoutOfferInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    maker: usersCreateNestedOneWithoutP2p_maker_ordersInput
    taker: usersCreateNestedOneWithoutP2p_taker_ordersInput
    messages?: p2p_messagesCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateWithoutOfferInput = {
    id?: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    messages?: p2p_messagesUncheckedCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesUncheckedCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersCreateOrConnectWithoutOfferInput = {
    where: p2p_ordersWhereUniqueInput
    create: XOR<p2p_ordersCreateWithoutOfferInput, p2p_ordersUncheckedCreateWithoutOfferInput>
  }

  export type p2p_ordersCreateManyOfferInputEnvelope = {
    data: p2p_ordersCreateManyOfferInput | p2p_ordersCreateManyOfferInput[]
  }

  export type usersUpsertWithoutP2p_offersInput = {
    update: XOR<usersUpdateWithoutP2p_offersInput, usersUncheckedUpdateWithoutP2p_offersInput>
    create: XOR<usersCreateWithoutP2p_offersInput, usersUncheckedCreateWithoutP2p_offersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_offersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_offersInput, usersUncheckedUpdateWithoutP2p_offersInput>
  }

  export type usersUpdateWithoutP2p_offersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_offersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutOfferInput = {
    where: p2p_offer_payment_methodsWhereUniqueInput
    update: XOR<p2p_offer_payment_methodsUpdateWithoutOfferInput, p2p_offer_payment_methodsUncheckedUpdateWithoutOfferInput>
    create: XOR<p2p_offer_payment_methodsCreateWithoutOfferInput, p2p_offer_payment_methodsUncheckedCreateWithoutOfferInput>
  }

  export type p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutOfferInput = {
    where: p2p_offer_payment_methodsWhereUniqueInput
    data: XOR<p2p_offer_payment_methodsUpdateWithoutOfferInput, p2p_offer_payment_methodsUncheckedUpdateWithoutOfferInput>
  }

  export type p2p_offer_payment_methodsUpdateManyWithWhereWithoutOfferInput = {
    where: p2p_offer_payment_methodsScalarWhereInput
    data: XOR<p2p_offer_payment_methodsUpdateManyMutationInput, p2p_offer_payment_methodsUncheckedUpdateManyWithoutOfferInput>
  }

  export type p2p_offer_payment_methodsScalarWhereInput = {
    AND?: p2p_offer_payment_methodsScalarWhereInput | p2p_offer_payment_methodsScalarWhereInput[]
    OR?: p2p_offer_payment_methodsScalarWhereInput[]
    NOT?: p2p_offer_payment_methodsScalarWhereInput | p2p_offer_payment_methodsScalarWhereInput[]
    id?: StringFilter<"p2p_offer_payment_methods"> | string
    offer_id?: StringFilter<"p2p_offer_payment_methods"> | string
    payment_method_id?: StringFilter<"p2p_offer_payment_methods"> | string
  }

  export type p2p_ordersUpsertWithWhereUniqueWithoutOfferInput = {
    where: p2p_ordersWhereUniqueInput
    update: XOR<p2p_ordersUpdateWithoutOfferInput, p2p_ordersUncheckedUpdateWithoutOfferInput>
    create: XOR<p2p_ordersCreateWithoutOfferInput, p2p_ordersUncheckedCreateWithoutOfferInput>
  }

  export type p2p_ordersUpdateWithWhereUniqueWithoutOfferInput = {
    where: p2p_ordersWhereUniqueInput
    data: XOR<p2p_ordersUpdateWithoutOfferInput, p2p_ordersUncheckedUpdateWithoutOfferInput>
  }

  export type p2p_ordersUpdateManyWithWhereWithoutOfferInput = {
    where: p2p_ordersScalarWhereInput
    data: XOR<p2p_ordersUpdateManyMutationInput, p2p_ordersUncheckedUpdateManyWithoutOfferInput>
  }

  export type usersCreateWithoutUser_payment_methodsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutUser_payment_methodsInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutUser_payment_methodsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
  }

  export type p2p_offer_payment_methodsCreateWithoutPayment_methodInput = {
    id?: string
    offer: p2p_offersCreateNestedOneWithoutPayment_methodsInput
  }

  export type p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput = {
    id?: string
    offer_id: string
  }

  export type p2p_offer_payment_methodsCreateOrConnectWithoutPayment_methodInput = {
    where: p2p_offer_payment_methodsWhereUniqueInput
    create: XOR<p2p_offer_payment_methodsCreateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput>
  }

  export type p2p_offer_payment_methodsCreateManyPayment_methodInputEnvelope = {
    data: p2p_offer_payment_methodsCreateManyPayment_methodInput | p2p_offer_payment_methodsCreateManyPayment_methodInput[]
  }

  export type usersUpsertWithoutUser_payment_methodsInput = {
    update: XOR<usersUpdateWithoutUser_payment_methodsInput, usersUncheckedUpdateWithoutUser_payment_methodsInput>
    create: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_payment_methodsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_payment_methodsInput, usersUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type usersUpdateWithoutUser_payment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_payment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type p2p_offer_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: p2p_offer_payment_methodsWhereUniqueInput
    update: XOR<p2p_offer_payment_methodsUpdateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<p2p_offer_payment_methodsCreateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedCreateWithoutPayment_methodInput>
  }

  export type p2p_offer_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: p2p_offer_payment_methodsWhereUniqueInput
    data: XOR<p2p_offer_payment_methodsUpdateWithoutPayment_methodInput, p2p_offer_payment_methodsUncheckedUpdateWithoutPayment_methodInput>
  }

  export type p2p_offer_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput = {
    where: p2p_offer_payment_methodsScalarWhereInput
    data: XOR<p2p_offer_payment_methodsUpdateManyMutationInput, p2p_offer_payment_methodsUncheckedUpdateManyWithoutPayment_methodInput>
  }

  export type p2p_offersCreateWithoutPayment_methodsInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutP2p_offersInput
    orders?: p2p_ordersCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersUncheckedCreateWithoutPayment_methodsInput = {
    id?: string
    user_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    orders?: p2p_ordersUncheckedCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersCreateOrConnectWithoutPayment_methodsInput = {
    where: p2p_offersWhereUniqueInput
    create: XOR<p2p_offersCreateWithoutPayment_methodsInput, p2p_offersUncheckedCreateWithoutPayment_methodsInput>
  }

  export type user_payment_methodsCreateWithoutOffersInput = {
    id?: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsUncheckedCreateWithoutOffersInput = {
    id?: string
    user_id: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_payment_methodsCreateOrConnectWithoutOffersInput = {
    where: user_payment_methodsWhereUniqueInput
    create: XOR<user_payment_methodsCreateWithoutOffersInput, user_payment_methodsUncheckedCreateWithoutOffersInput>
  }

  export type p2p_offersUpsertWithoutPayment_methodsInput = {
    update: XOR<p2p_offersUpdateWithoutPayment_methodsInput, p2p_offersUncheckedUpdateWithoutPayment_methodsInput>
    create: XOR<p2p_offersCreateWithoutPayment_methodsInput, p2p_offersUncheckedCreateWithoutPayment_methodsInput>
    where?: p2p_offersWhereInput
  }

  export type p2p_offersUpdateToOneWithWhereWithoutPayment_methodsInput = {
    where?: p2p_offersWhereInput
    data: XOR<p2p_offersUpdateWithoutPayment_methodsInput, p2p_offersUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type p2p_offersUpdateWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutP2p_offersNestedInput
    orders?: p2p_ordersUpdateManyWithoutOfferNestedInput
  }

  export type p2p_offersUncheckedUpdateWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: p2p_ordersUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type user_payment_methodsUpsertWithoutOffersInput = {
    update: XOR<user_payment_methodsUpdateWithoutOffersInput, user_payment_methodsUncheckedUpdateWithoutOffersInput>
    create: XOR<user_payment_methodsCreateWithoutOffersInput, user_payment_methodsUncheckedCreateWithoutOffersInput>
    where?: user_payment_methodsWhereInput
  }

  export type user_payment_methodsUpdateToOneWithWhereWithoutOffersInput = {
    where?: user_payment_methodsWhereInput
    data: XOR<user_payment_methodsUpdateWithoutOffersInput, user_payment_methodsUncheckedUpdateWithoutOffersInput>
  }

  export type user_payment_methodsUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offersCreateWithoutOrdersInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutP2p_offersInput
    payment_methods?: p2p_offer_payment_methodsCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersUncheckedCreateWithoutOrdersInput = {
    id?: string
    user_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
    payment_methods?: p2p_offer_payment_methodsUncheckedCreateNestedManyWithoutOfferInput
  }

  export type p2p_offersCreateOrConnectWithoutOrdersInput = {
    where: p2p_offersWhereUniqueInput
    create: XOR<p2p_offersCreateWithoutOrdersInput, p2p_offersUncheckedCreateWithoutOrdersInput>
  }

  export type usersCreateWithoutP2p_maker_ordersInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutP2p_maker_ordersInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutP2p_maker_ordersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_maker_ordersInput, usersUncheckedCreateWithoutP2p_maker_ordersInput>
  }

  export type usersCreateWithoutP2p_taker_ordersInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutP2p_taker_ordersInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutP2p_taker_ordersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_taker_ordersInput, usersUncheckedCreateWithoutP2p_taker_ordersInput>
  }

  export type p2p_messagesCreateWithoutOrderInput = {
    id?: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    sender: usersCreateNestedOneWithoutP2p_messages_sentInput
  }

  export type p2p_messagesUncheckedCreateWithoutOrderInput = {
    id?: string
    sender_id: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_messagesCreateOrConnectWithoutOrderInput = {
    where: p2p_messagesWhereUniqueInput
    create: XOR<p2p_messagesCreateWithoutOrderInput, p2p_messagesUncheckedCreateWithoutOrderInput>
  }

  export type p2p_messagesCreateManyOrderInputEnvelope = {
    data: p2p_messagesCreateManyOrderInput | p2p_messagesCreateManyOrderInput[]
  }

  export type p2p_disputesCreateWithoutOrderInput = {
    id?: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    raised_by: usersCreateNestedOneWithoutP2p_disputes_raisedInput
  }

  export type p2p_disputesUncheckedCreateWithoutOrderInput = {
    id?: string
    raised_by_user_id: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_disputesCreateOrConnectWithoutOrderInput = {
    where: p2p_disputesWhereUniqueInput
    create: XOR<p2p_disputesCreateWithoutOrderInput, p2p_disputesUncheckedCreateWithoutOrderInput>
  }

  export type p2p_disputesCreateManyOrderInputEnvelope = {
    data: p2p_disputesCreateManyOrderInput | p2p_disputesCreateManyOrderInput[]
  }

  export type p2p_ratingsCreateWithoutOrderInput = {
    id?: string
    stars: number
    comment?: string | null
    created_at?: Date | string
    from_user: usersCreateNestedOneWithoutP2p_ratings_fromInput
    to_user: usersCreateNestedOneWithoutP2p_ratings_toInput
  }

  export type p2p_ratingsUncheckedCreateWithoutOrderInput = {
    id?: string
    from_user_id: string
    to_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_ratingsCreateOrConnectWithoutOrderInput = {
    where: p2p_ratingsWhereUniqueInput
    create: XOR<p2p_ratingsCreateWithoutOrderInput, p2p_ratingsUncheckedCreateWithoutOrderInput>
  }

  export type p2p_ratingsCreateManyOrderInputEnvelope = {
    data: p2p_ratingsCreateManyOrderInput | p2p_ratingsCreateManyOrderInput[]
  }

  export type p2p_offersUpsertWithoutOrdersInput = {
    update: XOR<p2p_offersUpdateWithoutOrdersInput, p2p_offersUncheckedUpdateWithoutOrdersInput>
    create: XOR<p2p_offersCreateWithoutOrdersInput, p2p_offersUncheckedCreateWithoutOrdersInput>
    where?: p2p_offersWhereInput
  }

  export type p2p_offersUpdateToOneWithWhereWithoutOrdersInput = {
    where?: p2p_offersWhereInput
    data: XOR<p2p_offersUpdateWithoutOrdersInput, p2p_offersUncheckedUpdateWithoutOrdersInput>
  }

  export type p2p_offersUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutP2p_offersNestedInput
    payment_methods?: p2p_offer_payment_methodsUpdateManyWithoutOfferNestedInput
  }

  export type p2p_offersUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_methods?: p2p_offer_payment_methodsUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type usersUpsertWithoutP2p_maker_ordersInput = {
    update: XOR<usersUpdateWithoutP2p_maker_ordersInput, usersUncheckedUpdateWithoutP2p_maker_ordersInput>
    create: XOR<usersCreateWithoutP2p_maker_ordersInput, usersUncheckedCreateWithoutP2p_maker_ordersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_maker_ordersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_maker_ordersInput, usersUncheckedUpdateWithoutP2p_maker_ordersInput>
  }

  export type usersUpdateWithoutP2p_maker_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_maker_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersUpsertWithoutP2p_taker_ordersInput = {
    update: XOR<usersUpdateWithoutP2p_taker_ordersInput, usersUncheckedUpdateWithoutP2p_taker_ordersInput>
    create: XOR<usersCreateWithoutP2p_taker_ordersInput, usersUncheckedCreateWithoutP2p_taker_ordersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_taker_ordersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_taker_ordersInput, usersUncheckedUpdateWithoutP2p_taker_ordersInput>
  }

  export type usersUpdateWithoutP2p_taker_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_taker_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type p2p_messagesUpsertWithWhereUniqueWithoutOrderInput = {
    where: p2p_messagesWhereUniqueInput
    update: XOR<p2p_messagesUpdateWithoutOrderInput, p2p_messagesUncheckedUpdateWithoutOrderInput>
    create: XOR<p2p_messagesCreateWithoutOrderInput, p2p_messagesUncheckedCreateWithoutOrderInput>
  }

  export type p2p_messagesUpdateWithWhereUniqueWithoutOrderInput = {
    where: p2p_messagesWhereUniqueInput
    data: XOR<p2p_messagesUpdateWithoutOrderInput, p2p_messagesUncheckedUpdateWithoutOrderInput>
  }

  export type p2p_messagesUpdateManyWithWhereWithoutOrderInput = {
    where: p2p_messagesScalarWhereInput
    data: XOR<p2p_messagesUpdateManyMutationInput, p2p_messagesUncheckedUpdateManyWithoutOrderInput>
  }

  export type p2p_disputesUpsertWithWhereUniqueWithoutOrderInput = {
    where: p2p_disputesWhereUniqueInput
    update: XOR<p2p_disputesUpdateWithoutOrderInput, p2p_disputesUncheckedUpdateWithoutOrderInput>
    create: XOR<p2p_disputesCreateWithoutOrderInput, p2p_disputesUncheckedCreateWithoutOrderInput>
  }

  export type p2p_disputesUpdateWithWhereUniqueWithoutOrderInput = {
    where: p2p_disputesWhereUniqueInput
    data: XOR<p2p_disputesUpdateWithoutOrderInput, p2p_disputesUncheckedUpdateWithoutOrderInput>
  }

  export type p2p_disputesUpdateManyWithWhereWithoutOrderInput = {
    where: p2p_disputesScalarWhereInput
    data: XOR<p2p_disputesUpdateManyMutationInput, p2p_disputesUncheckedUpdateManyWithoutOrderInput>
  }

  export type p2p_ratingsUpsertWithWhereUniqueWithoutOrderInput = {
    where: p2p_ratingsWhereUniqueInput
    update: XOR<p2p_ratingsUpdateWithoutOrderInput, p2p_ratingsUncheckedUpdateWithoutOrderInput>
    create: XOR<p2p_ratingsCreateWithoutOrderInput, p2p_ratingsUncheckedCreateWithoutOrderInput>
  }

  export type p2p_ratingsUpdateWithWhereUniqueWithoutOrderInput = {
    where: p2p_ratingsWhereUniqueInput
    data: XOR<p2p_ratingsUpdateWithoutOrderInput, p2p_ratingsUncheckedUpdateWithoutOrderInput>
  }

  export type p2p_ratingsUpdateManyWithWhereWithoutOrderInput = {
    where: p2p_ratingsScalarWhereInput
    data: XOR<p2p_ratingsUpdateManyMutationInput, p2p_ratingsUncheckedUpdateManyWithoutOrderInput>
  }

  export type p2p_ordersCreateWithoutMessagesInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    offer: p2p_offersCreateNestedOneWithoutOrdersInput
    maker: usersCreateNestedOneWithoutP2p_maker_ordersInput
    taker: usersCreateNestedOneWithoutP2p_taker_ordersInput
    disputes?: p2p_disputesCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateWithoutMessagesInput = {
    id?: string
    offer_id: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    disputes?: p2p_disputesUncheckedCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersCreateOrConnectWithoutMessagesInput = {
    where: p2p_ordersWhereUniqueInput
    create: XOR<p2p_ordersCreateWithoutMessagesInput, p2p_ordersUncheckedCreateWithoutMessagesInput>
  }

  export type usersCreateWithoutP2p_messages_sentInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutP2p_messages_sentInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutP2p_messages_sentInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_messages_sentInput, usersUncheckedCreateWithoutP2p_messages_sentInput>
  }

  export type p2p_ordersUpsertWithoutMessagesInput = {
    update: XOR<p2p_ordersUpdateWithoutMessagesInput, p2p_ordersUncheckedUpdateWithoutMessagesInput>
    create: XOR<p2p_ordersCreateWithoutMessagesInput, p2p_ordersUncheckedCreateWithoutMessagesInput>
    where?: p2p_ordersWhereInput
  }

  export type p2p_ordersUpdateToOneWithWhereWithoutMessagesInput = {
    where?: p2p_ordersWhereInput
    data: XOR<p2p_ordersUpdateWithoutMessagesInput, p2p_ordersUncheckedUpdateWithoutMessagesInput>
  }

  export type p2p_ordersUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: p2p_offersUpdateOneRequiredWithoutOrdersNestedInput
    maker?: usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput
    taker?: usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput
    disputes?: p2p_disputesUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    disputes?: p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersUpsertWithoutP2p_messages_sentInput = {
    update: XOR<usersUpdateWithoutP2p_messages_sentInput, usersUncheckedUpdateWithoutP2p_messages_sentInput>
    create: XOR<usersCreateWithoutP2p_messages_sentInput, usersUncheckedCreateWithoutP2p_messages_sentInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_messages_sentInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_messages_sentInput, usersUncheckedUpdateWithoutP2p_messages_sentInput>
  }

  export type usersUpdateWithoutP2p_messages_sentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_messages_sentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type p2p_ordersCreateWithoutDisputesInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    offer: p2p_offersCreateNestedOneWithoutOrdersInput
    maker: usersCreateNestedOneWithoutP2p_maker_ordersInput
    taker: usersCreateNestedOneWithoutP2p_taker_ordersInput
    messages?: p2p_messagesCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateWithoutDisputesInput = {
    id?: string
    offer_id: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    messages?: p2p_messagesUncheckedCreateNestedManyWithoutOrderInput
    ratings?: p2p_ratingsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersCreateOrConnectWithoutDisputesInput = {
    where: p2p_ordersWhereUniqueInput
    create: XOR<p2p_ordersCreateWithoutDisputesInput, p2p_ordersUncheckedCreateWithoutDisputesInput>
  }

  export type usersCreateWithoutP2p_disputes_raisedInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutP2p_disputes_raisedInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutP2p_disputes_raisedInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_disputes_raisedInput, usersUncheckedCreateWithoutP2p_disputes_raisedInput>
  }

  export type p2p_ordersUpsertWithoutDisputesInput = {
    update: XOR<p2p_ordersUpdateWithoutDisputesInput, p2p_ordersUncheckedUpdateWithoutDisputesInput>
    create: XOR<p2p_ordersCreateWithoutDisputesInput, p2p_ordersUncheckedCreateWithoutDisputesInput>
    where?: p2p_ordersWhereInput
  }

  export type p2p_ordersUpdateToOneWithWhereWithoutDisputesInput = {
    where?: p2p_ordersWhereInput
    data: XOR<p2p_ordersUpdateWithoutDisputesInput, p2p_ordersUncheckedUpdateWithoutDisputesInput>
  }

  export type p2p_ordersUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: p2p_offersUpdateOneRequiredWithoutOrdersNestedInput
    maker?: usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput
    taker?: usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput
    messages?: p2p_messagesUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersUpsertWithoutP2p_disputes_raisedInput = {
    update: XOR<usersUpdateWithoutP2p_disputes_raisedInput, usersUncheckedUpdateWithoutP2p_disputes_raisedInput>
    create: XOR<usersCreateWithoutP2p_disputes_raisedInput, usersUncheckedCreateWithoutP2p_disputes_raisedInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_disputes_raisedInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_disputes_raisedInput, usersUncheckedUpdateWithoutP2p_disputes_raisedInput>
  }

  export type usersUpdateWithoutP2p_disputes_raisedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_disputes_raisedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type p2p_ordersCreateWithoutRatingsInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    offer: p2p_offersCreateNestedOneWithoutOrdersInput
    maker: usersCreateNestedOneWithoutP2p_maker_ordersInput
    taker: usersCreateNestedOneWithoutP2p_taker_ordersInput
    messages?: p2p_messagesCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersUncheckedCreateWithoutRatingsInput = {
    id?: string
    offer_id: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    messages?: p2p_messagesUncheckedCreateNestedManyWithoutOrderInput
    disputes?: p2p_disputesUncheckedCreateNestedManyWithoutOrderInput
  }

  export type p2p_ordersCreateOrConnectWithoutRatingsInput = {
    where: p2p_ordersWhereUniqueInput
    create: XOR<p2p_ordersCreateWithoutRatingsInput, p2p_ordersUncheckedCreateWithoutRatingsInput>
  }

  export type usersCreateWithoutP2p_ratings_fromInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_to?: p2p_ratingsCreateNestedManyWithoutTo_userInput
  }

  export type usersUncheckedCreateWithoutP2p_ratings_fromInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_to?: p2p_ratingsUncheckedCreateNestedManyWithoutTo_userInput
  }

  export type usersCreateOrConnectWithoutP2p_ratings_fromInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_ratings_fromInput, usersUncheckedCreateWithoutP2p_ratings_fromInput>
  }

  export type usersCreateWithoutP2p_ratings_toInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    deposits?: depositsCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardCreateNestedManyWithoutUsersInput
    settings?: settingsCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesCreateNestedManyWithoutUsersInput
    trades?: tradesCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsCreateNestedManyWithoutFrom_userInput
  }

  export type usersUncheckedCreateWithoutP2p_ratings_toInput = {
    id?: string
    name?: string | null
    first_name?: string | null
    last_name?: string | null
    email: string
    password_hash?: string | null
    phone?: string | null
    country?: string | null
    date_of_birth?: string | null
    address?: string | null
    city?: string | null
    postal_code?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    is_verified?: boolean
    is_admin?: boolean
    is_suspended?: boolean
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    demo_balance?: Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    deposits?: depositsUncheckedCreateNestedManyWithoutUsersInput
    leaderboard?: leaderboardUncheckedCreateNestedManyWithoutUsersInput
    settings?: settingsUncheckedCreateNestedManyWithoutUsersInput
    support_messages?: support_messagesUncheckedCreateNestedManyWithoutUsersInput
    trades?: tradesUncheckedCreateNestedManyWithoutUsersInput
    withdrawals?: withdrawalsUncheckedCreateNestedManyWithoutUsersInput
    deposit_sessions?: deposit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    wallet_ledger?: wallet_ledgerUncheckedCreateNestedManyWithoutUsersInput
    p2p_offers?: p2p_offersUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    p2p_maker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutMakerInput
    p2p_taker_orders?: p2p_ordersUncheckedCreateNestedManyWithoutTakerInput
    p2p_messages_sent?: p2p_messagesUncheckedCreateNestedManyWithoutSenderInput
    p2p_disputes_raised?: p2p_disputesUncheckedCreateNestedManyWithoutRaised_byInput
    p2p_ratings_from?: p2p_ratingsUncheckedCreateNestedManyWithoutFrom_userInput
  }

  export type usersCreateOrConnectWithoutP2p_ratings_toInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutP2p_ratings_toInput, usersUncheckedCreateWithoutP2p_ratings_toInput>
  }

  export type p2p_ordersUpsertWithoutRatingsInput = {
    update: XOR<p2p_ordersUpdateWithoutRatingsInput, p2p_ordersUncheckedUpdateWithoutRatingsInput>
    create: XOR<p2p_ordersCreateWithoutRatingsInput, p2p_ordersUncheckedCreateWithoutRatingsInput>
    where?: p2p_ordersWhereInput
  }

  export type p2p_ordersUpdateToOneWithWhereWithoutRatingsInput = {
    where?: p2p_ordersWhereInput
    data: XOR<p2p_ordersUpdateWithoutRatingsInput, p2p_ordersUncheckedUpdateWithoutRatingsInput>
  }

  export type p2p_ordersUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: p2p_offersUpdateOneRequiredWithoutOrdersNestedInput
    maker?: usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput
    taker?: usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput
    messages?: p2p_messagesUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersUpsertWithoutP2p_ratings_fromInput = {
    update: XOR<usersUpdateWithoutP2p_ratings_fromInput, usersUncheckedUpdateWithoutP2p_ratings_fromInput>
    create: XOR<usersCreateWithoutP2p_ratings_fromInput, usersUncheckedCreateWithoutP2p_ratings_fromInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_ratings_fromInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_ratings_fromInput, usersUncheckedUpdateWithoutP2p_ratings_fromInput>
  }

  export type usersUpdateWithoutP2p_ratings_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_to?: p2p_ratingsUpdateManyWithoutTo_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_ratings_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_to?: p2p_ratingsUncheckedUpdateManyWithoutTo_userNestedInput
  }

  export type usersUpsertWithoutP2p_ratings_toInput = {
    update: XOR<usersUpdateWithoutP2p_ratings_toInput, usersUncheckedUpdateWithoutP2p_ratings_toInput>
    create: XOR<usersCreateWithoutP2p_ratings_toInput, usersUncheckedCreateWithoutP2p_ratings_toInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutP2p_ratings_toInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutP2p_ratings_toInput, usersUncheckedUpdateWithoutP2p_ratings_toInput>
  }

  export type usersUpdateWithoutP2p_ratings_toInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    deposits?: depositsUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUpdateManyWithoutUsersNestedInput
    settings?: settingsUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUpdateManyWithoutUsersNestedInput
    trades?: tradesUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUpdateManyWithoutFrom_userNestedInput
  }

  export type usersUncheckedUpdateWithoutP2p_ratings_toInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    is_suspended?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demo_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    deposits?: depositsUncheckedUpdateManyWithoutUsersNestedInput
    leaderboard?: leaderboardUncheckedUpdateManyWithoutUsersNestedInput
    settings?: settingsUncheckedUpdateManyWithoutUsersNestedInput
    support_messages?: support_messagesUncheckedUpdateManyWithoutUsersNestedInput
    trades?: tradesUncheckedUpdateManyWithoutUsersNestedInput
    withdrawals?: withdrawalsUncheckedUpdateManyWithoutUsersNestedInput
    deposit_sessions?: deposit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    wallet_ledger?: wallet_ledgerUncheckedUpdateManyWithoutUsersNestedInput
    p2p_offers?: p2p_offersUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    p2p_maker_orders?: p2p_ordersUncheckedUpdateManyWithoutMakerNestedInput
    p2p_taker_orders?: p2p_ordersUncheckedUpdateManyWithoutTakerNestedInput
    p2p_messages_sent?: p2p_messagesUncheckedUpdateManyWithoutSenderNestedInput
    p2p_disputes_raised?: p2p_disputesUncheckedUpdateManyWithoutRaised_byNestedInput
    p2p_ratings_from?: p2p_ratingsUncheckedUpdateManyWithoutFrom_userNestedInput
  }

  export type chat_messagesCreateManyUsersInput = {
    id?: string
    sender?: string | null
    message?: string | null
    time?: Date | string
  }

  export type depositsCreateManyUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    status?: string | null
    created_at?: Date | string
  }

  export type leaderboardCreateManyUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    updated_at?: Date | string
  }

  export type settingsCreateManyUsersInput = {
    id?: string
    notifications?: boolean | null
    private?: boolean | null
  }

  export type support_messagesCreateManyUsersInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type tradesCreateManyUsersInput = {
    id?: string
    symbol?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    direction?: string | null
    open_time?: Date | string | null
    close_time?: Date | string | null
    result?: string | null
    status?: string | null
    entry_price?: Decimal | DecimalJsLike | number | string | null
    payout?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    account_type?: string | null
  }

  export type withdrawalsCreateManyUsersInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string | null
    method?: string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    created_at?: Date | string
  }

  export type deposit_sessionsCreateManyUsersInput = {
    id?: string
    crypto_asset_id: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type wallet_ledgerCreateManyUsersInput = {
    id?: string
    type: $Enums.LedgerType
    asset: string
    amount: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_offersCreateManyUsersInput = {
    id?: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    crypto_asset_id?: string | null
    fiat_currency: string
    price_type: string
    fixed_price?: Decimal | DecimalJsLike | number | string | null
    margin_percent?: Decimal | DecimalJsLike | number | string | null
    min_amount_asset: Decimal | DecimalJsLike | number | string
    max_amount_asset: Decimal | DecimalJsLike | number | string
    min_limit_fiat: Decimal | DecimalJsLike | number | string
    max_limit_fiat: Decimal | DecimalJsLike | number | string
    terms?: string | null
    auto_reply?: string | null
    status?: $Enums.P2POfferStatus
    total_trades?: number
    completion_rate?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_payment_methodsCreateManyUsersInput = {
    id?: string
    type: $Enums.PaymentMethodType
    label?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_ordersCreateManyMakerInput = {
    id?: string
    offer_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_ordersCreateManyTakerInput = {
    id?: string
    offer_id: string
    maker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_messagesCreateManySenderInput = {
    id?: string
    order_id: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_disputesCreateManyRaised_byInput = {
    id?: string
    order_id: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_ratingsCreateManyFrom_userInput = {
    id?: string
    order_id: string
    to_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_ratingsCreateManyTo_userInput = {
    id?: string
    order_id: string
    from_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type chat_messagesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaderboardUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaderboardUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaderboardUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type settingsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type settingsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notifications?: NullableBoolFieldUpdateOperationsInput | boolean | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type support_messagesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_messagesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_messagesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tradesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tradesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tradesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    entry_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type withdrawalsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    account_info?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    crypto_assets?: crypto_assetsUpdateOneRequiredWithoutDeposit_sessionsNestedInput
  }

  export type deposit_sessionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_ledgerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_ledgerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_ledgerUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    asset?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_methods?: p2p_offer_payment_methodsUpdateManyWithoutOfferNestedInput
    orders?: p2p_ordersUpdateManyWithoutOfferNestedInput
  }

  export type p2p_offersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_methods?: p2p_offer_payment_methodsUncheckedUpdateManyWithoutOfferNestedInput
    orders?: p2p_ordersUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type p2p_offersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    crypto_asset_id?: NullableStringFieldUpdateOperationsInput | string | null
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price_type?: StringFieldUpdateOperationsInput | string
    fixed_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    margin_percent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_limit_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    auto_reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2POfferStatusFieldUpdateOperationsInput | $Enums.P2POfferStatus
    total_trades?: IntFieldUpdateOperationsInput | number
    completion_rate?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: p2p_offer_payment_methodsUpdateManyWithoutPayment_methodNestedInput
  }

  export type user_payment_methodsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: p2p_offer_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type user_payment_methodsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ordersUpdateWithoutMakerInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: p2p_offersUpdateOneRequiredWithoutOrdersNestedInput
    taker?: usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput
    messages?: p2p_messagesUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateWithoutMakerInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateManyWithoutMakerInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ordersUpdateWithoutTakerInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: p2p_offersUpdateOneRequiredWithoutOrdersNestedInput
    maker?: usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput
    messages?: p2p_messagesUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateWithoutTakerInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateManyWithoutTakerInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_messagesUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type p2p_messagesUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_messagesUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesUpdateWithoutRaised_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type p2p_disputesUncheckedUpdateWithoutRaised_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesUncheckedUpdateManyWithoutRaised_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUpdateWithoutFrom_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutRatingsNestedInput
    to_user?: usersUpdateOneRequiredWithoutP2p_ratings_toNestedInput
  }

  export type p2p_ratingsUncheckedUpdateWithoutFrom_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUncheckedUpdateManyWithoutFrom_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUpdateWithoutTo_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: p2p_ordersUpdateOneRequiredWithoutRatingsNestedInput
    from_user?: usersUpdateOneRequiredWithoutP2p_ratings_fromNestedInput
  }

  export type p2p_ratingsUncheckedUpdateWithoutTo_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUncheckedUpdateManyWithoutTo_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsCreateManyCrypto_assetsInput = {
    id?: string
    user_id: string
    address: string
    derivation_path?: string | null
    memo_tag?: string | null
    amount_expected?: Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: Decimal | DecimalJsLike | number | string | null
    rate_source?: string | null
    status?: $Enums.DepositSessionStatus
    tx_hash?: string | null
    detected_amount?: Decimal | DecimalJsLike | number | string | null
    confirmations?: number | null
    min_confirmations?: number
    is_late?: boolean
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type deposit_sessionsUpdateWithoutCrypto_assetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutDeposit_sessionsNestedInput
  }

  export type deposit_sessionsUncheckedUpdateWithoutCrypto_assetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deposit_sessionsUncheckedUpdateManyWithoutCrypto_assetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    derivation_path?: NullableStringFieldUpdateOperationsInput | string | null
    memo_tag?: NullableStringFieldUpdateOperationsInput | string | null
    amount_expected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_locked_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositSessionStatusFieldUpdateOperationsInput | $Enums.DepositSessionStatus
    tx_hash?: NullableStringFieldUpdateOperationsInput | string | null
    detected_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    confirmations?: NullableIntFieldUpdateOperationsInput | number | null
    min_confirmations?: IntFieldUpdateOperationsInput | number
    is_late?: BoolFieldUpdateOperationsInput | boolean
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offer_payment_methodsCreateManyOfferInput = {
    id?: string
    payment_method_id: string
  }

  export type p2p_ordersCreateManyOfferInput = {
    id?: string
    maker_id: string
    taker_id: string
    side: $Enums.P2POrderSide
    asset_symbol: string
    fiat_currency: string
    price: Decimal | DecimalJsLike | number | string
    amount_asset: Decimal | DecimalJsLike | number | string
    amount_fiat: Decimal | DecimalJsLike | number | string
    status?: $Enums.P2PTradeStatus
    escrow_held?: boolean
    escrow_ledger_id?: string | null
    reference_code?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    released_at?: Date | string | null
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_offer_payment_methodsUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_method?: user_payment_methodsUpdateOneRequiredWithoutOffersNestedInput
  }

  export type p2p_offer_payment_methodsUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_offer_payment_methodsUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_ordersUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    maker?: usersUpdateOneRequiredWithoutP2p_maker_ordersNestedInput
    taker?: usersUpdateOneRequiredWithoutP2p_taker_ordersNestedInput
    messages?: p2p_messagesUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: p2p_messagesUncheckedUpdateManyWithoutOrderNestedInput
    disputes?: p2p_disputesUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: p2p_ratingsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type p2p_ordersUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    maker_id?: StringFieldUpdateOperationsInput | string
    taker_id?: StringFieldUpdateOperationsInput | string
    side?: EnumP2POrderSideFieldUpdateOperationsInput | $Enums.P2POrderSide
    asset_symbol?: StringFieldUpdateOperationsInput | string
    fiat_currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_asset?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_fiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumP2PTradeStatusFieldUpdateOperationsInput | $Enums.P2PTradeStatus
    escrow_held?: BoolFieldUpdateOperationsInput | boolean
    escrow_ledger_id?: NullableStringFieldUpdateOperationsInput | string | null
    reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_offer_payment_methodsCreateManyPayment_methodInput = {
    id?: string
    offer_id: string
  }

  export type p2p_offer_payment_methodsUpdateWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer?: p2p_offersUpdateOneRequiredWithoutPayment_methodsNestedInput
  }

  export type p2p_offer_payment_methodsUncheckedUpdateWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_offer_payment_methodsUncheckedUpdateManyWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    offer_id?: StringFieldUpdateOperationsInput | string
  }

  export type p2p_messagesCreateManyOrderInput = {
    id?: string
    sender_id: string
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type p2p_disputesCreateManyOrderInput = {
    id?: string
    raised_by_user_id: string
    reason?: string | null
    description?: string | null
    status?: $Enums.P2PDisputeStatus
    resolved_by_admin_id?: string | null
    resolution_note?: string | null
    resolved_at?: Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type p2p_ratingsCreateManyOrderInput = {
    id?: string
    from_user_id: string
    to_user_id: string
    stars: number
    comment?: string | null
    created_at?: Date | string
  }

  export type p2p_messagesUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: usersUpdateOneRequiredWithoutP2p_messages_sentNestedInput
  }

  export type p2p_messagesUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_messagesUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    raised_by?: usersUpdateOneRequiredWithoutP2p_disputes_raisedNestedInput
  }

  export type p2p_disputesUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    raised_by_user_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_disputesUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    raised_by_user_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PDisputeStatusFieldUpdateOperationsInput | $Enums.P2PDisputeStatus
    resolved_by_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_note?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    from_user?: usersUpdateOneRequiredWithoutP2p_ratings_fromNestedInput
    to_user?: usersUpdateOneRequiredWithoutP2p_ratings_toNestedInput
  }

  export type p2p_ratingsUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type p2p_ratingsUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}