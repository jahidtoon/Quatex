// Forex candle aggregation and storage system
// Handles 1m base candles and aggregates to higher timeframes

import prisma from './prisma.js';
import { fetchForexPrices } from './forexPriceFeed.js';

// NOTE: Previously we had a race window -> findUnique + create could collide under rapid parallel price updates
// causing: Unique constraint failed on (symbol, interval, time). We now use an upsert style helper.

// In-memory buffer: key => `${symbol}|1m|${epochMinute}`
const candleBuffer = new Map();
const FLUSH_INTERVAL_MS = 1000; // flush every 1s
let flushTimer = null;

function startFlushLoop() {
  if (flushTimer) return;
  flushTimer = setInterval(() => {
    flushBufferedCandles().catch(err => console.warn('[forex-candles] flush error', err.message));
  }, FLUSH_INTERVAL_MS);
}

export async function flushBufferedCandles() {
  if (candleBuffer.size === 0) return 0;
  const now = Date.now();
  let processed = 0;

  // Prepare batch operations
  const createOperations = [];
  const updateOperations = [];

  // Iterate current buffer WITHOUT clearing so we preserve open/high/low for rest of minute
  for (const [key, data] of candleBuffer.entries()) {
    try {
      const { symbol, time } = data;
      const open = data.open;
      const high = data.high;
      const low = data.low;
      const close = data.close;

      // Check if candle exists (we'll do this in batch later)
      // For now, prepare upsert operations
      createOperations.push({
        symbol,
        interval: '1m',
        time,
        open,
        high,
        low,
        close
      });

      processed++;

      // If the candle minute is finished (older than 70s as a safety), drop it from buffer to free memory
      if (now - time.getTime() > 70 * 1000) {
        candleBuffer.delete(key);
      }
    } catch (e) {
      console.warn('[forex-candles] prepare row failed', e.message);
    }
  }

  if (createOperations.length === 0) return processed;

  try {
    // Use batch upsert operations
    await prisma.$transaction(
      createOperations.map(candle => {
        return prisma.forex_candles.upsert({
          where: {
            symbol_interval_time: {
              symbol: candle.symbol,
              interval: candle.interval,
              time: candle.time
            }
          },
          create: candle,
          update: {
            high: candle.high,
            low: candle.low,
            close: candle.close,
            updated_at: new Date()
          }
        });
      })
    );
  } catch (e) {
    console.warn('[forex-candles] batch flush failed, falling back to individual operations', e.message);

    // Fallback to individual operations if batch fails
    for (const candle of createOperations) {
      try {
        await prisma.forex_candles.upsert({
          where: {
            symbol_interval_time: {
              symbol: candle.symbol,
              interval: candle.interval,
              time: candle.time
            }
          },
          create: candle,
          update: {
            high: candle.high,
            low: candle.low,
            close: candle.close,
            updated_at: new Date()
          }
        });
      } catch (e) {
        console.warn('[forex-candles] individual flush row failed', e.message);
      }
    }
  }

  return processed;
}

async function upsertMinuteCandle({ symbol, time, priceDecimal }) {
  // Use a single query path when possible; Prisma upsert needs a unique where
  // composed field alias generated by @@unique => symbol_interval_time
  try {
    return await prisma.forex_candles.upsert({
      where: {
        symbol_interval_time: { symbol, interval: '1m', time }
      },
      create: {
        symbol,
        interval: '1m',
        time,
        open: priceDecimal,
        high: priceDecimal,
        low: priceDecimal,
        close: priceDecimal
      },
      update: {
        // For update we need to fetch existing first to properly adjust high/low.
        // However Prisma upsert update block does not expose existing row.
        // So we run a lightweight select first; this is still race-safe because upsert ensures atomicity.
        // We'll compute high/low with a separate read.
      }
    });
  } catch (e) {
    // Fallback (should be rare). We'll perform manual logic.
    const existing = await prisma.forex_candles.findUnique({
      where: { symbol_interval_time: { symbol, interval: '1m', time } }
    });
    if (!existing) {
      return prisma.forex_candles.create({
        data: { symbol, interval: '1m', time, open: priceDecimal, high: priceDecimal, low: priceDecimal, close: priceDecimal }
      });
    }
    const newHigh = Number(priceDecimal) > Number(existing.high) ? priceDecimal : existing.high;
    const newLow = Number(priceDecimal) < Number(existing.low) ? priceDecimal : existing.low;
    return prisma.forex_candles.update({
      where: { id: existing.id },
      data: { high: newHigh, low: newLow, close: priceDecimal, updated_at: new Date() }
    });
  }
}

// Round down to nearest minute bucket for consistent time alignment
function minuteBucket(date) {
  const d = new Date(date);
  d.setSeconds(0, 0);
  return d;
}

// Update or create a 1m candle from price data
export async function updateForexCandle(symbol, price, timestamp = new Date()) {
  const time = minuteBucket(timestamp);
  const priceNum = Number(price);
  const priceDecimal = String(priceNum);
  try {
    // Buffer aggregation path
    const key = `${symbol}|1m|${time.getTime()}`;
    const existing = candleBuffer.get(key);
    if (!existing) {
      candleBuffer.set(key, { symbol, time, open: priceDecimal, high: priceDecimal, low: priceDecimal, close: priceDecimal });
    } else {
      // merge
      if (priceNum > Number(existing.high)) existing.high = priceDecimal;
      if (priceNum < Number(existing.low)) existing.low = priceDecimal;
      existing.close = priceDecimal; // latest trade price becomes close
    }
    startFlushLoop();
    return true;
  } catch (error) {
    console.warn(`[forex-candles] Buffer update failed for ${symbol}:`, error.message);
    return false;
  }
}

// Manual flush trigger (useful for tests or graceful shutdown)
export async function forceFlush() {
  return flushBufferedCandles();
}

// Aggregate 1m candles to higher timeframes
export async function aggregateForexCandles(symbol, interval, startTime, endTime) {
  const intervalMinutes = getIntervalMinutes(interval);
  if (intervalMinutes <= 1) {
    // For 1m, just return stored data
    return await prisma.forex_candles.findMany({
      where: {
        symbol,
        interval: '1m',
        time: { gte: startTime, lte: endTime }
      },
      orderBy: { time: 'asc' }
    });
  }
  
  // Aggregate 1m candles for higher timeframes
  const oneMinuteCandles = await prisma.forex_candles.findMany({
    where: {
      symbol,
      interval: '1m',
      time: { gte: startTime, lte: endTime }
    },
    orderBy: { time: 'asc' }
  });
  
  if (!oneMinuteCandles.length) return [];
  
  // Group by time buckets
  const buckets = new Map();
  for (const candle of oneMinuteCandles) {
    const bucketTime = getTimeBucket(candle.time, intervalMinutes);
    const key = bucketTime.getTime();
    
    if (!buckets.has(key)) {
      buckets.set(key, {
        symbol,
        interval,
        time: bucketTime,
        open: Number(candle.open),
        high: Number(candle.high),
        low: Number(candle.low),
        close: Number(candle.close),
        created_at: candle.created_at,
        updated_at: candle.updated_at
      });
    } else {
      const bucket = buckets.get(key);
      bucket.high = Math.max(bucket.high, Number(candle.high));
      bucket.low = Math.min(bucket.low, Number(candle.low));
      bucket.close = Number(candle.close); // Latest close
      bucket.updated_at = candle.updated_at;
    }
  }
  
  return Array.from(buckets.values());
}

// Get time bucket for aggregation
function getTimeBucket(time, intervalMinutes) {
  const date = new Date(time);
  
  if (intervalMinutes < 60) {
    // For minutes, round down to nearest interval
    const minutes = Math.floor(date.getMinutes() / intervalMinutes) * intervalMinutes;
    date.setMinutes(minutes, 0, 0);
  } else if (intervalMinutes < 1440) {
    // For hours, round down to nearest hour
    const hours = Math.floor(intervalMinutes / 60);
    const roundedHour = Math.floor(date.getHours() / hours) * hours;
    date.setHours(roundedHour, 0, 0, 0);
  } else {
    // For days, start of day
    date.setHours(0, 0, 0, 0);
  }
  
  return date;
}

// Convert interval string to minutes
function getIntervalMinutes(interval) {
  const map = {
    '1m': 1,
    '5m': 5,
    '15m': 15,
    '30m': 30,
    '1h': 60,
    '4h': 240,
    '1d': 1440
  };
  return map[interval] || 1;
}

// Backfill forex data for testing (simulated historical data)
export async function backfillForexData(symbol, hours = 24) {
  console.log(`[forex-candles] Backfilling ${symbol} for ${hours} hours`);
  
  const now = new Date();
  const startTime = new Date(now.getTime() - hours * 60 * 60 * 1000);
  
  // Get current price as base
  const prices = await fetchForexPrices([symbol]);
  const currentPrice = prices[symbol];
  
  if (!currentPrice) {
    console.warn(`[forex-candles] No current price for ${symbol}`);
    return;
  }
  
  // Generate simulated historical data
  let price = currentPrice * (0.98 + Math.random() * 0.04); // Start with slight variation
  
  for (let i = 0; i < hours * 60; i++) {
    const timestamp = new Date(startTime.getTime() + i * 60 * 1000);
    
    // Simulate forex price movement (smaller than crypto volatility)
    const change = (Math.random() - 0.5) * 0.002; // Â±0.1% per minute max
    price *= (1 + change);
    
    // Keep price within reasonable bounds
    price = Math.max(price, currentPrice * 0.95);
    price = Math.min(price, currentPrice * 1.05);
    
    await updateForexCandle(symbol, price, timestamp);
  }
  
  console.log(`[forex-candles] Backfilled ${hours * 60} candles for ${symbol}`);
}

// Cleanup old forex candles (keep last 30 days)
export async function cleanupOldForexCandles() {
  const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  
  const deleted = await prisma.forex_candles.deleteMany({
    where: {
      time: { lt: cutoff }
    }
  });
  
  console.log(`[forex-candles] Cleaned up ${deleted.count} old candles`);
  return deleted.count;
}
